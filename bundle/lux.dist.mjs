var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { get as get$3, transformExtent, getTransform, transform as transform$1 } from "ol/proj";
import { register } from "ol/proj/proj4";
import OlMap from "ol/Map";
import OlView from "ol/View";
import ImageLayer from "ol/layer/Image";
import TileLayer from "ol/layer/Tile";
import { ImageWMS, WMTS } from "ol/source";
import Layer from "ol/layer/Layer";
import { toDegrees } from "ol/math";
import { toLonLat } from "ol/proj.js";
import WmtsTileGrid from "ol/tilegrid/WMTS";
import { getTopLeft } from "ol/extent.js";
import * as olEvents from "ol/events";
import ObjectEventType from "ol/ObjectEventType";
import Attribution from "ol/control/Attribution";
import { CLASS_UNSELECTABLE, CLASS_CONTROL } from "ol/css";
import Control from "ol/control/Control";
import FullScreen from "ol/control/FullScreen";
import Zoom from "ol/control/Zoom";
import OlControlZoomToExtent from "ol/control/ZoomToExtent";
import WMTSCapabilities from "ol/format/WMTSCapabilities.js";
import { getRenderPixel } from "ol/render";
import { unByKey } from "ol/Observable";
import EventType from "ol/render/EventType";
import olLayerGroup from "ol/layer/Group.js";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
const EMPTY_ARR = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr2, el) => {
  const i = arr2.indexOf(el);
  if (i > -1) {
    arr2.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_23, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize$1 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize$1(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$1(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn$1(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (process.env.NODE_ENV !== "production") {
    warn$1(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = process.env.NODE_ENV !== "production" ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (process.env.NODE_ENV !== "production" && activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = process.env.NODE_ENV !== "production" ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (process.env.NODE_ENV !== "production" && effect.onTrigger) {
      effect.onTrigger(extend$2({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr2 = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr2, "get", i + "");
      }
      const res = arr2[key](...args);
      if (res === -1 || res === false) {
        return arr2[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow$1(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$8(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$8
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$2({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$2({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$1(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = process.env.NODE_ENV !== "production" ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (process.env.NODE_ENV !== "production") {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize$1(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow$1(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (process.env.NODE_ENV !== "production") {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow$1(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  if (process.env.NODE_ENV !== "production" && !isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = process.env.NODE_ENV !== "production" ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (process.env.NODE_ENV !== "production" && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn(msg, ...args) {
  if (!(process.env.NODE_ENV !== "production"))
    return;
  pauseTracking();
  const instance2 = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance2 && instance2.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance2, 11, [
      msg + args.join(""),
      instance2 && instance2.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance2, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (!(process.env.NODE_ENV !== "production"))
    return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance2, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance2, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance2, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance2, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance2, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance2, type, args));
  }
  return values;
}
function handleError(err, instance2, type, throwInDev = true) {
  const contextVNode = instance2 ? instance2.vnode : null;
  if (instance2) {
    let cur = instance2.parent;
    const exposedInstance = instance2.proxy;
    const errorInfo = process.env.NODE_ENV !== "production" ? ErrorTypeStrings[type] : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance2.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (process.env.NODE_ENV !== "production") {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start2 = middle + 1 : end = middle;
  }
  return start2;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (process.env.NODE_ENV !== "production") {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = process.env.NODE_ENV !== "production" ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (process.env.NODE_ENV !== "production" && check(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance2 = fn.ownerInstance;
      const componentName = instance2 && getComponentName(instance2.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (process.env.NODE_ENV !== "production") {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map$1 = /* @__PURE__ */ new Map();
function registerHMR(instance2) {
  const id = instance2.type.__hmrId;
  let record = map$1.get(id);
  if (!record) {
    createRecord(id, instance2.type);
    record = map$1.get(id);
  }
  record.instances.add(instance2);
}
function unregisterHMR(instance2) {
  map$1.get(instance2.type.__hmrId).instances.delete(instance2);
}
function createRecord(id, initialDef) {
  if (map$1.has(id)) {
    return false;
  }
  map$1.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map$1.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance2) => {
    if (newRender) {
      instance2.render = newRender;
      normalizeClassComponent(instance2.type).render = newRender;
    }
    instance2.renderCache = [];
    isHmrUpdating = true;
    instance2.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map$1.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance2 of instances) {
    const oldComp = normalizeClassComponent(instance2.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance2.appContext.optionsCache.delete(instance2.type);
    if (instance2.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance2.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance2.parent) {
      queueJob(instance2.parent.update);
    } else if (instance2.appContext.reload) {
      instance2.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance2 of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance2.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend$2(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app2, version2) {
  emit$1("app:init", app2, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app2) {
  emit$1("app:unmount", app2);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
const devtoolsComponentRemoved = (component) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params2) {
  emit$1("component:emit", component.appContext.app, component, event, params2);
}
function emit(instance2, event, ...rawArgs) {
  if (instance2.isUnmounted)
    return;
  const props = instance2.vnode.props || EMPTY_OBJ;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions, propsOptions: [propsOptions] } = instance2;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsComponentEmit(instance2, event, args);
  }
  if (process.env.NODE_ENV !== "production") {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance2, instance2.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance2, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance2.emitted) {
      instance2.emitted = {};
    } else if (instance2.emitted[handlerName]) {
      return;
    }
    instance2.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance2, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance2) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance2;
  currentScopeId = instance2 && instance2.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance2) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance2;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance2);
  if (process.env.NODE_ENV !== "production") {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (process.env.NODE_ENV !== "production" && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render3.length > 1 ? render3(props, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance2, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (process.env.NODE_ENV !== "production" && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (process.env.NODE_ENV !== "production" && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root.transition = vnode.transition;
  }
  if (process.env.NODE_ENV !== "production" && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    if (process.env.NODE_ENV !== "production") {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance2 = currentInstance || currentRenderingInstance;
  if (instance2) {
    const provides = instance2.parent == null ? instance2.vnode.appContext && instance2.vnode.appContext.provides : instance2.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance2.proxy) : defaultValue;
    } else if (process.env.NODE_ENV !== "production") {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (process.env.NODE_ENV !== "production" && !isFunction(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  if (process.env.NODE_ENV !== "production" && !cb) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance2 = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow$1(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance2, 2);
      } else {
        process.env.NODE_ENV !== "production" && warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance2, 2);
    } else {
      getter = () => {
        if (instance2 && instance2.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance2, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    process.env.NODE_ENV !== "production" && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance2, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance2, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance2, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance2 && instance2.suspense);
  } else {
    job.pre = true;
    if (instance2)
      job.id = instance2.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (process.env.NODE_ENV !== "production") {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance2 && instance2.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance2 && instance2.scope) {
      remove(instance2.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c2 of children) {
          if (c2.type !== Comment) {
            if (process.env.NODE_ENV !== "production" && hasFound) {
              warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            child = c2;
            hasFound = true;
            if (!(process.env.NODE_ENV !== "production"))
              break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      if (process.env.NODE_ENV !== "production" && mode2 && mode2 !== "in-out" && mode2 !== "out-in" && mode2 !== "default") {
        warn(`invalid <transition> mode: ${mode2}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance2);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance2.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance2);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance2.update.active !== false) {
              instance2.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance2) {
  const { appear, mode: mode2, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance2, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance2);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (process.env.NODE_ENV !== "production") {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    process.env.NODE_ENV !== "production" && warn(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance2 = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance: instance2,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance2, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance2, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance2 = currentRenderingInstance || currentInstance;
  if (instance2) {
    const Component = instance2.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance2[type] || Component[type], name) || resolve(instance2.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (process.env.NODE_ENV !== "production" && warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (process.env.NODE_ENV !== "production") {
    warn(`resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if (process.env.NODE_ENV !== "production" && !Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (process.env.NODE_ENV !== "production" && slot && slot.length > 1) {
    warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || validSlotContent && validSlotContent.key || `_${name}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.props) : i.props,
  $attrs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.attrs) : i.attrs,
  $slots: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.slots) : i.slots,
  $refs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.refs) : i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: (i) => instanceWatch.bind(i)
});
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance2 }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance2;
    if (process.env.NODE_ENV !== "production" && key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance2.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance2, "get", key);
        process.env.NODE_ENV !== "production" && markAttrsAccessed();
      }
      return publicGetter(instance2);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (process.env.NODE_ENV !== "production" && currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance2 === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance2 }, key, value) {
    const { data, setupState, ctx } = instance2;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (process.env.NODE_ENV !== "production" && setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance2.props, key)) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance2) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
      return false;
    } else {
      if (process.env.NODE_ENV !== "production" && key in instance2.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (process.env.NODE_ENV !== "production" && true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance2) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance2
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance2),
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance2) {
  const { ctx, propsOptions: [propsOptions] } = instance2;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance2.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance2) {
  const { ctx, setupState } = instance2;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance2) {
  const options = resolveMergedOptions(instance2);
  const publicThis = instance2.proxy;
  const ctx = instance2.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance2, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = process.env.NODE_ENV !== "production" ? createDuplicateChecker() : null;
  if (process.env.NODE_ENV !== "production") {
    const [propsOptions] = instance2.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance2.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (process.env.NODE_ENV !== "production") {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (process.env.NODE_ENV !== "production") {
          checkDuplicateProperties("Methods", key);
        }
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (process.env.NODE_ENV !== "production" && !isFunction(dataOptions)) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (process.env.NODE_ENV !== "production" && isPromise$1(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject(data)) {
      process.env.NODE_ENV !== "production" && warn(`data() should return an object.`);
    } else {
      instance2.data = reactive(data);
      if (process.env.NODE_ENV !== "production") {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (process.env.NODE_ENV !== "production" && get2 === NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : process.env.NODE_ENV !== "production" ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
      if (process.env.NODE_ENV !== "production") {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance2, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance2.exposed || (instance2.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance2.exposed) {
      instance2.exposed = {};
    }
  }
  if (render2 && instance2.render === NOOP) {
    instance2.render = render2;
  }
  if (inheritAttrs != null) {
    instance2.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance2.components = components;
  if (directives)
    instance2.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        if (process.env.NODE_ENV !== "production") {
          warn(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    if (process.env.NODE_ENV !== "production") {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance2, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) => h2.bind(instance2.proxy)) : hook.bind(instance2.proxy), instance2, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (process.env.NODE_ENV !== "production") {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance2) {
  const base = instance2.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance2.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      process.env.NODE_ENV !== "production" && warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$2(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$2(extend$2(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance2, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance2.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance2, rawProps, props, attrs);
  for (const key in instance2.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance2);
  }
  if (isStateful) {
    instance2.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance2.type.props) {
      instance2.props = attrs;
    } else {
      instance2.props = props;
    }
  }
  instance2.attrs = attrs;
}
function isInHmrContext(instance2) {
  while (instance2) {
    if (instance2.type.__hmrId)
      return true;
    instance2 = instance2.parent;
  }
}
function updateProps(instance2, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance2;
  const rawCurrentProps = toRaw(props);
  const [options] = instance2.propsOptions;
  let hasAttrsChanged = false;
  if (!(process.env.NODE_ENV !== "production" && isInHmrContext(instance2)) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance2.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance2.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance2, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance2, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance2, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance2, "set", "$attrs");
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance2);
  }
}
function setFullProps(instance2, rawProps, props, attrs) {
  const [options, needCastKeys] = instance2.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance2.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance2, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance2, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance2;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance2);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (process.env.NODE_ENV !== "production" && !isString(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (process.env.NODE_ENV !== "production" && !isObject(raw)) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match2 ? match2[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance2) {
  const resolvedValues = toRaw(props);
  const options = instance2.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (process.env.NODE_ENV !== "production" && currentInstance) {
      warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance2) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (process.env.NODE_ENV !== "production" && true) {
        warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance2, children) => {
  if (process.env.NODE_ENV !== "production" && !isKeepAlive(instance2.vnode) && true) {
    warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance2.slots.default = () => normalized;
};
const initSlots = (instance2, children) => {
  if (instance2.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance2.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance2.slots = {});
    }
  } else {
    instance2.slots = {};
    if (children) {
      normalizeVNodeSlots(instance2, children);
    }
  }
  def(instance2.slots, InternalObjectKey, 1);
};
const updateSlots = (instance2, children, optimized) => {
  const { vnode, slots } = instance2;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
        extend$2(slots, children);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      process.env.NODE_ENV !== "production" && warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v2) {
        if (process.env.NODE_ENV !== "production") {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
          process.env.NODE_ENV !== "production" && warn(`Plugin has already been applied to target app.`);
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else if (process.env.NODE_ENV !== "production") {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (process.env.NODE_ENV !== "production") {
            warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app2;
      },
      component(name, component) {
        if (process.env.NODE_ENV !== "production") {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (process.env.NODE_ENV !== "production" && context.components[name]) {
          warn(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (process.env.NODE_ENV !== "production") {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (process.env.NODE_ENV !== "production" && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (process.env.NODE_ENV !== "production" && rootContainer.__vue_app__) {
            warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (process.env.NODE_ENV !== "production") {
            context.reload = () => {
              render2(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          if (process.env.NODE_ENV !== "production" || false) {
            app2._instance = vnode.component;
            devtoolsInitApp(app2, version$1);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          if (process.env.NODE_ENV !== "production" || false) {
            app2._instance = null;
            devtoolsUnmountApp(app2);
          }
          delete app2._container.__vue_app__;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (process.env.NODE_ENV !== "production" && key in context.provides) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (process.env.NODE_ENV !== "production" && !owner) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let supported$1;
let perf$1;
function startMeasure(instance2, type) {
  if (instance2.appContext.config.performance && isSupported()) {
    perf$1.mark(`vue-${type}-${instance2.uid}`);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfStart(instance2, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function endMeasure(instance2, type) {
  if (instance2.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance2.uid}`;
    const endTag = startTag + `:end`;
    perf$1.mark(endTag);
    perf$1.measure(`<${formatComponentName(instance2, instance2.type)}> ${type}`, startTag, endTag);
    perf$1.clearMarks(startTag);
    perf$1.clearMarks(endTag);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfEnd(instance2, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$1 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
function initFeatureFlags() {
  const needWarn = [];
  if (process.env.NODE_ENV !== "production" && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (process.env.NODE_ENV !== "production" || false) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = process.env.NODE_ENV !== "production" && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (process.env.NODE_ENV !== "production") {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (process.env.NODE_ENV !== "production" && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (process.env.NODE_ENV !== "production" && (isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance2 = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (process.env.NODE_ENV !== "production" && instance2.type.__hmrId) {
      registerHMR(instance2);
    }
    if (process.env.NODE_ENV !== "production") {
      pushWarningContext(initialVNode);
      startMeasure(instance2, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance2.ctx.renderer = internals;
    }
    {
      if (process.env.NODE_ENV !== "production") {
        startMeasure(instance2, `init`);
      }
      setupComponent(instance2);
      if (process.env.NODE_ENV !== "production") {
        endMeasure(instance2, `init`);
      }
    }
    if (instance2.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance2, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance2.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance2, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    if (process.env.NODE_ENV !== "production") {
      popWarningContext();
      endMeasure(instance2, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance2 = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance2.asyncDep && !instance2.asyncResolved) {
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance2, n2, optimized);
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
        return;
      } else {
        instance2.next = n2;
        invalidateJob(instance2.update);
        instance2.update();
      }
    } else {
      n2.el = n1.el;
      instance2.vnode = n2;
    }
  };
  const setupRenderEffect = (instance2, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance2.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance2;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance2, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance2, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance2, `render`);
            }
            instance2.subTree = renderComponentRoot(instance2);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance2, `render`);
            }
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance2, `hydrate`);
            }
            hydrateNode(el, instance2.subTree, instance2, parentSuspense, null);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance2, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance2.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance2, `render`);
          }
          const subTree = instance2.subTree = renderComponentRoot(instance2);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance2, `render`);
          }
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance2, `patch`);
          }
          patch(null, subTree, container, anchor, instance2, parentSuspense, isSVG);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance2, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance2.a && queuePostRenderEffect(instance2.a, parentSuspense);
        }
        instance2.isMounted = true;
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentAdded(instance2);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance2;
        let originNext = next;
        let vnodeHook;
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(next || instance2.vnode);
        }
        toggleRecurse(instance2, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance2, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance2, true);
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance2, `render`);
        }
        const nextTree = renderComponentRoot(instance2);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance2, `render`);
        }
        const prevTree = instance2.subTree;
        instance2.subTree = nextTree;
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance2, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance2,
          parentSuspense,
          isSVG
        );
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance2, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance2, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentUpdated(instance2);
        }
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
      }
    };
    const effect = instance2.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance2.scope
    );
    const update = instance2.update = () => effect.run();
    update.id = instance2.uid;
    toggleRecurse(instance2, true);
    if (process.env.NODE_ENV !== "production") {
      effect.onTrack = instance2.rtc ? (e) => invokeArrayFns(instance2.rtc, e) : void 0;
      effect.onTrigger = instance2.rtg ? (e) => invokeArrayFns(instance2.rtg, e) : void 0;
      update.ownerInstance = instance2;
    }
    update();
  };
  const updateComponentPreRender = (instance2, nextVNode, optimized) => {
    nextVNode.component = instance2;
    const prevProps = instance2.vnode.props;
    instance2.vnode = nextVNode;
    instance2.next = null;
    updateProps(instance2, nextVNode.props, prevProps, optimized);
    updateSlots(instance2, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (process.env.NODE_ENV !== "production" && keyToNewIndexMap.has(nextChild.key)) {
            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex2;
        if (prevChild.key != null) {
          newIndex2 = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex2 = j;
              break;
            }
          }
        }
        if (newIndex2 === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex2 - s2] = i + 1;
          if (newIndex2 >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex2;
          } else {
            moved2 = true;
          }
          patch(prevChild, c2[newIndex2], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved2) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (process.env.NODE_ENV !== "production" && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance2, parentSuspense, doRemove) => {
    if (process.env.NODE_ENV !== "production" && instance2.type.__hmrId) {
      unregisterHMR(instance2);
    }
    const { bum, scope, update, subTree, um } = instance2;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance2, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance2.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance2.asyncDep && !instance2.asyncResolved && instance2.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentRemoved(instance2);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (process.env.NODE_ENV !== "production" && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr2) {
  const p2 = arr2.slice();
  const result = [0];
  let i, j, u, v2, c2;
  const len = arr2.length;
  for (i = 0; i < len; i++) {
    const arrI = arr2[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr2[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c2 = u + v2 >> 1;
        if (arr2[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr2[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      process.env.NODE_ENV !== "production" && warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
        process.env.NODE_ENV !== "production" && warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
      }
      return target;
    }
  } else {
    if (process.env.NODE_ENV !== "production" && !targetSelector && !isTeleportDisabled(props)) {
      warn(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = process.env.NODE_ENV !== "production" ? createComment("teleport start") : createText("");
      const mainAnchor = n2.anchor = process.env.NODE_ENV !== "production" ? createComment("teleport end") : createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      } else if (process.env.NODE_ENV !== "production" && !disabled) {
        warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else if (process.env.NODE_ENV !== "production") {
            warn("Invalid Teleport target on update:", target, `(${typeof target})`);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0);
const Text = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0);
const Comment = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0);
const Static = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (process.env.NODE_ENV !== "production" && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (process.env.NODE_ENV !== "production" && vnode.key !== vnode.key) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = process.env.NODE_ENV !== "production" ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (process.env.NODE_ENV !== "production" && !type) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend$2({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (process.env.NODE_ENV !== "production" && shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text2 = " ", flag = 0) {
  return createVNode(Text, null, text2, flag);
}
function createCommentVNode(text2 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance2, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance2, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance2 = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (process.env.NODE_ENV !== "production") {
    instance2.ctx = createDevRenderContext(instance2);
  } else {
    instance2.ctx = { _: instance2 };
  }
  instance2.root = parent ? parent.root : instance2;
  instance2.emit = emit.bind(null, instance2);
  if (vnode.ce) {
    vnode.ce(instance2);
  }
  return instance2;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance2) => {
  currentInstance = instance2;
  instance2.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance2) {
  return instance2.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance2, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance2.vnode;
  const isStateful = isStatefulComponent(instance2);
  initProps(instance2, props, isStateful, isSSR);
  initSlots(instance2, children);
  const setupResult = isStateful ? setupStatefulComponent(instance2, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance2, isSSR) {
  var _a;
  const Component = instance2.type;
  if (process.env.NODE_ENV !== "production") {
    if (Component.name) {
      validateComponentName(Component.name, instance2.appContext.config);
    }
    if (Component.components) {
      const names2 = Object.keys(Component.components);
      for (let i = 0; i < names2.length; i++) {
        validateComponentName(names2[i], instance2.appContext.config);
      }
    }
    if (Component.directives) {
      const names2 = Object.keys(Component.directives);
      for (let i = 0; i < names2.length; i++) {
        validateDirectiveName(names2[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance2.accessCache = /* @__PURE__ */ Object.create(null);
  instance2.proxy = markRaw(new Proxy(instance2.ctx, PublicInstanceProxyHandlers));
  if (process.env.NODE_ENV !== "production") {
    exposePropsOnRenderContext(instance2);
  }
  const { setup } = Component;
  if (setup) {
    const setupContext = instance2.setupContext = setup.length > 1 ? createSetupContext(instance2) : null;
    setCurrentInstance(instance2);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance2, 0, [process.env.NODE_ENV !== "production" ? shallowReadonly(instance2.props) : instance2.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance2, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance2, 0);
        });
      } else {
        instance2.asyncDep = setupResult;
        if (process.env.NODE_ENV !== "production" && !instance2.suspense) {
          const name = (_a = Component.name) !== null && _a !== void 0 ? _a : "Anonymous";
          warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance2, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance2, isSSR);
  }
}
function handleSetupResult(instance2, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance2.type.__ssrInlineRender) {
      instance2.ssrRender = setupResult;
    } else {
      instance2.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (process.env.NODE_ENV !== "production" && isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    if (process.env.NODE_ENV !== "production" || false) {
      instance2.devtoolsRawSetupState = setupResult;
    }
    instance2.setupState = proxyRefs(setupResult);
    if (process.env.NODE_ENV !== "production") {
      exposeSetupStateOnRenderContext(instance2);
    }
  } else if (process.env.NODE_ENV !== "production" && setupResult !== void 0) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance2, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance2, isSSR, skipOptions) {
  const Component = instance2.type;
  if (!instance2.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance2).template;
      if (template) {
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance2, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance2.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(extend$2({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance2, `compile`);
        }
      }
    }
    instance2.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance2);
    pauseTracking();
    applyOptions(instance2);
    resetTracking();
    unsetCurrentInstance();
  }
  if (process.env.NODE_ENV !== "production" && !Component.render && instance2.render === NOOP && !isSSR) {
    if (Component.template) {
      warn(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance2) {
  return new Proxy(instance2.attrs, process.env.NODE_ENV !== "production" ? {
    get(target, key) {
      markAttrsAccessed();
      track(instance2, "get", "$attrs");
      return target[key];
    },
    set() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(instance2, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance2) {
  const expose = (exposed) => {
    if (process.env.NODE_ENV !== "production") {
      if (instance2.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
      }
    }
    instance2.exposed = exposed || {};
  };
  let attrs;
  if (process.env.NODE_ENV !== "production") {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance2));
      },
      get slots() {
        return shallowReadonly(instance2.slots);
      },
      get emit() {
        return (event, ...args) => instance2.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance2));
      },
      slots: instance2.slots,
      emit: instance2.emit,
      expose
    };
  }
}
function getExposeProxy(instance2) {
  if (instance2.exposed) {
    return instance2.exposeProxy || (instance2.exposeProxy = new Proxy(proxyRefs(markRaw(instance2.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance2);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance2, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance2 && instance2.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance2.components || instance2.parent.type.components) || inferFromRegistry(instance2.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(process.env.NODE_ENV !== "production" ? `ssrContext` : ``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      process.env.NODE_ENV !== "production" && warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function initCustomFormatter() {
  if (!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance2) {
    const blocks = [];
    if (instance2.type.props && instance2.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance2.props)));
    }
    if (instance2.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance2.setupState));
    }
    if (instance2.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance2.data)));
    }
    const computed2 = extractKeys(instance2, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance2, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance2 }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend$2({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v2, asRaw = true) {
    if (typeof v2 === "number") {
      return ["span", numberStyle, v2];
    } else if (typeof v2 === "string") {
      return ["span", stringStyle, JSON.stringify(v2)];
    } else if (typeof v2 === "boolean") {
      return ["span", keywordStyle, v2];
    } else if (isObject(v2)) {
      return ["object", { object: asRaw ? toRaw(v2) : v2 }];
    } else {
      return ["span", stringStyle, String(v2)];
    }
  }
  function extractKeys(instance2, type) {
    const Comp = instance2.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance2.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance2.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v2) {
    if (isShallow(v2)) {
      return `ShallowRef`;
    }
    if (v2.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
const version$1 = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text2) => doc.createTextNode(text2),
  createComment: (text2) => doc.createComment(text2),
  setText: (node, text2) => {
    node.nodeValue = text2;
  },
  setElementText: (el, text2) => {
    el.textContent = text2;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  insertStaticContent(content, parent, anchor, isSVG, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null)
      val = "";
    if (process.env.NODE_ENV !== "production") {
      if (semicolonRE.test(val)) {
        warn(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance2) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (process.env.NODE_ENV !== "production" && !needRemove) {
      warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance2 = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance2);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance2) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance2, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$2({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (process.env.NODE_ENV !== "production") {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  if (process.env.NODE_ENV !== "production") {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function injectNativeTagCheck(app2) {
  Object.defineProperty(app2.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app2) {
  {
    const isCustomElement = app2.config.isCustomElement;
    Object.defineProperty(app2.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app2.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app2.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (process.env.NODE_ENV !== "production" && !res) {
      warn(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (process.env.NODE_ENV !== "production" && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
function initDev() {
  {
    initCustomFormatter();
  }
}
if (process.env.NODE_ENV !== "production") {
  initDev();
}
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$4()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance2 = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance2, Class2.prototype);
      return instance2;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray$1(arr2) || _unsupportedIterableToArray$1(arr2) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray$1(arr2);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone$1(object) {
  var newObject = create(null);
  var property;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property]) === true) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof$5(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_23) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.4.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone$1(document2).documentMode ? document2.documentMode : {};
  } catch (_23) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var ALLOW_SELF_CLOSE_IN_ATTR = true;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var ALLOWED_NAMESPACES = null;
  var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof$5(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone$1(cfg);
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),
      cfg.ADD_URI_SAFE_ATTR,
      transformCaseFunc
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone$1(DEFAULT_DATA_URI_TAGS),
      cfg.ADD_DATA_URI_TAGS,
      transformCaseFunc
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_23) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_24) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_23) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_23) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_23) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc2;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches2 && matches2[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc2 = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_23) {
      }
    }
    if (!doc2 || !doc2.documentElement) {
      doc2 = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_23) {
      }
    }
    var body = doc2.body || doc2.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc2.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  var _isNode = function _isNode2(object) {
    return _typeof$5(Node) === "object" ? object instanceof Node : object && _typeof$5(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, " ");
      content = stringReplace(content, ERB_EXPR$1, " ");
      content = stringReplace(content, TMPLIT_EXPR$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
        value = stringReplace(value, TMPLIT_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof$5(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML":
              value = trustedTypesPolicy.createHTML(value);
              break;
            case "TrustedScriptURL":
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_23) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof$5(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var isVue2 = false;
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
function p(o, i) {
  var _a;
  const n = (_a = o.hooks) != null ? _a : {};
  let t;
  for (t in n) {
    const e = n[t];
    e !== void 0 && i.addHook(t, e);
  }
}
function c() {
  return purify();
}
function v(o = {}, i = c) {
  const n = i();
  p(o, n);
  const t = function(e, r) {
    var _a, _b;
    const u = r.value;
    if (r.oldValue === u)
      return;
    const a = `${u}`, s = r.arg, d = o.namedConfigurations, f = (_a = o.default) != null ? _a : {};
    if (d && s !== void 0) {
      e.innerHTML = n.sanitize(
        a,
        (_b = d[s]) != null ? _b : f
      );
      return;
    }
    e.innerHTML = n.sanitize(
      a,
      f
    );
  };
  return {
    mounted: t,
    updated: t
  };
}
const y = {
  install(o, i = {}, n = c) {
    o.directive(
      "dompurify-html",
      v(i, n)
    );
  }
};
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function isPlainObject(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const USE_DEVTOOLS = (process.env.NODE_ENV !== "production" || false) && !(process.env.NODE_ENV === "test") && IS_CLIENT;
const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
  if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
  }
  return blob;
}
function download(url, name, opts) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console.error("could not download file");
  };
  xhr.send();
}
function corsEnabled(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
function click(node) {
  try {
    node.dispatchEvent(new MouseEvent("click"));
  } catch (e) {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node.dispatchEvent(evt);
  }
}
const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT ? () => {
} : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs;
function downloadSaveAs(blob, name = "download", opts) {
  const a = document.createElement("a");
  a.download = name;
  a.rel = "noopener";
  if (typeof blob === "string") {
    a.href = blob;
    if (a.origin !== location.origin) {
      if (corsEnabled(a.href)) {
        download(blob, name, opts);
      } else {
        a.target = "_blank";
        click(a);
      }
    } else {
      click(a);
    }
  } else {
    a.href = URL.createObjectURL(blob);
    setTimeout(function() {
      URL.revokeObjectURL(a.href);
    }, 4e4);
    setTimeout(function() {
      click(a);
    }, 0);
  }
}
function msSaveAs(blob, name = "download", opts) {
  if (typeof blob === "string") {
    if (corsEnabled(blob)) {
      download(blob, name, opts);
    } else {
      const a = document.createElement("a");
      a.href = blob;
      a.target = "_blank";
      setTimeout(function() {
        click(a);
      });
    }
  } else {
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
  }
}
function fileSaverSaveAs(blob, name, opts, popup) {
  popup = popup || open("", "_blank");
  if (popup) {
    popup.document.title = popup.document.body.innerText = "downloading...";
  }
  if (typeof blob === "string")
    return download(blob, name, opts);
  const force = blob.type === "application/octet-stream";
  const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
  const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
    const reader = new FileReader();
    reader.onloadend = function() {
      let url = reader.result;
      if (typeof url !== "string") {
        popup = null;
        throw new Error("Wrong reader.result type");
      }
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
      if (popup) {
        popup.location.href = url;
      } else {
        location.assign(url);
      }
      popup = null;
    };
    reader.readAsDataURL(blob);
  } else {
    const url = URL.createObjectURL(blob);
    if (popup)
      popup.location.assign(url);
    else
      location.href = url;
    popup = null;
    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 4e4);
  }
}
function toastMessage(message, type) {
  const piniaMessage = "\u{1F34D} " + message;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
function isPinia(o) {
  return "_a" in o && "install" in o;
}
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
function checkNotFocusedError(error2) {
  if (error2 instanceof Error && error2.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
  return false;
}
async function actionGlobalCopyState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
    toastMessage("Global state copied to clipboard.");
  } catch (error2) {
    if (checkNotFocusedError(error2))
      return;
    toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
    console.error(error2);
  }
}
async function actionGlobalPasteState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    pinia.state.value = JSON.parse(await navigator.clipboard.readText());
    toastMessage("Global state pasted from clipboard.");
  } catch (error2) {
    if (checkNotFocusedError(error2))
      return;
    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
    console.error(error2);
  }
}
async function actionGlobalSaveState(pinia) {
  try {
    saveAs(new Blob([JSON.stringify(pinia.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (error2) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error2);
  }
}
let fileInput;
function getFileOpener() {
  if (!fileInput) {
    fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve2, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files)
          return resolve2(null);
        const file = files.item(0);
        if (!file)
          return resolve2(null);
        return resolve2({ text: await file.text(), file });
      };
      fileInput.oncancel = () => resolve2(null);
      fileInput.onerror = reject;
      fileInput.click();
    });
  }
  return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
  try {
    const open2 = await getFileOpener();
    const result = await open2();
    if (!result)
      return;
    const { text: text2, file } = result;
    pinia.state.value = JSON.parse(text2);
    toastMessage(`Global state imported from "${file.name}".`);
  } catch (error2) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error2);
  }
}
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
const PINIA_ROOT_LABEL = "\u{1F34D} Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return isPinia(store) ? {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  } : {
    id: store.$id,
    label: store.$id
  };
}
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const storeNames = Array.from(store._s.keys());
    const storeMap = store._s;
    const state2 = {
      state: storeNames.map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      })),
      getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
        const store2 = storeMap.get(id);
        return {
          editable: false,
          key: id,
          value: store2._getters.reduce((getters, key) => {
            getters[key] = store2[key];
            return getters;
          }, {})
        };
      })
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
function formatEventData(events) {
  if (!events)
    return {};
  if (Array.isArray(events)) {
    return events.reduce((data, event) => {
      data.keys.push(event.key);
      data.operations.push(event.type);
      data.oldValue[event.key] = event.oldValue;
      data.newValue[event.key] = event.newValue;
      return data;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay(events.type),
      key: formatDisplay(events.key),
      oldValue: events.oldValue,
      newValue: events.newValue
    };
  }
}
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const { assign: assign$1 } = Object;
const getStoreType = (id) => "\u{1F34D} " + id;
function registerPiniaDevtools(app2, pinia) {
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2
  }, (api) => {
    if (typeof api.now !== "function") {
      toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: `Pinia \u{1F34D}`,
      color: 15064968
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            actionGlobalCopyState(pinia);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await actionGlobalPasteState(pinia);
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            actionGlobalSaveState(pinia);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await actionGlobalOpenStateFile(pinia);
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (nodeId) => {
            const store = pinia._s.get(nodeId);
            if (!store) {
              toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
            } else if (!store._isOptionsAPI) {
              toastMessage(`Cannot reset "${nodeId}" store because it's a setup store.`, "warn");
            } else {
              store.$reset();
              toastMessage(`Store "${nodeId}" reset.`);
            }
          }
        }
      ]
    });
    api.on.inspectComponent((payload, ctx) => {
      const proxy = payload.componentInstance && payload.componentInstance.proxy;
      if (proxy && proxy._pStores) {
        const piniaStores = payload.componentInstance.proxy._pStores;
        Object.values(piniaStores).forEach((store) => {
          payload.instanceData.state.push({
            type: getStoreType(store.$id),
            key: "state",
            editable: true,
            value: store._isOptionsAPI ? {
              _custom: {
                value: toRaw(store.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => store.$reset()
                  }
                ]
              }
            } : Object.keys(store.$state).reduce((state, key) => {
              state[key] = store.$state[key];
              return state;
            }, {})
          });
          if (store._getters && store._getters.length) {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "getters",
              editable: false,
              value: store._getters.reduce((getters, key) => {
                try {
                  getters[key] = store[key];
                } catch (error2) {
                  getters[key] = error2;
                }
                return getters;
              }, {})
            });
          }
        });
      }
    });
    api.on.getInspectorTree((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        let stores = [pinia];
        stores = stores.concat(Array.from(pinia._s.values()));
        payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
      }
    });
    api.on.getInspectorState((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
        if (!inspectedStore) {
          return;
        }
        if (inspectedStore) {
          payload.state = formatStoreForInspectorState(inspectedStore);
        }
      }
    });
    api.on.editInspectorState((payload, ctx) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
        if (!inspectedStore) {
          return toastMessage(`store "${payload.nodeId}" not found`, "error");
        }
        const { path } = payload;
        if (!isPinia(inspectedStore)) {
          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
            path.unshift("$state");
          }
        } else {
          path.unshift("state");
        }
        isTimelineActive = false;
        payload.set(inspectedStore, path, payload.state.value);
        isTimelineActive = true;
      }
    });
    api.on.editComponentState((payload) => {
      if (payload.type.startsWith("\u{1F34D}")) {
        const storeId = payload.type.replace(/^🍍\s*/, "");
        const store = pinia._s.get(storeId);
        if (!store) {
          return toastMessage(`store "${storeId}" not found`, "error");
        }
        const { path } = payload;
        if (path[0] !== "state") {
          return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
        }
        path[0] = "$state";
        isTimelineActive = false;
        payload.set(store, path, payload.state.value);
        isTimelineActive = true;
      }
    });
  });
}
function addStoreToDevtools(app2, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: true
      }
    }
  }, (api) => {
    const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
    store.$onAction(({ after, onError, name, args }) => {
      const groupId = runningActionId++;
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "\u{1F6EB} " + name,
          subtitle: "start",
          data: {
            store: formatDisplay(store.$id),
            action: formatDisplay(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        activeAction = void 0;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "\u{1F6EC} " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error2) => {
        activeAction = void 0;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            logType: "error",
            title: "\u{1F4A5} " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              error: error2
            },
            groupId
          }
        });
      });
    }, true);
    store._customProperties.forEach((name) => {
      watch(() => unref(store[name]), (newValue, oldValue) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (isTimelineActive) {
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "Change",
              subtitle: name,
              data: {
                newValue,
                oldValue
              },
              groupId: activeAction
            }
          });
        }
      }, { deep: true });
    });
    store.$subscribe(({ events, type }, state) => {
      api.notifyComponentUpdate();
      api.sendInspectorState(INSPECTOR_ID);
      if (!isTimelineActive)
        return;
      const eventData = {
        time: now2(),
        title: formatMutationType(type),
        data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
        groupId: activeAction
      };
      activeAction = void 0;
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "\u2935\uFE0F";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "\u{1F9E9}";
      } else if (events && !Array.isArray(events)) {
        eventData.subtitle = events.type;
      }
      if (events) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events
          }
        };
      }
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    }, { detached: true, flush: "sync" });
    const hotUpdate = store._hotUpdate;
    store._hotUpdate = markRaw((newStore) => {
      hotUpdate(newStore);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "\u{1F525} " + store.$id,
          subtitle: "HMR update",
          data: {
            store: formatDisplay(store.$id),
            info: formatDisplay(`HMR update`)
          }
        }
      });
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
    });
    const { $dispose } = store;
    store.$dispose = () => {
      $dispose();
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store \u{1F5D1}`);
    };
    api.notifyComponentUpdate();
    api.sendInspectorTree(INSPECTOR_ID);
    api.sendInspectorState(INSPECTOR_ID);
    api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed \u{1F195}`);
  });
}
let runningActionId = 0;
let activeAction;
function patchActionForGrouping(store, actionNames) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const _actionId = runningActionId;
      const trackedStore = new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      });
      return actions[actionName].apply(trackedStore, arguments);
    };
  }
}
function devtoolsPlugin({ app: app2, store, options }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  if (options.state) {
    store._isOptionsAPI = true;
  }
  if (typeof options.state === "function") {
    patchActionForGrouping(
      store,
      Object.keys(options.actions)
    );
    const originalHotUpdate = store._hotUpdate;
    toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));
    };
  }
  addStoreToDevtools(
    app2,
    store
  );
}
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app2) {
      setActivePinia(pinia);
      {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(app2, pinia);
        }
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
    pinia.use(devtoolsPlugin);
  }
  return pinia;
}
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
const noop$1 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && (!(process.env.NODE_ENV !== "production") || !hot)) {
      {
        pinia.state.value[id] = state ? state() : {};
      }
    }
    const localState = process.env.NODE_ENV !== "production" && hot ? toRefs(ref(state ? state() : {}).value) : toRefs(pinia.state.value[id]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      if (process.env.NODE_ENV !== "production" && name in localState) {
        console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
      }
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign({ actions: {} }, options);
  if (process.env.NODE_ENV !== "production" && !pinia._e.active) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = {
    deep: true
  };
  if (process.env.NODE_ENV !== "production" && !isVue2) {
    $subscribeOptions.onTrigger = (event) => {
      if (isListening) {
        debuggerEvents = event;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event);
        } else {
          console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== "production") || !hot)) {
    {
      pinia.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (process.env.NODE_ENV !== "production") {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
  } : noop$1;
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error2) {
        triggerSubscriptions(onErrorCallbackList, error2);
        throw error2;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error2) => {
          triggerSubscriptions(onErrorCallbackList, error2);
          return Promise.reject(error2);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(process.env.NODE_ENV !== "production" || USE_DEVTOOLS ? assign(
    {
      _hmrPayload,
      _customProperties: markRaw(/* @__PURE__ */ new Set())
    },
    partialStore
  ) : partialStore);
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup());
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (process.env.NODE_ENV !== "production" && hot) {
        set(hotState.value, key, toRef(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
      if (process.env.NODE_ENV !== "production") {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop === "function") {
      const actionValue = process.env.NODE_ENV !== "production" && hot ? prop : wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      if (process.env.NODE_ENV !== "production") {
        _hmrPayload.actions[key] = prop;
      }
      optionsForPlugin.actions[key] = prop;
    } else if (process.env.NODE_ENV !== "production") {
      if (isComputed(prop)) {
        _hmrPayload.getters[key] = isOptionsStore ? options.getters[key] : prop;
        if (IS_CLIENT) {
          const getters = setupStore._getters || (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  {
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => process.env.NODE_ENV !== "production" && hot ? hotState.value : pinia.state.value[$id],
    set: (state) => {
      if (process.env.NODE_ENV !== "production" && hot) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  if (process.env.NODE_ENV !== "production") {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set(store, stateKey, toRef(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const action = newStore[actionName];
        set(store, actionName, wrapAction(actionName, action));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? computed(() => {
          setActivePinia(pinia);
          return getter.call(store, store);
        }) : getter;
        set(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
  }
  if (USE_DEVTOOLS) {
    const nonEnumerable = {
      writable: true,
      configurable: true,
      enumerable: false
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
      Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
    });
  }
  pinia._p.forEach((extender) => {
    if (USE_DEVTOOLS) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign(store, extensions);
    } else {
      assign(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (process.env.NODE_ENV !== "production" && store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
    console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia = (process.env.NODE_ENV === "test" && activePinia && activePinia._testing ? null : pinia) || currentInstance2 && inject(piniaSymbol, null);
    if (pinia)
      setActivePinia(pinia);
    if (process.env.NODE_ENV !== "production" && !activePinia) {
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    }
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
      if (process.env.NODE_ENV !== "production") {
        useStore._pinia = pinia;
      }
    }
    const store = pinia._s.get(id);
    if (process.env.NODE_ENV !== "production" && hot) {
      const hotId = "__hot:" + id;
      const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
      hot._hotUpdate(newStore);
      delete pinia.state.value[hotId];
      pinia._s.delete(hotId);
    }
    if (process.env.NODE_ENV !== "production" && IS_CLIENT && currentInstance2 && currentInstance2.proxy && !hot) {
      const vm = currentInstance2.proxy;
      const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
      cache[id] = store;
    }
    return store;
  }
  useStore.$id = id;
  return useStore;
}
function storeToRefs(store) {
  {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value = store[key];
      if (isRef(value) || isReactive(value)) {
        refs[key] = toRef(store, key);
      }
    }
    return refs;
  }
}
function globals(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R$1 = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;
var exports$2 = {};
exports$2.greenwich = 0;
exports$2.lisbon = -9.131906111111;
exports$2.paris = 2.337229166667;
exports$2.bogota = -74.080916666667;
exports$2.madrid = -3.687938888889;
exports$2.rome = 12.452333333333;
exports$2.bern = 7.439583333333;
exports$2.jakarta = 106.807719444444;
exports$2.ferro = -17.666666666667;
exports$2.brussels = 4.367975;
exports$2.stockholm = 18.058277777778;
exports$2.athens = 23.7163375;
exports$2.oslo = 10.722916666667;
const units = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
function projStr(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p2, a) {
    var split = a.split("=");
    split.push(true);
    p2[split[0].toLowerCase()] = split[1];
    return p2;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R$1;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R$1;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R$1;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R$1;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R$1;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R$1;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R$1;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R$1;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2);
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R$1;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match(units, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R$1;
    },
    pm: function(v2) {
      var pm = match(exports$2, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R$1;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser$2(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser$2.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser$2.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser$2.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser$2.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser$2.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser$2.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser$2.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser$2.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser$2(txt);
  return parser.output();
}
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key = v2.shift();
  if (key === "PARAMETER") {
    key = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key] = {};
      sExpr(v2[0], obj[key]);
      return;
    }
    obj[key] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v2;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v2);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key]);
      }
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      return;
    default:
      i = -1;
      while (++i < v2.length) {
        if (!Array.isArray(v2[i])) {
          return sExpr(v2, obj[key]);
        }
      }
      return mapit(obj, key, v2);
  }
}
var D2R = 0.017453292519943295;
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function d2r(input) {
  return input * D2R;
}
function cleanWKT(wkt2) {
  if (wkt2.type === "GEOGCS") {
    wkt2.projName = "longlat";
  } else if (wkt2.type === "LOCAL_CS") {
    wkt2.projName = "identity";
    wkt2.local = true;
  } else {
    if (typeof wkt2.PROJECTION === "object") {
      wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
    } else {
      wkt2.projName = wkt2.PROJECTION;
    }
  }
  if (wkt2.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt2.AXIS.length; i < ii; ++i) {
      var axis = [wkt2.AXIS[i][0].toLowerCase(), wkt2.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt2.axis = axisOrder;
    }
  }
  if (wkt2.UNIT) {
    wkt2.units = wkt2.UNIT.name.toLowerCase();
    if (wkt2.units === "metre") {
      wkt2.units = "meter";
    }
    if (wkt2.UNIT.convert) {
      if (wkt2.type === "GEOGCS") {
        if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
          wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
        }
      } else {
        wkt2.to_meter = wkt2.UNIT.convert;
      }
    }
  }
  var geogcs = wkt2.GEOGCS;
  if (wkt2.type === "GEOGCS") {
    geogcs = wkt2;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt2.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt2.datumCode.slice(0, 2) === "d_") {
      wkt2.datumCode = wkt2.datumCode.slice(2);
    }
    if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
      wkt2.datumCode = "nzgd49";
    }
    if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
      if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt2.sphere = true;
      }
      wkt2.datumCode = "wgs84";
    }
    if (wkt2.datumCode.slice(-6) === "_ferro") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -6);
    }
    if (wkt2.datumCode.slice(-8) === "_jakarta") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -8);
    }
    if (~wkt2.datumCode.indexOf("belge")) {
      wkt2.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt2.ellps = "intl";
      }
      wkt2.a = geogcs.DATUM.SPHEROID.a;
      wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt2.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt2.datumCode.indexOf("osgb_1936")) {
      wkt2.datumCode = "osgb36";
    }
    if (~wkt2.datumCode.indexOf("osni_1952")) {
      wkt2.datumCode = "osni52";
    }
    if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt2.datumCode = "ire65";
    }
    if (wkt2.datumCode === "ch1903+") {
      wkt2.datumCode = "ch1903";
    }
    if (~wkt2.datumCode.indexOf("israel")) {
      wkt2.datumCode = "isr93";
    }
  }
  if (wkt2.b && !isFinite(wkt2.b)) {
    wkt2.b = wkt2.a;
  }
  function toMeter(input) {
    var ratio = wkt2.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt2, a);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt2.long0 = wkt2.longc;
  }
  if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
    wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
    wkt2.lat_ts = wkt2.lat1;
  }
}
function wkt(wkt2) {
  var lisp = parseString(wkt2);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(["name", name]);
  lisp.unshift(["type", type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def2 = arguments[1];
    if (typeof def2 === "string") {
      if (def2.charAt(0) === "+") {
        defs[name] = projStr(arguments[1]);
      } else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def2;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          defs.apply(that, v2);
        } else {
          defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
globals(defs);
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs[code];
    }
    if (testWKT(code)) {
      var out = wkt(code);
      if (checkMercator(out)) {
        return defs["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projStr(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projStr(code);
    }
  } else {
    return code;
  }
}
function extend$1(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
function sign(x) {
  return x < 0 ? -1 : 1;
}
function adjust_lon(x) {
  return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
}
function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
function init$v() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward$u(p2) {
  var lon = p2.x;
  var lat = p2.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x, y2;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p2.x = x;
    p2.y = y2;
    return p2;
  }
}
function inverse$u(p2) {
  var x = p2.x - this.x0;
  var y2 = p2.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y2 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y2 / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$w = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const merc = {
  init: init$v,
  forward: forward$u,
  inverse: inverse$u,
  names: names$w
};
function init$u() {
}
function identity(pt) {
  return pt;
}
var names$v = ["longlat", "identity"];
const longlat = {
  init: init$u,
  forward: identity,
  inverse: identity,
  names: names$v
};
var projs = [merc, longlat];
var names$u = {};
var projStore = [];
function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names$u[n.toLowerCase()] = len;
  });
  return this;
}
function get$1(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names$u[n] !== "undefined" && projStore[names$u[n]]) {
    return projStore[names$u[n]];
  }
}
function start() {
  projs.forEach(add);
}
const projections = {
  start,
  add,
  get: get$1
};
var exports$1 = {};
exports$1.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports$1.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports$1.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports$1.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports$1.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports$1.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports$1.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports$1.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports$1.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports$1.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports$1.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports$1.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports$1.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports$1.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports$1.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports$1.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports$1.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports$1.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports$1.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports$1.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports$1.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports$1.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports$1.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports$1.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports$1.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports$1.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports$1.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports$1.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports$1.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports$1.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports$1.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports$1.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports$1.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports$1.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports$1.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports$1.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports$1.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports$1.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports$1.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports$1.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports$1.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports$1.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports$1.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function eccentricity(a, b, rf, R_A) {
  var a2 = a * a;
  var b2 = b * b;
  var es = (a2 - b2) / a2;
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a2 - b2) / b2;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a, b, rf, ellps, sphere2) {
  if (!a) {
    var ellipse = match(exports$1, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1 - 1 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere2 = true;
    b = a;
  }
  return {
    a,
    b,
    rf,
    sphere: sphere2
  };
}
var exports = {};
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
exports.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
exports.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a;
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var loadedNadgrids = {};
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString$1(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString$1(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString$1(view, offset + 8, offset + 16).trim(),
    parent: decodeString$1(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error2) {
    if (error2) {
      throw error2;
    }
  };
  var json = parse(srsCode);
  if (typeof json !== "object") {
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if (!ourProj) {
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend$1(this, json);
  extend$1(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection.projections = projections;
Projection.projections.start();
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p2, es, a) {
  var Longitude = p2.x;
  var Latitude = p2.y;
  var Height = p2.z ? p2.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p2.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p2.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p2, es, a, b) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p2.x;
  var Y = p2.y;
  var Z2 = p2.z ? p2.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
  if (P / a < genau) {
    Longitude = 0;
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p2.x,
        y: p2.y,
        z: p2.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z2 / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x + datum_params[0],
      y: p2.y + datum_params[1],
      z: p2.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p2.x - Rz_BF * p2.y + Ry_BF * p2.z) + Dx_BF,
      y: M_BF * (Rz_BF * p2.x + p2.y - Rx_BF * p2.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p2.x + Rx_BF * p2.y + p2.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x - datum_params[0],
      y: p2.y - datum_params[1],
      z: p2.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p2.x - Dx_BF) / M_BF;
    var y_tmp = (p2.y - Dy_BF) / M_BF;
    var z_tmp = (p2.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse2, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output2 = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output2 = input;
      break;
    }
    grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }
    output2 = applySubgridShift(input, inverse2, subgrid);
    if (!isNaN(output2.x)) {
      break;
    }
  }
  if (isNaN(output2.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output2.x;
  point.y = output2.y;
  return 0;
}
function applySubgridShift(pin, inverse2, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse2) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del2;
    do {
      del2 = nadInterpolate(t, ct);
      if (isNaN(del2.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del2.x + t.x), y: tb.y - (del2.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
function adjust_axis(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v2, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === void 0) {
      continue;
    }
    if (i === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v2 = zin;
      t = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t] = v2;
        break;
      case "w":
        out[t] = -v2;
        break;
      case "n":
        out[t] = v2;
        break;
      case "s":
        out[t] = -v2;
        break;
      case "u":
        if (point[t] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point[t] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
function common(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = common(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Projection("WGS84");
    point = transform(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R$1,
      y: point.y * D2R$1,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis(dest, true, point);
  }
  if (!hasZ) {
    delete point.z;
  }
  return point;
}
var wgs84 = Projection("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Projection) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Projection(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A = 65;
var I = 73;
var O = 79;
var V = 86;
var Z = 90;
const mgrs = {
  forward: forward$t,
  inverse: inverse$t,
  toPoint
};
function forward$t(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse$t(mgrs2) {
  var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs2) {
  var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A2, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm2) {
  var UTMNorthing = utm2.northing;
  var UTMEasting = utm2.easting;
  var zoneLetter = utm2.zoneLetter;
  var zoneNumber = utm2.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;
  var x = UTMEasting - 5e5;
  var y2 = UTMNorthing;
  if (zoneLetter < "N") {
    y2 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y2 / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm2.accuracy) {
    var topRight = UTMtoLL({
      northing: utm2.northing + utm2.accuracy,
      easting: utm2.easting + utm2.accuracy,
      zoneLetter: utm2.zoneLetter,
      zoneNumber: utm2.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm2, accuracy) {
  var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
  return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index2 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index2);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index2);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n, set2) {
  if (n > "V") {
    throw "MGRSPoint given invalid Northing " + n;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
function Point(x, y2, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y2, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0;
  } else if (typeof x === "object") {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0;
  } else if (typeof x === "string" && typeof y2 === "undefined") {
    var coords = x.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x;
    this.y = y2;
    this.z = z || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point.fromMGRS = function(mgrsStr) {
  return new Point(toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return forward$t([this.x, this.y], accuracy);
};
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}
function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var MAX_ITER$3 = 20;
function pj_inv_mlfn(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER$3; i; --i) {
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
function init$t() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward$s(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y2;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y2 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y2);
      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y2 = 0;
        }
      } else {
        y2 = Math.acos(y2);
      }
      if (lat < 0) {
        y2 = -y2;
      }
      y2 = this.a * this.k0 * (y2 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c2 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c2, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c2 + als / 20 * (5 - 18 * t + ts + 14 * c2 - 58 * t * c2 + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y2 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c2 + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c2 - 330 * t * c2 + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$s(p2) {
  var con, phi;
  var lat, lon;
  var x = (p2.x - this.x0) * (1 / this.a);
  var y2 = (p2.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y2 / this.k0;
    var h2 = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h2, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y2 < 0) {
      lat = -lat;
    }
    if (g === 0 && h2 === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g, h2) + this.long0);
    }
  } else {
    con = this.ml0 + y2 / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c2 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c2, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c2 * t + c2 - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c2 * t + 45 * ts + 46 * c2 - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c2 - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c2 * t + 6 * c2 - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign(y2);
      lon = 0;
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$t = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const tmerc = {
  init: init$t,
  forward: forward$s,
  inverse: inverse$s,
  names: names$t
};
function sinh(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}
function hypot(x, y2) {
  x = Math.abs(x);
  y2 = Math.abs(y2);
  var a = Math.max(x, y2);
  var b = Math.min(x, y2) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}
function log1py(x) {
  var y2 = 1 + x;
  var z = y2 - 1;
  return z === 0 ? x : x * Math.log(y2) / z;
}
function asinhy(x) {
  var y2 = Math.abs(x);
  y2 = log1py(y2 * (1 + y2 / (hypot(1, y2) + 1)));
  return x < 0 ? -y2 : y2;
}
function gatg(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h3;
  while (--i >= 0) {
    h3 = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h3;
  }
  return B + h3 * Math.sin(2 * B);
}
function clens(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
function cosh(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}
function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }
  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}
function init$s() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
}
function forward$r(p2) {
  var Ce = adjust_lon(p2.x - this.long0);
  var Cn = p2.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y2;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y2 = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y2 = Infinity;
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$r(p2) {
  var Ce = (p2.x - this.x0) * (1 / this.a);
  var Cn = (p2.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$s = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const etmerc = {
  init: init$s,
  forward: forward$r,
  inverse: inverse$r,
  names: names$s
};
function adjust_zone(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var dependsOn = "etmerc";
function init$r() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R$1;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var names$r = ["Universal Transverse Mercator System", "utm"];
const utm = {
  init: init$r,
  names: names$r,
  dependsOn
};
function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var MAX_ITER$2 = 20;
function init$q() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function forward$q(p2) {
  var lon = p2.x;
  var lat = p2.y;
  p2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p2.x = this.C * lon;
  return p2;
}
function inverse$q(p2) {
  var DEL_TOL = 1e-14;
  var lon = p2.x / this.C;
  var lat = p2.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER$2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p2.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p2.y) < DEL_TOL) {
      break;
    }
    p2.y = lat;
  }
  if (!i) {
    return null;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$q = ["gauss"];
const gauss = {
  init: init$q,
  forward: forward$q,
  inverse: inverse$q,
  names: names$q
};
function init$p() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward$p(p2) {
  var sinc, cosc, cosl, k;
  p2.x = adjust_lon(p2.x - this.long0);
  gauss.forward.apply(this, [p2]);
  sinc = Math.sin(p2.y);
  cosc = Math.cos(p2.y);
  cosl = Math.cos(p2.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p2.x = k * cosc * Math.sin(p2.x);
  p2.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p2.x = this.a * p2.x + this.x0;
  p2.y = this.a * p2.y + this.y0;
  return p2;
}
function inverse$p(p2) {
  var sinc, cosc, lon, lat, rho;
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  p2.x /= this.k0;
  p2.y /= this.k0;
  if (rho = Math.sqrt(p2.x * p2.x + p2.y * p2.y)) {
    var c2 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = Math.asin(cosc * this.sinc0 + p2.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p2.x * sinc, rho * this.cosc0 * cosc - p2.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p2.x = lon;
  p2.y = lat;
  gauss.inverse.apply(this, [p2]);
  p2.x = adjust_lon(p2.x + this.long0);
  return p2;
}
var names$p = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const sterea = {
  init: init$p,
  forward: forward$p,
  inverse: inverse$p,
  names: names$p
};
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init$o() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward$o(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A2, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p2.x = NaN;
    p2.y = NaN;
    return p2;
  }
  if (this.sphere) {
    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p2.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
    p2.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p2;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p2.x = this.x0 + rh * Math.sin(lon - this.long0);
      p2.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p2;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p2.y = A2 * sinX;
    } else {
      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p2.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p2.x = A2 * cosX * Math.sin(dlon) + this.x0;
  }
  return p2;
}
function inverse$o(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  if (this.sphere) {
    var c2 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p2.x = lon;
      p2.y = lat;
      return p2;
    }
    lat = Math.asin(Math.cos(c2) * this.sinlat0 + p2.y * Math.sin(c2) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p2.x, -1 * p2.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p2.x, p2.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p2.x * Math.sin(c2), rh * this.coslat0 * Math.cos(c2) - p2.y * this.sinlat0 * Math.sin(c2)));
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p2.x = lon;
        p2.y = lat;
        return p2;
      }
      p2.x *= this.con;
      p2.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p2.x, -1 * p2.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p2.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p2.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p2.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$o = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const stere = {
  init: init$o,
  forward: forward$o,
  inverse: inverse$o,
  names: names$o,
  ssfn_
};
function init$n() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward$n(p2) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p2.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p2.y)) / (1 - this.e * Math.sin(p2.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
  var I2 = this.alpha * (p2.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
  p2.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p2.x = this.R * rotI + this.x0;
  return p2;
}
function inverse$n(p2) {
  var Y = p2.x - this.x0;
  var X = p2.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p2.x = lambda;
  p2.y = phy;
  return p2;
}
var names$n = ["somerc"];
const somerc = {
  init: init$n,
  forward: forward$n,
  inverse: inverse$n,
  names: names$n
};
var TOL = 1e-7;
function isTypeA(P) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
}
function init$m() {
  var con, com, cosph0, D, F, H, L, sinph0, p2, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R$1;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p2 = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p2) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
function forward$m(p2) {
  var coords = {};
  var S, T, U, V2, W, temp, u, v2;
  p2.x = p2.x - this.lam0;
  if (Math.abs(Math.abs(p2.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p2.y, Math.sin(p2.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V2 = Math.sin(this.B * p2.x);
    U = (S * this.singam - V2 * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p2.x);
    if (Math.abs(temp) < TOL) {
      u = this.A * p2.x;
    } else {
      u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v2 = p2.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p2.y;
  }
  if (this.no_rot) {
    coords.x = u;
    coords.y = v2;
  } else {
    u -= this.u_0;
    coords.x = v2 * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse$m(p2) {
  var u, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p2.x = (p2.x - this.x0) * (1 / this.a);
  p2.y = (p2.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p2.y;
    u = p2.x;
  } else {
    v2 = p2.x * this.cosrot - p2.y * this.sinrot;
    u = p2.y * this.cosrot + p2.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }
  coords.x += this.lam0;
  return coords;
}
var names$m = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const omerc = {
  init: init$m,
  forward: forward$m,
  inverse: inverse$m,
  names: names$m
};
function init$l() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward$l(p2) {
  var lon = p2.x;
  var lat = p2.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p2.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p2.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p2;
}
function inverse$l(p2) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p2.x - this.x0) / this.k0;
  var y2 = this.rh - (p2.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y2 * y2);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y2 * y2);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y2);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$l = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const lcc = {
  init: init$l,
  forward: forward$l,
  inverse: inverse$l,
  names: names$l
};
function init$k() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward$k(p2) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p2.y = ro * Math.cos(eps) / 1;
  p2.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p2.y *= -1;
    p2.x *= -1;
  }
  return p2;
}
function inverse$k(p2) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  var tmp = p2.x;
  p2.x = p2.y;
  p2.y = tmp;
  if (!this.czech) {
    p2.y *= -1;
    p2.x *= -1;
  }
  ro = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  eps = Math.atan2(p2.y, p2.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p2.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p2.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p2.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p2;
}
var names$k = ["Krovak", "krovak"];
const krovak = {
  init: init$k,
  forward: forward$k,
  inverse: inverse$k,
  names: names$k
};
function mlfn(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
function e0fn(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}
function e1fn(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}
function e2fn(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}
function e3fn(x) {
  return x * x * x * (35 / 3072);
}
function gN(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
function adjust_lat(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
}
function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$j() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward$j(p2) {
  var x, y2;
  var lam = p2.x;
  var phi = p2.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y2 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y2 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p2.x = x + this.x0;
  p2.y = y2 + this.y0;
  return p2;
}
function inverse$j(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var x = p2.x / this.a;
  var y2 = p2.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y2 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y2;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p2.x = this.long0;
      p2.y = HALF_PI;
      if (y2 < 0) {
        p2.y *= -1;
      }
      return p2;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p2.x = adjust_lon(lam + this.long0);
  p2.y = adjust_lat(phi);
  return p2;
}
var names$j = ["Cassini", "Cassini_Soldner", "cass"];
const cass = {
  init: init$j,
  forward: forward$j,
  inverse: inverse$j,
  names: names$j
};
function qsfnz(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init$i() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward$i(p2) {
  var x, y2, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p2.x;
  var phi = p2.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y2 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y2 <= EPSLN) {
        return null;
      }
      y2 = Math.sqrt(2 / y2);
      x = y2 * cosphi * Math.sin(lam);
      y2 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y2 = FORTPI - phi * 0.5;
      y2 = 2 * (this.mode === this.S_POLE ? Math.cos(y2) : Math.sin(y2));
      x = y2 * Math.sin(lam);
      y2 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y2 = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y2 = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y2 = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y2 = 0;
        }
        break;
    }
  }
  p2.x = this.a * x + this.x0;
  p2.y = this.a * y2 + this.y0;
  return p2;
}
function inverse$i(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var x = p2.x / this.a;
  var y2 = p2.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x * x + y2 * y2);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y2 * sinz / rh);
        x *= sinz;
        y2 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y2 * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y2 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y2 = -y2;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y2 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y2);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y2 *= this.dd;
      rho = Math.sqrt(x * x + y2 * y2);
      if (rho < EPSLN) {
        p2.x = this.long0;
        p2.y = this.lat0;
        return p2;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y2 * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y2 = rho * this.cosb1 * cCe - y2 * this.sinb1 * sCe;
      } else {
        ab = y2 * sCe / rho;
        q = this.qp * ab;
        y2 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y2 = -y2;
      }
      q = x * x + y2 * y2;
      if (!q) {
        p2.x = this.long0;
        p2.y = this.lat0;
        return p2;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y2);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p2.x = adjust_lon(this.long0 + lam);
  p2.y = phi;
  return p2;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var names$i = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const laea = {
  init: init$i,
  forward: forward$i,
  inverse: inverse$i,
  names: names$i,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};
function asinz(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}
function init$h() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward$h(p2) {
  var lon = p2.x;
  var lat = p2.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y2 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$h(p2) {
  var rh1, qs, con, theta, lon, lat;
  p2.x -= this.x0;
  p2.y = this.rh - p2.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p2.x, con * p2.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon(theta / this.ns0 + this.long0);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names$h = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const aea = {
  init: init$h,
  forward: forward$h,
  inverse: inverse$h,
  names: names$h,
  phi1z
};
function init$g() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward$g(p2) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x, y2;
  var lon = p2.x;
  var lat = p2.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$g(p2) {
  var rh;
  var sinc, cosc;
  var c2;
  var lon, lat;
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  p2.x /= this.k0;
  p2.y /= this.k0;
  if (rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y)) {
    c2 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = asinz(cosc * this.sin_p14 + p2.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p2.x * sinc, rh * this.cos_p14 * cosc - p2.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$g = ["gnom"];
const gnom = {
  init: init$g,
  forward: forward$g,
  inverse: inverse$g,
  names: names$g
};
function iqsfnz(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1e-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$f() {
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward$f(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var x, y2;
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y2 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y2 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$f(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon(this.long0 + p2.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p2.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p2.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p2.x / (this.a * this.k0));
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$f = ["cea"];
const cea = {
  init: init$f,
  forward: forward$f,
  inverse: inverse$f,
  names: names$f
};
function init$e() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward$e(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p2.x = this.x0 + this.a * dlon * this.rc;
  p2.y = this.y0 + this.a * dlat;
  return p2;
}
function inverse$e(p2) {
  var x = p2.x;
  var y2 = p2.y;
  p2.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
  p2.y = adjust_lat(this.lat0 + (y2 - this.y0) / this.a);
  return p2;
}
var names$e = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const eqc = {
  init: init$e,
  forward: forward$e,
  inverse: inverse$e,
  names: names$e
};
var MAX_ITER$1 = 20;
function init$d() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward$d(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var x, y2, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y2 = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y2 = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y2 = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y2 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p2.x = x + this.x0;
  p2.y = y2 + this.y0;
  return p2;
}
function inverse$d(p2) {
  var lon, lat, x, y2, i;
  var al, bl;
  var phi, dphi;
  x = p2.x - this.x0;
  y2 = p2.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y2 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y2 / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER$1; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y2 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y2) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER$1; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$d = ["Polyconic", "poly"];
const poly = {
  init: init$d,
  forward: forward$d,
  inverse: inverse$d,
  names: names$d
};
function init$c() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward$c(p2) {
  var n;
  var lon = p2.x;
  var lat = p2.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }
  p2.x = z_im * this.a + this.x0;
  p2.y = z_re * this.a + this.y0;
  return p2;
}
function inverse$c(p2) {
  var n;
  var x = p2.x;
  var y2 = p2.y;
  var delta_x = x - this.x0;
  var delta_y = y2 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$c = ["New_Zealand_Map_Grid", "nzmg"];
const nzmg = {
  init: init$c,
  forward: forward$c,
  inverse: inverse$c,
  names: names$c
};
function init$b() {
}
function forward$b(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$b(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon = adjust_lon(this.long0 + p2.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p2.y / this.a)) - Math.PI / 4);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$b = ["Miller_Cylindrical", "mill"];
const mill = {
  init: init$b,
  forward: forward$b,
  inverse: inverse$b,
  names: names$b
};
var MAX_ITER = 20;
function init$a() {
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward$a(p2) {
  var x, y2;
  var lon = p2.x;
  var lat = p2.y;
  lon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y2 = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c2 = Math.cos(lat);
    y2 = this.a * pj_mlfn(lat, s, c2, this.en);
    x = this.a * lon * c2 / Math.sqrt(1 - this.es * s * s);
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$a(p2) {
  var lat, temp, lon, s;
  p2.x -= this.x0;
  lon = p2.x / this.a;
  p2.y -= this.y0;
  lat = p2.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p2.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p2.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$a = ["Sinusoidal", "sinu"];
const sinu = {
  init: init$a,
  forward: forward$a,
  inverse: inverse$a,
  names: names$a
};
function init$9() {
}
function forward$9(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y2 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$9(p2) {
  var theta;
  var arg;
  p2.x -= this.x0;
  p2.y -= this.y0;
  arg = p2.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p2.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$9 = ["Mollweide", "moll"];
const moll = {
  init: init$9,
  forward: forward$9,
  inverse: inverse$9,
  names: names$9
};
function init$8() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward$8(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y2 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$8(p2) {
  p2.x -= this.x0;
  p2.y = this.rh - p2.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p2.x, con * p2.y);
  }
  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
}
var names$8 = ["Equidistant_Conic", "eqdc"];
const eqdc = {
  init: init$8,
  forward: forward$8,
  inverse: inverse$8,
  names: names$8
};
function init$7() {
  this.R = this.a;
}
function forward$7(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon(lon - this.long0);
  var x, y2;
  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y2 = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;
    if (lat >= 0) {
      y2 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y2 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    y2 = this.y0 + con;
  } else {
    y2 = this.y0 - con;
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$7(p2) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  p2.x -= this.x0;
  p2.y -= this.y0;
  con = Math.PI * this.R;
  xx = p2.x / con;
  yy = p2.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p2.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$7 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const vandg = {
  init: init$7,
  forward: forward$7,
  inverse: inverse$7,
  names: names$7
};
function init$6() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward$6(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var sinphi = Math.sin(p2.y);
  var cosphi = Math.cos(p2.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c2, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p2.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p2.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p2.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p2.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p2;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c2 = Math.acos(cos_c);
      kp = c2 ? c2 / Math.sin(c2) : 1;
      p2.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p2.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p2;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p2.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p2.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p2.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p2.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p2;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c2 = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p2.x = this.x0 + c2 * Math.sin(Az);
      p2.y = this.y0 + c2 * Math.cos(Az);
      return p2;
    }
  }
}
function inverse$6(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A2, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p2.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p2.x, -p2.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p2.x, p2.y));
        }
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p2.x * sinz, rh * this.cos_p12 * cosz - p2.y * this.sin_p12 * sinz));
      }
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p2.x, -1 * p2.y));
      p2.x = lon;
      p2.y = lat;
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      M = rh - Mlp;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p2.x, p2.y));
      p2.x = lon;
      p2.y = lat;
      return p2;
    } else {
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      Az = Math.atan2(p2.x, p2.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A2 = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A2 * (1 + A2) * Math.pow(D, 3) / 6 - B * (1 + 3 * A2) * Math.pow(D, 4) / 24;
      F = 1 - A2 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p2.x = lon;
      p2.y = lat;
      return p2;
    }
  }
}
var names$6 = ["Azimuthal_Equidistant", "aeqd"];
const aeqd = {
  init: init$6,
  forward: forward$6,
  inverse: inverse$6,
  names: names$6
};
function init$5() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward$5(p2) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x, y2;
  var lon = p2.x;
  var lat = p2.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p2.x = x;
  p2.y = y2;
  return p2;
}
function inverse$5(p2) {
  var rh;
  var z;
  var sinz, cosz;
  var con;
  var lon, lat;
  p2.x -= this.x0;
  p2.y -= this.y0;
  rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  z = asinz(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
  lat = asinz(cosz * this.sin_p14 + p2.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p2.x, -p2.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p2.x, p2.y));
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
  lon = adjust_lon(this.long0 + Math.atan2(p2.x * sinz, rh * this.cos_p14 * cosz - p2.y * this.sin_p14 * sinz));
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names$5 = ["ortho"];
const ortho = {
  init: init$5,
  forward: forward$5,
  inverse: inverse$5,
  names: names$5
};
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init$4() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward$4(p2) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t, mu;
  var area = { value: 0 };
  p2.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p2.y));
  } else {
    lat = p2.y;
  }
  lon = p2.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p2.x = xy.x;
  p2.y = xy.y;
  return p2;
}
function inverse$4(p2) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = { value: 0 };
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p2.x * p2.x + p2.y * p2.y));
  mu = Math.atan2(p2.y, p2.x);
  if (p2.x >= 0 && p2.x >= Math.abs(p2.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p2.y >= 0 && p2.y >= Math.abs(p2.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p2.x < 0 && -p2.x >= Math.abs(p2.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p2.x = lp.lam;
  p2.y = lp.phi;
  return p2;
}
function qsc_fwd_equat_face_theta(phi, y2, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y2, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names$4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const qsc = {
  init: init$4,
  forward: forward$4,
  inverse: inverse$4,
  names: names$4
};
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};
var poly3_der = function(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x = start2;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init$3() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward$3(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse$3(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t = newton_rapshon(function(x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R$1;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var names$3 = ["Robinson", "robin"];
const robin = {
  init: init$3,
  forward: forward$3,
  inverse: inverse$3,
  names: names$3
};
function init$2() {
  this.name = "geocent";
}
function forward$2(p2) {
  var point = geodeticToGeocentric(p2, this.es, this.a);
  return point;
}
function inverse$2(p2) {
  var point = geocentricToGeodetic(p2, this.es, this.a, this.b);
  return point;
}
var names$2 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const geocent = {
  init: init$2,
  forward: forward$2,
  inverse: inverse$2,
  names: names$2
};
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  azi: { def: 0, num: true, degrees: true },
  tilt: { def: 0, num: true, degrees: true },
  long0: { def: 0, num: true },
  lat0: { def: 0, num: true }
};
function init$1() {
  Object.keys(params).forEach(function(p2) {
    if (typeof this[p2] === "undefined") {
      this[p2] = params[p2].def;
    } else if (params[p2].num && isNaN(this[p2])) {
      throw new Error("Invalid parameter value, must be numeric " + p2 + " = " + this[p2]);
    } else if (params[p2].num) {
      this[p2] = parseFloat(this[p2]);
    }
    if (params[p2].degrees) {
      this[p2] = this[p2] * D2R$1;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward$1(p2) {
  p2.x -= this.long0;
  var sinphi = Math.sin(p2.y);
  var cosphi = Math.cos(p2.y);
  var coslam = Math.cos(p2.x);
  var x, y2;
  switch (this.mode) {
    case mode.OBLIQ:
      y2 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y2 = -sinphi;
      break;
    case mode.N_POLE:
      y2 = sinphi;
      break;
  }
  y2 = this.pn1 / (this.p - y2);
  x = y2 * cosphi * Math.sin(p2.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y2 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 *= sinphi;
      break;
    case mode.N_POLE:
      y2 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y2 *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y2 * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y2 * this.sg) * this.cw * ba;
  y2 = yt * ba;
  p2.x = x * this.a;
  p2.y = y2 * this.a;
  return p2;
}
function inverse$1(p2) {
  p2.x /= this.a;
  p2.y /= this.a;
  var r = { x: p2.x, y: p2.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p2.y * this.sw);
  bm = this.pn1 * p2.x * yt;
  bq = this.pn1 * p2.y * this.cw * yt;
  p2.x = bm * this.cg + bq * this.sg;
  p2.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p2.x, p2.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p2.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p2.y * sinz * this.cosph0 / rh);
        p2.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p2.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p2.y * sinz / rh);
        p2.y = cosz * rh;
        p2.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p2.y = -p2.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p2.x, p2.y);
  }
  p2.x = r.x + this.long0;
  p2.y = r.y;
  return p2;
}
var names$1 = ["Tilted_Perspective", "tpers"];
const tpers = {
  init: init$1,
  forward: forward$1,
  inverse: inverse$1,
  names: names$1
};
function init() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p2.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
      p2.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p2.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p2.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p2.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
      p2.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p2.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p2.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
    }
  }
  p2.x = p2.x * this.a;
  p2.y = p2.y * this.a;
  return p2;
}
function inverse(p2) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a, b, det, k;
  p2.x = p2.x / this.a;
  p2.y = p2.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p2.y / this.radius_g_1);
      v_y = Math.tan(p2.x / this.radius_g_1) * hypot(1, v_z);
    } else {
      v_y = Math.tan(p2.x / this.radius_g_1);
      v_z = Math.tan(p2.y / this.radius_g_1) * hypot(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p2.x = Math.atan2(v_y, v_x);
    p2.y = Math.atan(v_z * Math.cos(p2.x) / v_x);
    p2.y = Math.atan(this.radius_p_inv2 * Math.tan(p2.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p2.y / this.radius_g_1);
      v_y = Math.tan(p2.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p2.x / this.radius_g_1);
      v_z = Math.tan(p2.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p2.x = Math.atan2(v_y, v_x);
    p2.y = Math.atan(v_z * Math.cos(p2.x) / v_x);
  }
  p2.x = p2.x + this.long0;
  return p2;
}
var names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const geos = {
  init,
  forward,
  inverse,
  names
};
function includedProjections(proj42) {
  proj42.Proj.projections.add(tmerc);
  proj42.Proj.projections.add(etmerc);
  proj42.Proj.projections.add(utm);
  proj42.Proj.projections.add(sterea);
  proj42.Proj.projections.add(stere);
  proj42.Proj.projections.add(somerc);
  proj42.Proj.projections.add(omerc);
  proj42.Proj.projections.add(lcc);
  proj42.Proj.projections.add(krovak);
  proj42.Proj.projections.add(cass);
  proj42.Proj.projections.add(laea);
  proj42.Proj.projections.add(aea);
  proj42.Proj.projections.add(gnom);
  proj42.Proj.projections.add(cea);
  proj42.Proj.projections.add(eqc);
  proj42.Proj.projections.add(poly);
  proj42.Proj.projections.add(nzmg);
  proj42.Proj.projections.add(mill);
  proj42.Proj.projections.add(sinu);
  proj42.Proj.projections.add(moll);
  proj42.Proj.projections.add(eqdc);
  proj42.Proj.projections.add(vandg);
  proj42.Proj.projections.add(aeqd);
  proj42.Proj.projections.add(ortho);
  proj42.Proj.projections.add(qsc);
  proj42.Proj.projections.add(robin);
  proj42.Proj.projections.add(geocent);
  proj42.Proj.projections.add(tpers);
  proj42.Proj.projections.add(geos);
}
proj4.defaultDatum = "WGS84";
proj4.Proj = Projection;
proj4.WGS84 = new proj4.Proj("WGS84");
proj4.Point = Point;
proj4.toPoint = common;
proj4.defs = defs;
proj4.nadgrid = nadgrid;
proj4.transform = transform;
proj4.mgrs = mgrs;
proj4.version = "__VERSION__";
includedProjections(proj4);
function initProjections() {
  var _a, _b, _c;
  proj4.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs");
  proj4.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs");
  proj4.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  );
  register(proj4);
  (_a = get$3("EPSG:32632")) == null ? void 0 : _a.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]);
  (_b = get$3("EPSG:32631")) == null ? void 0 : _b.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]);
  (_c = get$3("EPSG:2169")) == null ? void 0 : _c.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function defineCustomElement(options, config, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, config, hydrate2);
    }
  }
  __publicField(VueCustomElement, "def", Comp);
  return VueCustomElement;
}
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _config = {}, hydrate2) {
    super();
    __publicField(this, "_instance", null);
    __publicField(this, "_connected", false);
    __publicField(this, "_resolved", false);
    __publicField(this, "_numberProps", null);
    __publicField(this, "_styles");
    __publicField(this, "_slots");
    this._def = _def;
    this._props = _props;
    this._config = _config;
    this._config = extend$2(
      {
        shadowRoot: true
      },
      this._config
    );
    if (this._config.shadowRoot) {
      if (this.shadowRoot && hydrate2) {
        hydrate2(this._createVNode(), this.shadowRoot);
      } else {
        this.attachShadow({ mode: "open" });
        if (!this._def.__asyncLoader) {
          this._resolveProps(this._def);
        }
      }
    } else {
      if (hydrate2) {
        hydrate2(this._createVNode(), this._root);
      }
    }
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this._root);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this._root);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$2({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance2) => {
        this._instance = instance2;
        instance2.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance2.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance2.parent = parent._instance;
            instance2.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css2) => {
        const s = document.createElement("style");
        s.textContent = css2;
        this._root.appendChild(s);
      });
    }
  }
}
const main = "";
var AlertNotificationType = /* @__PURE__ */ ((AlertNotificationType2) => {
  AlertNotificationType2["INFO"] = "alert-info";
  AlertNotificationType2["WARNING"] = "alert-warning";
  AlertNotificationType2["ERROR"] = "alert-danger";
  return AlertNotificationType2;
})(AlertNotificationType || {});
const DEFAULT_NOTIFICATION_TYPE = AlertNotificationType.INFO;
const DEFAULT_NOTIFICATION_DURATION = 7e3;
const DEFAULT_NOTIFICATION_DURATION_WARNING = 4e3;
const useAlertNotificationsStore = defineStore(
  "alert-notifications",
  () => {
    const notifications = ref([]);
    function addNotification(message, type = DEFAULT_NOTIFICATION_TYPE, duration) {
      const notification = {
        message,
        type,
        duration: duration != null ? duration : type === AlertNotificationType.WARNING ? DEFAULT_NOTIFICATION_DURATION_WARNING : DEFAULT_NOTIFICATION_DURATION
      };
      notifications.value.push(notification);
    }
    function removeNotification(index2) {
      notifications.value.splice(index2, 1);
    }
    return {
      notifications,
      addNotification,
      removeNotification
    };
  },
  {}
);
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "notification-item",
  props: {
    notification: { type: null, required: true }
  },
  emits: ["close"],
  setup(__props) {
    const props = __props;
    const show = shallowRef(true);
    function onEnter(el, done) {
      setTimeout(() => {
        show.value = false;
      }, props.notification.duration);
      done();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "fade-out",
        appear: "",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "transform opacity-0",
        onEnter,
        onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
      }, {
        default: withCtx(() => [
          unref(show) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["lux-alert", `lux-${props.notification.type}`]),
            role: "alert"
          }, toDisplayString(props.notification.message), 3)) : createCommentVNode("v-if", true)
        ]),
        _: 1
      });
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const Notification = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/alert-notifications/notification-item.vue"]]);
const _hoisted_1$r = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
};
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "alert-notifications",
  setup(__props) {
    const alertNotificationsStore = useAlertNotificationsStore();
    const { notifications } = storeToRefs(alertNotificationsStore);
    function onClose(index2) {
      alertNotificationsStore.removeNotification(index2);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        unref(notifications).length ? (openBlock(), createElementBlock("div", _hoisted_1$r, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(notifications), (notification, index2) => {
            return openBlock(), createBlock(Notification, {
              key: index2,
              notification,
              onClose: () => onClose(index2)
            }, null, 8, ["notification", "onClose"]);
          }), 128))
        ])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
const AlertNotifications = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/alert-notifications/alert-notifications.vue"]]);
const _hoisted_1$q = { class: "lux-dropdown" };
const _hoisted_2$k = { class: "h-full" };
const _hoisted_3$i = ["aria-expanded"];
const _hoisted_4$g = /* @__PURE__ */ createBaseVNode("span", { class: "lux-caret" }, null, -1);
const _hoisted_5$e = { class: "lux-dropdown-wrapper" };
const _hoisted_6$a = ["aria-label", "data-value"];
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: true },
    options: { type: Array, required: true, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: false }
  },
  emits: ["change"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const isOpen = shallowRef(false);
    const selectedValue = shallowRef();
    function toggleDropdown(forceOpen) {
      isOpen.value = forceOpen === void 0 ? !isOpen.value : forceOpen;
    }
    function onClickOpenBtn(event) {
      event.stopImmediatePropagation();
      toggleDropdown();
    }
    function onClickItem(event) {
      selectedValue.value = event.target.dataset.value;
      emit2("change", selectedValue.value);
    }
    function onClickOutsideOpenBtn() {
      toggleDropdown(false);
    }
    onMounted(() => document.addEventListener("click", onClickOutsideOpenBtn));
    onUnmounted(() => document.removeEventListener("click", onClickOutsideOpenBtn));
    return (_ctx, _cache) => {
      var _a, _b;
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$k, [
          createBaseVNode("button", {
            type: "button",
            class: normalizeClass(["lux-btn lux-dropdown-btn", unref(isOpen) ? "expanded" : ""]),
            "aria-expanded": unref(isOpen),
            "aria-haspopup": "true",
            onClick: onClickOpenBtn
          }, [
            createBaseVNode("span", null, toDisplayString((_b = props.placeholder) != null ? _b : (_a = props.options[0]) == null ? void 0 : _a.label), 1),
            _hoisted_4$g
          ], 10, _hoisted_3$i)
        ]),
        createBaseVNode("div", _hoisted_5$e, [
          createBaseVNode("ul", {
            class: normalizeClass(["lux-dropdown-list", unref(isOpen) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(props.options, (option2) => {
              return openBlock(), createElementBlock("li", {
                key: option2.value,
                class: normalizeClass(__props.modelValue === option2.value ? "selected" : "")
              }, [
                createBaseVNode("button", {
                  class: "lux-dropdown-list-item",
                  "aria-label": option2.ariaLabel,
                  "data-value": option2.value,
                  onClick: onClickItem
                }, toDisplayString(option2.label), 9, _hoisted_6$a)
              ], 2);
            }), 128))
          ], 2)
        ])
      ]);
    };
  }
});
const DropdownList = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/common/dropdown-list.vue"]]);
const PROJECTION_WEBMERCATOR = "EPSG:3857";
const PROJECTION_WGS84 = "EPSG:4326";
const PROJECTION_LUX = "EPSG:2169";
let map;
const olMap = shallowRef();
function useMap() {
  function getOlMap() {
    return map;
  }
  function createMap() {
    olMap.value = map = new OlMap({
      view: new OlView({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: true
      }),
      controls: []
    });
    return map;
  }
  function equalsLayer(layerA, layerB) {
    return layerA === layerB;
  }
  function hasLayer(context, layer) {
    var _a;
    return (_a = context.layers) == null ? void 0 : _a.some((l) => equalsLayer(layer, l));
  }
  function layerHasChanged(oldContext, layer) {
    var _a;
    const oldLayer = (_a = oldContext == null ? void 0 : oldContext.layers) == null ? void 0 : _a.find((l) => l.id === layer.id);
    return oldLayer !== layer;
  }
  function contextHasChanged(newContext, oldContext) {
    return !(oldContext === null || !("layers" in newContext) || !("layers" in oldContext) || typeof oldContext.layers === "undefined" || typeof newContext.layers === "undefined" || newContext.layers === oldContext.layers);
  }
  function getAddedLayers(newContext, oldContext) {
    if (!("layers" in newContext) || typeof newContext.layers === "undefined")
      return [];
    if (oldContext === null || !("layers" in oldContext)) {
      return newContext.layers.map((layer, position) => ({ layer, position }));
    }
    if (newContext.layers === oldContext.layers)
      return [];
    return newContext.layers.reduce(
      (addedLayers, layer, i) => hasLayer(oldContext, layer) ? addedLayers : [
        ...addedLayers,
        {
          layer,
          position: i
        }
      ],
      []
    );
  }
  function getRemovedLayers(newContext, oldContext) {
    if (contextHasChanged(newContext, oldContext)) {
      return oldContext.layers.reduce(
        (prev, layer) => hasLayer(newContext, layer) ? prev : [...prev, layer],
        []
      );
    }
    return [];
  }
  function getMutatedLayers(newContext, oldContext) {
    if (contextHasChanged(newContext, oldContext)) {
      return newContext.layers.reduce(
        (prev, layer) => layerHasChanged(oldContext, layer) ? [...prev, layer] : prev,
        []
      );
    }
    return [];
  }
  return {
    olMap,
    getOlMap,
    createMap,
    equalsLayer,
    hasLayer,
    layerHasChanged,
    contextHasChanged,
    getAddedLayers,
    getRemovedLayers,
    getMutatedLayers
  };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var mapboxGl = { exports: {} };
(function(module, exports2) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define(_23, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined") {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define(["exports"], function(t) {
      function e(t2, e2) {
        return t2(e2 = { exports: {} }, e2.exports), e2.exports;
      }
      var r = n;
      function n(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = n2, this.p2x = r2, this.p2y = n2;
      }
      n.prototype.sampleCurveX = function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, n.prototype.sampleCurveY = function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, n.prototype.sampleCurveDerivativeX = function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, n.prototype.solveCurveX = function(t2, e2) {
        var r2, n2, i2, a2, o2;
        for (void 0 === e2 && (e2 = 1e-6), i2 = t2, o2 = 0; o2 < 8; o2++) {
          if (a2 = this.sampleCurveX(i2) - t2, Math.abs(a2) < e2)
            return i2;
          var s2 = this.sampleCurveDerivativeX(i2);
          if (Math.abs(s2) < 1e-6)
            break;
          i2 -= a2 / s2;
        }
        if ((i2 = t2) < (r2 = 0))
          return r2;
        if (i2 > (n2 = 1))
          return n2;
        for (; r2 < n2; ) {
          if (a2 = this.sampleCurveX(i2), Math.abs(a2 - t2) < e2)
            return i2;
          t2 > a2 ? r2 = i2 : n2 = i2, i2 = 0.5 * (n2 - r2) + r2;
        }
        return i2;
      }, n.prototype.solve = function(t2, e2) {
        return this.sampleCurveY(this.solveCurveX(t2, e2));
      };
      var i = a;
      function a(t2, e2) {
        this.x = t2, this.y = e2;
      }
      a.prototype = { clone: function() {
        return new a(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e2) {
        return this.clone()._rotateAround(t2, e2);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e2 = t2.x - this.x, r2 = t2.y - this.y;
        return e2 * e2 + r2 * r2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e2) {
        return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
      }, _matMult: function(t2) {
        var e2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
      }, _rotateAround: function(t2, e2) {
        var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
        return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, a.convert = function(t2) {
        return t2 instanceof a ? t2 : Array.isArray(t2) ? new a(t2[0], t2[1]) : t2;
      };
      var o = "undefined" != typeof self ? self : {}, s = Math.pow(2, 53) - 1;
      function u(t2, e2, n2, i2) {
        var a2 = new r(t2, e2, n2, i2);
        return function(t3) {
          return a2.solve(t3);
        };
      }
      var l = u(0.25, 0.1, 0.25, 1);
      function p2(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function c2(t2, e2, r2) {
        var n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function h2(t2) {
        for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
          e2[r2] = arguments[r2 + 1];
        for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          for (var o2 in a2)
            t2[o2] = a2[o2];
        }
        return t2;
      }
      var f = 1;
      function y2() {
        return f++;
      }
      function d() {
        return function t2(e2) {
          return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
        }();
      }
      function m(t2) {
        return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
      }
      function v2(t2, e2) {
        t2.forEach(function(t3) {
          e2[t3] && (e2[t3] = e2[t3].bind(e2));
        });
      }
      function g(t2, e2) {
        return -1 !== t2.indexOf(e2, t2.length - e2.length);
      }
      function x(t2, e2, r2) {
        var n2 = {};
        for (var i2 in t2)
          n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
        return n2;
      }
      function b(t2, e2, r2) {
        var n2 = {};
        for (var i2 in t2)
          e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
        return n2;
      }
      function w(t2) {
        return Array.isArray(t2) ? t2.map(w) : "object" == typeof t2 && t2 ? x(t2, w) : t2;
      }
      var _23 = {};
      function A2(t2) {
        _23[t2] || ("undefined" != typeof console && console.warn(t2), _23[t2] = true);
      }
      function S(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function k(t2) {
        for (var e2 = 0, r2 = 0, n2 = t2.length, i2 = n2 - 1, a2 = void 0, o2 = void 0; r2 < n2; i2 = r2++)
          e2 += ((o2 = t2[i2]).x - (a2 = t2[r2]).x) * (a2.y + o2.y);
        return e2;
      }
      function I2() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function z(t2) {
        var e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(t3, r3, n2, i2) {
          var a2 = n2 || i2;
          return e2[r3] = !a2 || a2.toLowerCase(), "";
        }), e2["max-age"]) {
          var r2 = parseInt(e2["max-age"], 10);
          isNaN(r2) ? delete e2["max-age"] : e2["max-age"] = r2;
        }
        return e2;
      }
      var C = null;
      function E(t2) {
        if (null == C) {
          var e2 = t2.navigator ? t2.navigator.userAgent : null;
          C = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return C;
      }
      function P(t2) {
        try {
          var e2 = o[t2];
          return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }
      var M, B, T, V2, F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date), D = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame, L = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame, O2 = { now: F, frame: function(t2) {
        var e2 = D(t2);
        return { cancel: function() {
          return L(e2);
        } };
      }, getImageData: function(t2, e2) {
        void 0 === e2 && (e2 = 0);
        var r2 = o.document.createElement("canvas"), n2 = r2.getContext("2d");
        if (!n2)
          throw new Error("failed to create canvas 2d context");
        return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
      }, resolveURL: function(t2) {
        return M || (M = o.document.createElement("a")), M.href = t2, M.href;
      }, hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
        return o.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!o.matchMedia && (null == B && (B = o.matchMedia("(prefers-reduced-motion: reduce)")), B.matches);
      } }, R = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
      }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, U = { supported: false, testSupport: function(t2) {
        !j && V2 && (q ? N(t2) : T = t2);
      } }, j = false, q = false;
      function N(t2) {
        var e2 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e2);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, V2), t2.isContextLost())
            return;
          U.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e2), j = true;
      }
      o.document && ((V2 = o.document.createElement("img")).onload = function() {
        T && N(T), T = null, q = true;
      }, V2.onerror = function() {
        j = true, T = null;
      }, V2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      var K = "01", G = function(t2, e2) {
        this._transformRequestFn = t2, this._customAccessToken = e2, this._createSkuToken();
      };
      function Z2(t2) {
        return 0 === t2.indexOf("mapbox:");
      }
      G.prototype._createSkuToken = function() {
        var t2 = function() {
          for (var t3 = "", e2 = 0; e2 < 10; e2++)
            t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return { token: ["1", K, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
        }();
        this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
      }, G.prototype._isSkuTokenExpired = function() {
        return Date.now() > this._skuTokenExpiresAt;
      }, G.prototype.transformRequest = function(t2, e2) {
        return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
      }, G.prototype.normalizeStyleURL = function(t2, e2) {
        if (!Z2(t2))
          return t2;
        var r2 = Y(t2);
        return r2.path = "/styles/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
      }, G.prototype.normalizeGlyphsURL = function(t2, e2) {
        if (!Z2(t2))
          return t2;
        var r2 = Y(t2);
        return r2.path = "/fonts/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
      }, G.prototype.normalizeSourceURL = function(t2, e2) {
        if (!Z2(t2))
          return t2;
        var r2 = Y(t2);
        return r2.path = "/v4/" + r2.authority + ".json", r2.params.push("secure"), this._makeAPIURL(r2, this._customAccessToken || e2);
      }, G.prototype.normalizeSpriteURL = function(t2, e2, r2, n2) {
        var i2 = Y(t2);
        return Z2(t2) ? (i2.path = "/styles/v1" + i2.path + "/sprite" + e2 + r2, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += "" + e2 + r2, $(i2));
      }, G.prototype.normalizeTileURL = function(t2, e2) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !Z2(t2))
          return t2;
        var r2 = Y(t2);
        r2.path = r2.path.replace(/(\.(png|jpg)\d*)(?=$)/, (O2.devicePixelRatio >= 2 || 512 === e2 ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r2.path = r2.path.replace(/^.+\/v4\//, "/"), r2.path = "/v4" + r2.path;
        var n2 = this._customAccessToken || function(t3) {
          for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1) {
            var n3 = r3[e3].match(/^access_token=(.*)$/);
            if (n3)
              return n3[1];
          }
          return null;
        }(r2.params) || R.ACCESS_TOKEN;
        return R.REQUIRE_ACCESS_TOKEN && n2 && this._skuToken && r2.params.push("sku=" + this._skuToken), this._makeAPIURL(r2, n2);
      }, G.prototype.canonicalizeTileURL = function(t2, e2) {
        var r2 = Y(t2);
        if (!r2.path.match(/(^\/v4\/)/) || !r2.path.match(/\.[\w]+$/))
          return t2;
        var n2 = "mapbox://tiles/";
        n2 += r2.path.replace("/v4/", "");
        var i2 = r2.params;
        return e2 && (i2 = i2.filter(function(t3) {
          return !t3.match(/^access_token=/);
        })), i2.length && (n2 += "?" + i2.join("&")), n2;
      }, G.prototype.canonicalizeTileset = function(t2, e2) {
        for (var r2 = !!e2 && Z2(e2), n2 = [], i2 = 0, a2 = t2.tiles || []; i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          J(o2) ? n2.push(this.canonicalizeTileURL(o2, r2)) : n2.push(o2);
        }
        return n2;
      }, G.prototype._makeAPIURL = function(t2, e2) {
        var r2 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = Y(R.API_URL);
        if (t2.protocol = n2.protocol, t2.authority = n2.authority, "http" === t2.protocol) {
          var i2 = t2.params.indexOf("secure");
          i2 >= 0 && t2.params.splice(i2, 1);
        }
        if ("/" !== n2.path && (t2.path = "" + n2.path + t2.path), !R.REQUIRE_ACCESS_TOKEN)
          return $(t2);
        if (!(e2 = e2 || R.ACCESS_TOKEN))
          throw new Error("An API access token is required to use Mapbox GL. " + r2);
        if ("s" === e2[0])
          throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r2);
        return t2.params = t2.params.filter(function(t3) {
          return -1 === t3.indexOf("access_token");
        }), t2.params.push("access_token=" + e2), $(t2);
      };
      var X = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      function J(t2) {
        return X.test(t2);
      }
      var H = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Y(t2) {
        var e2 = t2.match(H);
        if (!e2)
          throw new Error("Unable to parse URL object");
        return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
      }
      function $(t2) {
        var e2 = t2.params.length ? "?" + t2.params.join("&") : "";
        return t2.protocol + "://" + t2.authority + t2.path + e2;
      }
      function W(t2) {
        if (!t2)
          return null;
        var e2 = t2.split(".");
        if (!e2 || 3 !== e2.length)
          return null;
        try {
          return JSON.parse(decodeURIComponent(o.atob(e2[1]).split("").map(function(t3) {
            return "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2);
          }).join("")));
        } catch (t3) {
          return null;
        }
      }
      var Q = function(t2) {
        this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      };
      Q.prototype.getStorageKey = function(t2) {
        var e2, r2 = W(R.ACCESS_TOKEN);
        return e2 = r2 && r2.u ? o.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, function(t3, e3) {
          return String.fromCharCode(Number("0x" + e3));
        })) : R.ACCESS_TOKEN || "", t2 ? "mapbox.eventData." + t2 + ":" + e2 : "mapbox.eventData:" + e2;
      }, Q.prototype.fetchEventData = function() {
        var t2 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
        if (t2)
          try {
            var n2 = o.localStorage.getItem(e2);
            n2 && (this.eventData = JSON.parse(n2));
            var i2 = o.localStorage.getItem(r2);
            i2 && (this.anonId = i2);
          } catch (t3) {
            A2("Unable to read from LocalStorage");
          }
      }, Q.prototype.saveEventData = function() {
        var t2 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
        if (t2)
          try {
            o.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e2, JSON.stringify(this.eventData));
          } catch (t3) {
            A2("Unable to write to LocalStorage");
          }
      }, Q.prototype.processRequests = function(t2) {
      }, Q.prototype.postEvent = function(t2, e2, r2, n2) {
        var i2 = this;
        if (R.EVENTS_URL) {
          var a2 = Y(R.EVENTS_URL);
          a2.params.push("access_token=" + (n2 || R.ACCESS_TOKEN || ""));
          var o2 = { event: this.type, created: new Date(t2).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: K, userId: this.anonId }, s2 = e2 ? h2(o2, e2) : o2, u2 = { url: $(a2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([s2]) };
          this.pendingRequest = wt(u2, function(t3) {
            i2.pendingRequest = null, r2(t3), i2.saveEventData(), i2.processRequests(n2);
          });
        }
      }, Q.prototype.queueRequest = function(t2, e2) {
        this.queue.push(t2), this.processRequests(e2);
      };
      var tt, et, rt = function(t2) {
        function e2() {
          t2.call(this, "map.load"), this.success = {}, this.skuToken = "";
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.postMapLoadEvent = function(t3, e3, r2, n2) {
          this.skuToken = r2;
          var i2 = !(!n2 && !R.ACCESS_TOKEN), a2 = Array.isArray(t3) && t3.some(function(t4) {
            return Z2(t4) || J(t4);
          });
          R.EVENTS_URL && i2 && a2 && this.queueRequest({ id: e3, timestamp: Date.now() }, n2);
        }, e2.prototype.processRequests = function(t3) {
          var e3 = this;
          if (!this.pendingRequest && 0 !== this.queue.length) {
            var r2 = this.queue.shift(), n2 = r2.id, i2 = r2.timestamp;
            n2 && this.success[n2] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i2, { skuToken: this.skuToken }, function(t4) {
              t4 || n2 && (e3.success[n2] = true);
            }, t3));
          }
        }, e2;
      }(Q), nt = new (function(t2) {
        function e2(e3) {
          t2.call(this, "appUserTurnstile"), this._customAccessToken = e3;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.postTurnstileEvent = function(t3, e3) {
          R.EVENTS_URL && R.ACCESS_TOKEN && Array.isArray(t3) && t3.some(function(t4) {
            return Z2(t4) || J(t4);
          }) && this.queueRequest(Date.now(), e3);
        }, e2.prototype.processRequests = function(t3) {
          var e3 = this;
          if (!this.pendingRequest && 0 !== this.queue.length) {
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            var r2 = W(R.ACCESS_TOKEN), n2 = r2 ? r2.u : R.ACCESS_TOKEN, i2 = n2 !== this.eventData.tokenU;
            m(this.anonId) || (this.anonId = d(), i2 = true);
            var a2 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              var o2 = new Date(this.eventData.lastSuccess), s2 = new Date(a2), u2 = (a2 - this.eventData.lastSuccess) / 864e5;
              i2 = i2 || u2 >= 1 || u2 < -1 || o2.getDate() !== s2.getDate();
            } else
              i2 = true;
            if (!i2)
              return this.processRequests();
            this.postEvent(a2, { "enabled.telemetry": false }, function(t4) {
              t4 || (e3.eventData.lastSuccess = a2, e3.eventData.tokenU = n2);
            }, t3);
          }
        }, e2;
      }(Q))(), it = nt.postTurnstileEvent.bind(nt), at = new rt(), ot = at.postMapLoadEvent.bind(at), st = 500, ut = 50;
      function lt() {
        o.caches && !tt && (tt = o.caches.open("mapbox-tiles"));
      }
      function pt(t2) {
        var e2 = t2.indexOf("?");
        return e2 < 0 ? t2 : t2.slice(0, e2);
      }
      var ct, ht = 1 / 0;
      function ft() {
        return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;
      }
      var yt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      "function" == typeof Object.freeze && Object.freeze(yt);
      var dt = function(t2) {
        function e2(e3, r2, n2) {
          401 === r2 && J(n2) && (e3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t2.call(this, e3), this.status = r2, this.url = n2, this.name = this.constructor.name, this.message = e3;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.toString = function() {
          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
        }, e2;
      }(Error), mt = I2() ? function() {
        return self.worker && self.worker.referrer;
      } : function() {
        return ("blob:" === o.location.protocol ? o.parent : o).location.href;
      };
      var vt, gt, xt = function(t2, e2) {
        if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(mt()) && !/^\w+:/.test(r2))) {
          if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal"))
            return function(t3, e3) {
              var r3, n2 = new o.AbortController(), i2 = new o.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: mt(), signal: n2.signal }), a2 = false, s2 = false, u2 = (r3 = i2.url).indexOf("sku=") > 0 && J(r3);
              "json" === t3.type && i2.headers.set("Accept", "application/json");
              var l2 = function(r4, n3, a3) {
                if (!s2) {
                  if (r4 && "SecurityError" !== r4.message && A2(r4), n3 && a3)
                    return p3(n3);
                  var l3 = Date.now();
                  o.fetch(i2).then(function(r5) {
                    if (r5.ok) {
                      var n4 = u2 ? r5.clone() : null;
                      return p3(r5, n4, l3);
                    }
                    return e3(new dt(r5.statusText, r5.status, t3.url));
                  }).catch(function(t4) {
                    20 !== t4.code && e3(new Error(t4.message));
                  });
                }
              }, p3 = function(r4, n3, u3) {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then(function(t4) {
                  s2 || (n3 && u3 && function(t5, e4, r5) {
                    if (lt(), tt) {
                      var n4 = { status: e4.status, statusText: e4.statusText, headers: new o.Headers() };
                      e4.headers.forEach(function(t6, e5) {
                        return n4.headers.set(e5, t6);
                      });
                      var i3 = z(e4.headers.get("Cache-Control") || "");
                      i3["no-store"] || (i3["max-age"] && n4.headers.set("Expires", new Date(r5 + 1e3 * i3["max-age"]).toUTCString()), new Date(n4.headers.get("Expires")).getTime() - r5 < 42e4 || function(t6, e5) {
                        if (void 0 === et)
                          try {
                            new Response(new ReadableStream()), et = true;
                          } catch (t7) {
                            et = false;
                          }
                        et ? e5(t6.body) : t6.blob().then(e5);
                      }(e4, function(e5) {
                        var r6 = new o.Response(e5, n4);
                        lt(), tt && tt.then(function(e6) {
                          return e6.put(pt(t5.url), r6);
                        }).catch(function(t6) {
                          return A2(t6.message);
                        });
                      }));
                    }
                  }(i2, n3, u3), a2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                }).catch(function(t4) {
                  s2 || e3(new Error(t4.message));
                });
              };
              return u2 ? function(t4, e4) {
                if (lt(), !tt)
                  return e4(null);
                var r4 = pt(t4.url);
                tt.then(function(t5) {
                  t5.match(r4).then(function(n3) {
                    var i3 = function(t6) {
                      if (!t6)
                        return false;
                      var e5 = new Date(t6.headers.get("Expires") || 0), r5 = z(t6.headers.get("Cache-Control") || "");
                      return e5 > Date.now() && !r5["no-cache"];
                    }(n3);
                    t5.delete(r4), i3 && t5.put(r4, n3.clone()), e4(null, n3, i3);
                  }).catch(e4);
                }).catch(e4);
              }(i2, l2) : l2(null, null), { cancel: function() {
                s2 = true, a2 || n2.abort();
              } };
            }(t2, e2);
          if (I2() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t2, e2, void 0, true);
        }
        var r2;
        return function(t3, e3) {
          var r3 = new o.XMLHttpRequest();
          for (var n2 in r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer"), t3.headers)
            r3.setRequestHeader(n2, t3.headers[n2]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = function() {
            e3(new Error(r3.statusText));
          }, r3.onload = function() {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              var n3 = r3.response;
              if ("json" === t3.type)
                try {
                  n3 = JSON.parse(r3.response);
                } catch (t4) {
                  return e3(t4);
                }
              e3(null, n3, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else
              e3(new dt(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: function() {
            return r3.abort();
          } };
        }(t2, e2);
      }, bt = function(t2, e2) {
        return xt(h2(t2, { type: "arrayBuffer" }), e2);
      }, wt = function(t2, e2) {
        return xt(h2(t2, { method: "POST" }), e2);
      }, _t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      vt = [], gt = 0;
      var At = function(t2, e2) {
        if (U.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), gt >= R.MAX_PARALLEL_IMAGE_REQUESTS) {
          var r2 = { requestParameters: t2, callback: e2, cancelled: false, cancel: function() {
            this.cancelled = true;
          } };
          return vt.push(r2), r2;
        }
        gt++;
        var n2 = false, i2 = function() {
          if (!n2)
            for (n2 = true, gt--; vt.length && gt < R.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var t3 = vt.shift();
              t3.cancelled || (t3.cancel = At(t3.requestParameters, t3.callback).cancel);
            }
        }, a2 = bt(t2, function(t3, r3, n3, a3) {
          i2(), t3 ? e2(t3) : r3 && (ft() ? function(t4, e3) {
            var r4 = new o.Blob([new Uint8Array(t4)], { type: "image/png" });
            o.createImageBitmap(r4).then(function(t5) {
              e3(null, t5);
            }).catch(function(t5) {
              e3(new Error("Could not load image because of " + t5.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            });
          }(r3, e2) : function(t4, e3, r4, n4) {
            var i3 = new o.Image(), a4 = o.URL;
            i3.onload = function() {
              e3(null, i3), a4.revokeObjectURL(i3.src), i3.onload = null, o.requestAnimationFrame(function() {
                i3.src = _t;
              });
            }, i3.onerror = function() {
              return e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            };
            var s2 = new o.Blob([new Uint8Array(t4)], { type: "image/png" });
            i3.cacheControl = r4, i3.expires = n4, i3.src = t4.byteLength ? a4.createObjectURL(s2) : _t;
          }(r3, e2, n3, a3));
        });
        return { cancel: function() {
          a2.cancel(), i2();
        } };
      };
      function St(t2, e2, r2) {
        r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function kt(t2, e2, r2) {
        if (r2 && r2[t2]) {
          var n2 = r2[t2].indexOf(e2);
          -1 !== n2 && r2[t2].splice(n2, 1);
        }
      }
      var It = function(t2, e2) {
        void 0 === e2 && (e2 = {}), h2(this, e2), this.type = t2;
      }, zt = function(t2) {
        function e2(e3, r2) {
          void 0 === r2 && (r2 = {}), t2.call(this, "error", h2({ error: e3 }, r2));
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(It), Ct = function() {
      };
      Ct.prototype.on = function(t2, e2) {
        return this._listeners = this._listeners || {}, St(t2, e2, this._listeners), this;
      }, Ct.prototype.off = function(t2, e2) {
        return kt(t2, e2, this._listeners), kt(t2, e2, this._oneTimeListeners), this;
      }, Ct.prototype.once = function(t2, e2) {
        return this._oneTimeListeners = this._oneTimeListeners || {}, St(t2, e2, this._oneTimeListeners), this;
      }, Ct.prototype.fire = function(t2, e2) {
        "string" == typeof t2 && (t2 = new It(t2, e2 || {}));
        var r2 = t2.type;
        if (this.listens(r2)) {
          t2.target = this;
          for (var n2 = 0, i2 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : []; n2 < i2.length; n2 += 1)
            i2[n2].call(this, t2);
          for (var a2 = 0, o2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : []; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2];
            kt(r2, s2, this._oneTimeListeners), s2.call(this, t2);
          }
          var u2 = this._eventedParent;
          u2 && (h2(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u2.fire(t2));
        } else
          t2 instanceof zt && console.error(t2.error);
        return this;
      }, Ct.prototype.listens = function(t2) {
        return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
      }, Ct.prototype.setEventedParent = function(t2, e2) {
        return this._eventedParent = t2, this._eventedParentData = e2, this;
      };
      var Et = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, Pt = function(t2, e2, r2, n2) {
        this.message = (t2 ? t2 + ": " : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
      };
      function Mt(t2) {
        var e2 = t2.value;
        return e2 ? [new Pt(t2.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function Bt(t2) {
        for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
          e2[r2] = arguments[r2 + 1];
        for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          for (var o2 in a2)
            t2[o2] = a2[o2];
        }
        return t2;
      }
      function Tt(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function Vt(t2) {
        if (Array.isArray(t2))
          return t2.map(Vt);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          var e2 = {};
          for (var r2 in t2)
            e2[r2] = Vt(t2[r2]);
          return e2;
        }
        return Tt(t2);
      }
      var Ft = function(t2) {
        function e2(e3, r2) {
          t2.call(this, r2), this.message = r2, this.key = e3;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(Error), Dt = function(t2, e2) {
        void 0 === e2 && (e2 = []), this.parent = t2, this.bindings = {};
        for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
          var i2 = n2[r2];
          this.bindings[i2[0]] = i2[1];
        }
      };
      Dt.prototype.concat = function(t2) {
        return new Dt(this, t2);
      }, Dt.prototype.get = function(t2) {
        if (this.bindings[t2])
          return this.bindings[t2];
        if (this.parent)
          return this.parent.get(t2);
        throw new Error(t2 + " not found in scope.");
      }, Dt.prototype.has = function(t2) {
        return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
      };
      var Lt = { kind: "null" }, Ot = { kind: "number" }, Rt = { kind: "string" }, Ut = { kind: "boolean" }, jt = { kind: "color" }, qt = { kind: "object" }, Nt = { kind: "value" }, Kt = { kind: "collator" }, Gt = { kind: "formatted" }, Zt = { kind: "resolvedImage" };
      function Xt(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function Jt(t2) {
        if ("array" === t2.kind) {
          var e2 = Jt(t2.itemType);
          return "number" == typeof t2.N ? "array<" + e2 + ", " + t2.N + ">" : "value" === t2.itemType.kind ? "array" : "array<" + e2 + ">";
        }
        return t2.kind;
      }
      var Ht = [Lt, Ot, Rt, Ut, jt, Gt, qt, Xt(Nt), Zt];
      function Yt(t2, e2) {
        if ("error" === e2.kind)
          return null;
        if ("array" === t2.kind) {
          if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Yt(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if ("value" === t2.kind) {
            for (var r2 = 0, n2 = Ht; r2 < n2.length; r2 += 1)
              if (!Yt(n2[r2], e2))
                return null;
          }
        }
        return "Expected " + Jt(t2) + " but found " + Jt(e2) + " instead.";
      }
      function $t(t2, e2) {
        return e2.some(function(e3) {
          return e3.kind === t2.kind;
        });
      }
      function Wt(t2, e2) {
        return e2.some(function(e3) {
          return "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2;
        });
      }
      var Qt = e(function(t2, e2) {
        var r2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function n2(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function i2(t3) {
          return n2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function a2(t3) {
          return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function o2(t3, e3, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
        }
        try {
          e2.parseCSSColor = function(t3) {
            var e3, s2 = t3.replace(/ /g, "").toLowerCase();
            if (s2 in r2)
              return r2[s2].slice();
            if ("#" === s2[0])
              return 4 === s2.length ? (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === s2.length && (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
            var u2 = s2.indexOf("("), l2 = s2.indexOf(")");
            if (-1 !== u2 && l2 + 1 === s2.length) {
              var p3 = s2.substr(0, u2), c3 = s2.substr(u2 + 1, l2 - (u2 + 1)).split(","), h3 = 1;
              switch (p3) {
                case "rgba":
                  if (4 !== c3.length)
                    return null;
                  h3 = a2(c3.pop());
                case "rgb":
                  return 3 !== c3.length ? null : [i2(c3[0]), i2(c3[1]), i2(c3[2]), h3];
                case "hsla":
                  if (4 !== c3.length)
                    return null;
                  h3 = a2(c3.pop());
                case "hsl":
                  if (3 !== c3.length)
                    return null;
                  var f2 = (parseFloat(c3[0]) % 360 + 360) % 360 / 360, y3 = a2(c3[1]), d2 = a2(c3[2]), m2 = d2 <= 0.5 ? d2 * (y3 + 1) : d2 + y3 - d2 * y3, v3 = 2 * d2 - m2;
                  return [n2(255 * o2(v3, m2, f2 + 1 / 3)), n2(255 * o2(v3, m2, f2)), n2(255 * o2(v3, m2, f2 - 1 / 3)), h3];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
      }).parseCSSColor, te = function(t2, e2, r2, n2) {
        void 0 === n2 && (n2 = 1), this.r = t2, this.g = e2, this.b = r2, this.a = n2;
      };
      te.parse = function(t2) {
        if (t2) {
          if (t2 instanceof te)
            return t2;
          if ("string" == typeof t2) {
            var e2 = Qt(t2);
            if (e2)
              return new te(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]);
          }
        }
      }, te.prototype.toString = function() {
        var t2 = this.toArray(), e2 = t2[1], r2 = t2[2], n2 = t2[3];
        return "rgba(" + Math.round(t2[0]) + "," + Math.round(e2) + "," + Math.round(r2) + "," + n2 + ")";
      }, te.prototype.toArray = function() {
        var t2 = this.a;
        return 0 === t2 ? [0, 0, 0, 0] : [255 * this.r / t2, 255 * this.g / t2, 255 * this.b / t2, t2];
      }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1);
      var ee = function(t2, e2, r2) {
        this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
      };
      ee.prototype.compare = function(t2, e2) {
        return this.collator.compare(t2, e2);
      }, ee.prototype.resolvedLocale = function() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      };
      var re = function(t2, e2, r2, n2, i2) {
        this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
      }, ne = function(t2) {
        this.sections = t2;
      };
      ne.fromString = function(t2) {
        return new ne([new re(t2, null, null, null, null)]);
      }, ne.prototype.isEmpty = function() {
        return 0 === this.sections.length || !this.sections.some(function(t2) {
          return 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length;
        });
      }, ne.factory = function(t2) {
        return t2 instanceof ne ? t2 : ne.fromString(t2);
      }, ne.prototype.toString = function() {
        return 0 === this.sections.length ? "" : this.sections.map(function(t2) {
          return t2.text;
        }).join("");
      }, ne.prototype.serialize = function() {
        for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2];
          if (n2.image)
            t2.push(["image", n2.image.name]);
          else {
            t2.push(n2.text);
            var i2 = {};
            n2.fontStack && (i2["text-font"] = ["literal", n2.fontStack.split(",")]), n2.scale && (i2["font-scale"] = n2.scale), n2.textColor && (i2["text-color"] = ["rgba"].concat(n2.textColor.toArray())), t2.push(i2);
          }
        }
        return t2;
      };
      var ie = function(t2) {
        this.name = t2.name, this.available = t2.available;
      };
      function ae(t2, e2, r2, n2) {
        return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : "Invalid rgba value [" + [t2, e2, r2, n2].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
      }
      function oe(t2) {
        if (null === t2)
          return true;
        if ("string" == typeof t2)
          return true;
        if ("boolean" == typeof t2)
          return true;
        if ("number" == typeof t2)
          return true;
        if (t2 instanceof te)
          return true;
        if (t2 instanceof ee)
          return true;
        if (t2 instanceof ne)
          return true;
        if (t2 instanceof ie)
          return true;
        if (Array.isArray(t2)) {
          for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
            if (!oe(r2[e2]))
              return false;
          return true;
        }
        if ("object" == typeof t2) {
          for (var n2 in t2)
            if (!oe(t2[n2]))
              return false;
          return true;
        }
        return false;
      }
      function se(t2) {
        if (null === t2)
          return Lt;
        if ("string" == typeof t2)
          return Rt;
        if ("boolean" == typeof t2)
          return Ut;
        if ("number" == typeof t2)
          return Ot;
        if (t2 instanceof te)
          return jt;
        if (t2 instanceof ee)
          return Kt;
        if (t2 instanceof ne)
          return Gt;
        if (t2 instanceof ie)
          return Zt;
        if (Array.isArray(t2)) {
          for (var e2, r2 = t2.length, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
            var a2 = se(i2[n2]);
            if (e2) {
              if (e2 === a2)
                continue;
              e2 = Nt;
              break;
            }
            e2 = a2;
          }
          return Xt(e2 || Nt, r2);
        }
        return qt;
      }
      function ue(t2) {
        var e2 = typeof t2;
        return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof te || t2 instanceof ne || t2 instanceof ie ? t2.toString() : JSON.stringify(t2);
      }
      ie.prototype.toString = function() {
        return this.name;
      }, ie.fromString = function(t2) {
        return t2 ? new ie({ name: t2, available: false }) : null;
      }, ie.prototype.serialize = function() {
        return ["image", this.name];
      };
      var le = function(t2, e2) {
        this.type = t2, this.value = e2;
      };
      le.parse = function(t2, e2) {
        if (2 !== t2.length)
          return e2.error("'literal' expression requires exactly one argument, but found " + (t2.length - 1) + " instead.");
        if (!oe(t2[1]))
          return e2.error("invalid value");
        var r2 = t2[1], n2 = se(r2), i2 = e2.expectedType;
        return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new le(n2, r2);
      }, le.prototype.evaluate = function() {
        return this.value;
      }, le.prototype.eachChild = function() {
      }, le.prototype.outputDefined = function() {
        return true;
      }, le.prototype.serialize = function() {
        return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ne ? this.value.serialize() : this.value;
      };
      var pe = function(t2) {
        this.name = "ExpressionEvaluationError", this.message = t2;
      };
      pe.prototype.toJSON = function() {
        return this.message;
      };
      var ce = { string: Rt, number: Ot, boolean: Ut, object: qt }, he = function(t2, e2) {
        this.type = t2, this.args = e2;
      };
      he.parse = function(t2, e2) {
        if (t2.length < 2)
          return e2.error("Expected at least one argument.");
        var r2, n2 = 1, i2 = t2[0];
        if ("array" === i2) {
          var a2, o2;
          if (t2.length > 2) {
            var s2 = t2[1];
            if ("string" != typeof s2 || !(s2 in ce) || "object" === s2)
              return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
            a2 = ce[s2], n2++;
          } else
            a2 = Nt;
          if (t2.length > 3) {
            if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
              return e2.error('The length argument to "array" must be a positive integer literal', 2);
            o2 = t2[2], n2++;
          }
          r2 = Xt(a2, o2);
        } else
          r2 = ce[i2];
        for (var u2 = []; n2 < t2.length; n2++) {
          var l2 = e2.parse(t2[n2], n2, Nt);
          if (!l2)
            return null;
          u2.push(l2);
        }
        return new he(r2, u2);
      }, he.prototype.evaluate = function(t2) {
        for (var e2 = 0; e2 < this.args.length; e2++) {
          var r2 = this.args[e2].evaluate(t2);
          if (!Yt(this.type, se(r2)))
            return r2;
          if (e2 === this.args.length - 1)
            throw new pe("Expected value to be of type " + Jt(this.type) + ", but found " + Jt(se(r2)) + " instead.");
        }
        return null;
      }, he.prototype.eachChild = function(t2) {
        this.args.forEach(t2);
      }, he.prototype.outputDefined = function() {
        return this.args.every(function(t2) {
          return t2.outputDefined();
        });
      }, he.prototype.serialize = function() {
        var t2 = this.type, e2 = [t2.kind];
        if ("array" === t2.kind) {
          var r2 = t2.itemType;
          if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
            e2.push(r2.kind);
            var n2 = t2.N;
            ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
          }
        }
        return e2.concat(this.args.map(function(t3) {
          return t3.serialize();
        }));
      };
      var fe = function(t2) {
        this.type = Gt, this.sections = t2;
      };
      fe.parse = function(t2, e2) {
        if (t2.length < 2)
          return e2.error("Expected at least one argument.");
        var r2 = t2[1];
        if (!Array.isArray(r2) && "object" == typeof r2)
          return e2.error("First argument must be an image or text section.");
        for (var n2 = [], i2 = false, a2 = 1; a2 <= t2.length - 1; ++a2) {
          var o2 = t2[a2];
          if (i2 && "object" == typeof o2 && !Array.isArray(o2)) {
            i2 = false;
            var s2 = null;
            if (o2["font-scale"] && !(s2 = e2.parse(o2["font-scale"], 1, Ot)))
              return null;
            var u2 = null;
            if (o2["text-font"] && !(u2 = e2.parse(o2["text-font"], 1, Xt(Rt))))
              return null;
            var l2 = null;
            if (o2["text-color"] && !(l2 = e2.parse(o2["text-color"], 1, jt)))
              return null;
            var p3 = n2[n2.length - 1];
            p3.scale = s2, p3.font = u2, p3.textColor = l2;
          } else {
            var c3 = e2.parse(t2[a2], 1, Nt);
            if (!c3)
              return null;
            var h3 = c3.type.kind;
            if ("string" !== h3 && "value" !== h3 && "null" !== h3 && "resolvedImage" !== h3)
              return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            i2 = true, n2.push({ content: c3, scale: null, font: null, textColor: null });
          }
        }
        return new fe(n2);
      }, fe.prototype.evaluate = function(t2) {
        return new ne(this.sections.map(function(e2) {
          var r2 = e2.content.evaluate(t2);
          return se(r2) === Zt ? new re("", r2, null, null, null) : new re(ue(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
        }));
      }, fe.prototype.eachChild = function(t2) {
        for (var e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2];
          t2(n2.content), n2.scale && t2(n2.scale), n2.font && t2(n2.font), n2.textColor && t2(n2.textColor);
        }
      }, fe.prototype.outputDefined = function() {
        return false;
      }, fe.prototype.serialize = function() {
        for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2];
          t2.push(n2.content.serialize());
          var i2 = {};
          n2.scale && (i2["font-scale"] = n2.scale.serialize()), n2.font && (i2["text-font"] = n2.font.serialize()), n2.textColor && (i2["text-color"] = n2.textColor.serialize()), t2.push(i2);
        }
        return t2;
      };
      var ye = function(t2) {
        this.type = Zt, this.input = t2;
      };
      ye.parse = function(t2, e2) {
        if (2 !== t2.length)
          return e2.error("Expected two arguments.");
        var r2 = e2.parse(t2[1], 1, Rt);
        return r2 ? new ye(r2) : e2.error("No image name provided.");
      }, ye.prototype.evaluate = function(t2) {
        var e2 = this.input.evaluate(t2), r2 = ie.fromString(e2);
        return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
      }, ye.prototype.eachChild = function(t2) {
        t2(this.input);
      }, ye.prototype.outputDefined = function() {
        return false;
      }, ye.prototype.serialize = function() {
        return ["image", this.input.serialize()];
      };
      var de = { "to-boolean": Ut, "to-color": jt, "to-number": Ot, "to-string": Rt }, me = function(t2, e2) {
        this.type = t2, this.args = e2;
      };
      me.parse = function(t2, e2) {
        if (t2.length < 2)
          return e2.error("Expected at least one argument.");
        var r2 = t2[0];
        if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
          return e2.error("Expected one argument.");
        for (var n2 = de[r2], i2 = [], a2 = 1; a2 < t2.length; a2++) {
          var o2 = e2.parse(t2[a2], a2, Nt);
          if (!o2)
            return null;
          i2.push(o2);
        }
        return new me(n2, i2);
      }, me.prototype.evaluate = function(t2) {
        if ("boolean" === this.type.kind)
          return Boolean(this.args[0].evaluate(t2));
        if ("color" === this.type.kind) {
          for (var e2, r2, n2 = 0, i2 = this.args; n2 < i2.length; n2 += 1) {
            if (r2 = null, (e2 = i2[n2].evaluate(t2)) instanceof te)
              return e2;
            if ("string" == typeof e2) {
              var a2 = t2.parseColor(e2);
              if (a2)
                return a2;
            } else if (Array.isArray(e2) && !(r2 = e2.length < 3 || e2.length > 4 ? "Invalid rbga value " + JSON.stringify(e2) + ": expected an array containing either three or four numeric values." : ae(e2[0], e2[1], e2[2], e2[3])))
              return new te(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
          }
          throw new pe(r2 || "Could not parse color from value '" + ("string" == typeof e2 ? e2 : String(JSON.stringify(e2))) + "'");
        }
        if ("number" === this.type.kind) {
          for (var o2 = null, s2 = 0, u2 = this.args; s2 < u2.length; s2 += 1) {
            if (null === (o2 = u2[s2].evaluate(t2)))
              return 0;
            var l2 = Number(o2);
            if (!isNaN(l2))
              return l2;
          }
          throw new pe("Could not convert " + JSON.stringify(o2) + " to number.");
        }
        return "formatted" === this.type.kind ? ne.fromString(ue(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? ie.fromString(ue(this.args[0].evaluate(t2))) : ue(this.args[0].evaluate(t2));
      }, me.prototype.eachChild = function(t2) {
        this.args.forEach(t2);
      }, me.prototype.outputDefined = function() {
        return this.args.every(function(t2) {
          return t2.outputDefined();
        });
      }, me.prototype.serialize = function() {
        if ("formatted" === this.type.kind)
          return new fe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
        if ("resolvedImage" === this.type.kind)
          return new ye(this.args[0]).serialize();
        var t2 = ["to-" + this.type.kind];
        return this.eachChild(function(e2) {
          t2.push(e2.serialize());
        }), t2;
      };
      var ve = ["Unknown", "Point", "LineString", "Polygon"], ge = function() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
      };
      ge.prototype.id = function() {
        return this.feature && "id" in this.feature ? this.feature.id : null;
      }, ge.prototype.geometryType = function() {
        return this.feature ? "number" == typeof this.feature.type ? ve[this.feature.type] : this.feature.type : null;
      }, ge.prototype.geometry = function() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }, ge.prototype.canonicalID = function() {
        return this.canonical;
      }, ge.prototype.properties = function() {
        return this.feature && this.feature.properties || {};
      }, ge.prototype.parseColor = function(t2) {
        var e2 = this._parseColorCache[t2];
        return e2 || (e2 = this._parseColorCache[t2] = te.parse(t2)), e2;
      };
      var xe = function(t2, e2, r2, n2) {
        this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
      };
      xe.prototype.evaluate = function(t2) {
        return this._evaluate(t2, this.args);
      }, xe.prototype.eachChild = function(t2) {
        this.args.forEach(t2);
      }, xe.prototype.outputDefined = function() {
        return false;
      }, xe.prototype.serialize = function() {
        return [this.name].concat(this.args.map(function(t2) {
          return t2.serialize();
        }));
      }, xe.parse = function(t2, e2) {
        var r2, n2 = t2[0], i2 = xe.definitions[n2];
        if (!i2)
          return e2.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
        for (var a2 = Array.isArray(i2) ? i2[0] : i2.type, o2 = Array.isArray(i2) ? [[i2[1], i2[2]]] : i2.overloads, s2 = o2.filter(function(e3) {
          var r3 = e3[0];
          return !Array.isArray(r3) || r3.length === t2.length - 1;
        }), u2 = null, l2 = 0, p3 = s2; l2 < p3.length; l2 += 1) {
          var c3 = p3[l2], h3 = c3[0], f2 = c3[1];
          u2 = new je(e2.registry, e2.path, null, e2.scope);
          for (var y3 = [], d2 = false, m2 = 1; m2 < t2.length; m2++) {
            var v3 = t2[m2], g2 = Array.isArray(h3) ? h3[m2 - 1] : h3.type, x2 = u2.parse(v3, 1 + y3.length, g2);
            if (!x2) {
              d2 = true;
              break;
            }
            y3.push(x2);
          }
          if (!d2)
            if (Array.isArray(h3) && h3.length !== y3.length)
              u2.error("Expected " + h3.length + " arguments, but found " + y3.length + " instead.");
            else {
              for (var b2 = 0; b2 < y3.length; b2++) {
                var w2 = Array.isArray(h3) ? h3[b2] : h3.type, _24 = y3[b2];
                u2.concat(b2 + 1).checkSubtype(w2, _24.type);
              }
              if (0 === u2.errors.length)
                return new xe(n2, a2, f2, y3);
            }
        }
        if (1 === s2.length)
          (r2 = e2.errors).push.apply(r2, u2.errors);
        else {
          for (var A3 = (s2.length ? s2 : o2).map(function(t3) {
            var e3;
            return e3 = t3[0], Array.isArray(e3) ? "(" + e3.map(Jt).join(", ") + ")" : "(" + Jt(e3.type) + "...)";
          }).join(" | "), S2 = [], k2 = 1; k2 < t2.length; k2++) {
            var I3 = e2.parse(t2[k2], 1 + S2.length);
            if (!I3)
              return null;
            S2.push(Jt(I3.type));
          }
          e2.error("Expected arguments of type " + A3 + ", but found (" + S2.join(", ") + ") instead.");
        }
        return null;
      }, xe.register = function(t2, e2) {
        for (var r2 in xe.definitions = e2, e2)
          t2[r2] = xe;
      };
      var be = function(t2, e2, r2) {
        this.type = Kt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
      };
      function we(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function _e(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function Ae(t2, e2) {
        var r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * 8192), Math.round(n2 * i2 * 8192)];
      }
      function Se(t2, e2, r2) {
        return e2[1] > t2[1] != r2[1] > t2[1] && t2[0] < (r2[0] - e2[0]) * (t2[1] - e2[1]) / (r2[1] - e2[1]) + e2[0];
      }
      function ke(t2, e2) {
        for (var r2, n2, i2, a2, o2, s2, u2, l2 = false, p3 = 0, c3 = e2.length; p3 < c3; p3++)
          for (var h3 = e2[p3], f2 = 0, y3 = h3.length; f2 < y3 - 1; f2++) {
            if ((a2 = (r2 = t2)[0] - (n2 = h3[f2])[0]) * (u2 = r2[1] - (i2 = h3[f2 + 1])[1]) - (s2 = r2[0] - i2[0]) * (o2 = r2[1] - n2[1]) == 0 && a2 * s2 <= 0 && o2 * u2 <= 0)
              return false;
            Se(t2, h3[f2], h3[f2 + 1]) && (l2 = !l2);
          }
        return l2;
      }
      function Ie(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++)
          if (ke(t2, e2[r2]))
            return true;
        return false;
      }
      function ze(t2, e2, r2, n2) {
        var i2 = n2[0] - r2[0], a2 = n2[1] - r2[1], o2 = (t2[0] - r2[0]) * a2 - i2 * (t2[1] - r2[1]), s2 = (e2[0] - r2[0]) * a2 - i2 * (e2[1] - r2[1]);
        return o2 > 0 && s2 < 0 || o2 < 0 && s2 > 0;
      }
      function Ce(t2, e2, r2) {
        for (var n2 = 0, i2 = r2; n2 < i2.length; n2 += 1)
          for (var a2 = i2[n2], o2 = 0; o2 < a2.length - 1; ++o2)
            if (0 != (c3 = [(p3 = a2[o2 + 1])[0] - (l2 = a2[o2])[0], p3[1] - l2[1]])[0] * (h3 = [(u2 = e2)[0] - (s2 = t2)[0], u2[1] - s2[1]])[1] - c3[1] * h3[0] && ze(s2, u2, l2, p3) && ze(l2, p3, s2, u2))
              return true;
        var s2, u2, l2, p3, c3, h3;
        return false;
      }
      function Ee(t2, e2) {
        for (var r2 = 0; r2 < t2.length; ++r2)
          if (!ke(t2[r2], e2))
            return false;
        for (var n2 = 0; n2 < t2.length - 1; ++n2)
          if (Ce(t2[n2], t2[n2 + 1], e2))
            return false;
        return true;
      }
      function Pe(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++)
          if (Ee(t2, e2[r2]))
            return true;
        return false;
      }
      function Me(t2, e2, r2) {
        for (var n2 = [], i2 = 0; i2 < t2.length; i2++) {
          for (var a2 = [], o2 = 0; o2 < t2[i2].length; o2++) {
            var s2 = Ae(t2[i2][o2], r2);
            we(e2, s2), a2.push(s2);
          }
          n2.push(a2);
        }
        return n2;
      }
      function Be(t2, e2, r2) {
        for (var n2 = [], i2 = 0; i2 < t2.length; i2++) {
          var a2 = Me(t2[i2], e2, r2);
          n2.push(a2);
        }
        return n2;
      }
      function Te(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          var i2 = 0.5 * n2, a2 = t2[0] - r2[0] > i2 ? -n2 : r2[0] - t2[0] > i2 ? n2 : 0;
          0 === a2 && (a2 = t2[0] - r2[2] > i2 ? -n2 : r2[2] - t2[0] > i2 ? n2 : 0), t2[0] += a2;
        }
        we(e2, t2);
      }
      function Ve(t2, e2, r2, n2) {
        for (var i2 = 8192 * Math.pow(2, n2.z), a2 = [8192 * n2.x, 8192 * n2.y], o2 = [], s2 = 0, u2 = t2; s2 < u2.length; s2 += 1)
          for (var l2 = 0, p3 = u2[s2]; l2 < p3.length; l2 += 1) {
            var c3 = p3[l2], h3 = [c3.x + a2[0], c3.y + a2[1]];
            Te(h3, e2, r2, i2), o2.push(h3);
          }
        return o2;
      }
      function Fe(t2, e2, r2, n2) {
        for (var i2, a2 = 8192 * Math.pow(2, n2.z), o2 = [8192 * n2.x, 8192 * n2.y], s2 = [], u2 = 0, l2 = t2; u2 < l2.length; u2 += 1) {
          for (var p3 = [], c3 = 0, h3 = l2[u2]; c3 < h3.length; c3 += 1) {
            var f2 = h3[c3], y3 = [f2.x + o2[0], f2.y + o2[1]];
            we(e2, y3), p3.push(y3);
          }
          s2.push(p3);
        }
        if (e2[2] - e2[0] <= a2 / 2) {
          (i2 = e2)[0] = i2[1] = 1 / 0, i2[2] = i2[3] = -1 / 0;
          for (var d2 = 0, m2 = s2; d2 < m2.length; d2 += 1)
            for (var v3 = 0, g2 = m2[d2]; v3 < g2.length; v3 += 1)
              Te(g2[v3], e2, r2, a2);
        }
        return s2;
      }
      be.parse = function(t2, e2) {
        if (2 !== t2.length)
          return e2.error("Expected one argument.");
        var r2 = t2[1];
        if ("object" != typeof r2 || Array.isArray(r2))
          return e2.error("Collator options argument must be an object.");
        var n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Ut);
        if (!n2)
          return null;
        var i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Ut);
        if (!i2)
          return null;
        var a2 = null;
        return r2.locale && !(a2 = e2.parse(r2.locale, 1, Rt)) ? null : new be(n2, i2, a2);
      }, be.prototype.evaluate = function(t2) {
        return new ee(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
      }, be.prototype.eachChild = function(t2) {
        t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
      }, be.prototype.outputDefined = function() {
        return false;
      }, be.prototype.serialize = function() {
        var t2 = {};
        return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
      };
      var De = function(t2, e2) {
        this.type = Ut, this.geojson = t2, this.geometries = e2;
      };
      function Le(t2) {
        if (t2 instanceof xe) {
          if ("get" === t2.name && 1 === t2.args.length)
            return false;
          if ("feature-state" === t2.name)
            return false;
          if ("has" === t2.name && 1 === t2.args.length)
            return false;
          if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof De)
          return false;
        var e2 = true;
        return t2.eachChild(function(t3) {
          e2 && !Le(t3) && (e2 = false);
        }), e2;
      }
      function Oe(t2) {
        if (t2 instanceof xe && "feature-state" === t2.name)
          return false;
        var e2 = true;
        return t2.eachChild(function(t3) {
          e2 && !Oe(t3) && (e2 = false);
        }), e2;
      }
      function Re(t2, e2) {
        if (t2 instanceof xe && e2.indexOf(t2.name) >= 0)
          return false;
        var r2 = true;
        return t2.eachChild(function(t3) {
          r2 && !Re(t3, e2) && (r2 = false);
        }), r2;
      }
      De.parse = function(t2, e2) {
        if (2 !== t2.length)
          return e2.error("'within' expression requires exactly one argument, but found " + (t2.length - 1) + " instead.");
        if (oe(t2[1])) {
          var r2 = t2[1];
          if ("FeatureCollection" === r2.type)
            for (var n2 = 0; n2 < r2.features.length; ++n2) {
              var i2 = r2.features[n2].geometry.type;
              if ("Polygon" === i2 || "MultiPolygon" === i2)
                return new De(r2, r2.features[n2].geometry);
            }
          else if ("Feature" === r2.type) {
            var a2 = r2.geometry.type;
            if ("Polygon" === a2 || "MultiPolygon" === a2)
              return new De(r2, r2.geometry);
          } else if ("Polygon" === r2.type || "MultiPolygon" === r2.type)
            return new De(r2, r2);
        }
        return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }, De.prototype.evaluate = function(t2) {
        if (null != t2.geometry() && null != t2.canonicalID()) {
          if ("Point" === t2.geometryType())
            return function(t3, e2) {
              var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
              if ("Polygon" === e2.type) {
                var a2 = Me(e2.coordinates, n2, i2), o2 = Ve(t3.geometry(), r2, n2, i2);
                if (!_e(r2, n2))
                  return false;
                for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                  if (!ke(u2[s2], a2))
                    return false;
              }
              if ("MultiPolygon" === e2.type) {
                var l2 = Be(e2.coordinates, n2, i2), p3 = Ve(t3.geometry(), r2, n2, i2);
                if (!_e(r2, n2))
                  return false;
                for (var c3 = 0, h3 = p3; c3 < h3.length; c3 += 1)
                  if (!Ie(h3[c3], l2))
                    return false;
              }
              return true;
            }(t2, this.geometries);
          if ("LineString" === t2.geometryType())
            return function(t3, e2) {
              var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
              if ("Polygon" === e2.type) {
                var a2 = Me(e2.coordinates, n2, i2), o2 = Fe(t3.geometry(), r2, n2, i2);
                if (!_e(r2, n2))
                  return false;
                for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                  if (!Ee(u2[s2], a2))
                    return false;
              }
              if ("MultiPolygon" === e2.type) {
                var l2 = Be(e2.coordinates, n2, i2), p3 = Fe(t3.geometry(), r2, n2, i2);
                if (!_e(r2, n2))
                  return false;
                for (var c3 = 0, h3 = p3; c3 < h3.length; c3 += 1)
                  if (!Pe(h3[c3], l2))
                    return false;
              }
              return true;
            }(t2, this.geometries);
        }
        return false;
      }, De.prototype.eachChild = function() {
      }, De.prototype.outputDefined = function() {
        return true;
      }, De.prototype.serialize = function() {
        return ["within", this.geojson];
      };
      var Ue = function(t2, e2) {
        this.type = e2.type, this.name = t2, this.boundExpression = e2;
      };
      Ue.parse = function(t2, e2) {
        if (2 !== t2.length || "string" != typeof t2[1])
          return e2.error("'var' expression requires exactly one string literal argument.");
        var r2 = t2[1];
        return e2.scope.has(r2) ? new Ue(r2, e2.scope.get(r2)) : e2.error('Unknown variable "' + r2 + '". Make sure "' + r2 + '" has been bound in an enclosing "let" expression before using it.', 1);
      }, Ue.prototype.evaluate = function(t2) {
        return this.boundExpression.evaluate(t2);
      }, Ue.prototype.eachChild = function() {
      }, Ue.prototype.outputDefined = function() {
        return false;
      }, Ue.prototype.serialize = function() {
        return ["var", this.name];
      };
      var je = function(t2, e2, r2, n2, i2) {
        void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = new Dt()), void 0 === i2 && (i2 = []), this.registry = t2, this.path = e2, this.key = e2.map(function(t3) {
          return "[" + t3 + "]";
        }).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
      };
      function qe(t2, e2) {
        for (var r2, n2 = t2.length - 1, i2 = 0, a2 = n2, o2 = 0; i2 <= a2; )
          if ((r2 = t2[o2 = Math.floor((i2 + a2) / 2)]) <= e2) {
            if (o2 === n2 || e2 < t2[o2 + 1])
              return o2;
            i2 = o2 + 1;
          } else {
            if (!(r2 > e2))
              throw new pe("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      je.prototype.parse = function(t2, e2, r2, n2, i2) {
        return void 0 === i2 && (i2 = {}), e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
      }, je.prototype._parse = function(t2, e2) {
        function r2(t3, e3, r3) {
          return "assert" === r3 ? new he(e3, [t3]) : "coerce" === r3 ? new me(e3, [t3]) : t3;
        }
        if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
          if (0 === t2.length)
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          var n2 = t2[0];
          if ("string" != typeof n2)
            return this.error("Expression name must be a string, but found " + typeof n2 + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
          var i2 = this.registry[n2];
          if (i2) {
            var a2 = i2.parse(t2, this);
            if (!a2)
              return null;
            if (this.expectedType) {
              var o2 = this.expectedType, s2 = a2.type;
              if ("string" !== o2.kind && "number" !== o2.kind && "boolean" !== o2.kind && "object" !== o2.kind && "array" !== o2.kind || "value" !== s2.kind)
                if ("color" !== o2.kind && "formatted" !== o2.kind && "resolvedImage" !== o2.kind || "value" !== s2.kind && "string" !== s2.kind) {
                  if (this.checkSubtype(o2, s2))
                    return null;
                } else
                  a2 = r2(a2, o2, e2.typeAnnotation || "coerce");
              else
                a2 = r2(a2, o2, e2.typeAnnotation || "assert");
            }
            if (!(a2 instanceof le) && "resolvedImage" !== a2.type.kind && function t3(e3) {
              if (e3 instanceof Ue)
                return t3(e3.boundExpression);
              if (e3 instanceof xe && "error" === e3.name)
                return false;
              if (e3 instanceof be)
                return false;
              if (e3 instanceof De)
                return false;
              var r3 = e3 instanceof me || e3 instanceof he, n3 = true;
              return e3.eachChild(function(e4) {
                n3 = r3 ? n3 && t3(e4) : n3 && e4 instanceof le;
              }), !!n3 && Le(e3) && Re(e3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
            }(a2)) {
              var u2 = new ge();
              try {
                a2 = new le(a2.type, a2.evaluate(u2));
              } catch (t3) {
                return this.error(t3.message), null;
              }
            }
            return a2;
          }
          return this.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
        }
        return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof t2 + " instead.");
      }, je.prototype.concat = function(t2, e2, r2) {
        var n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
        return new je(this.registry, n2, e2 || null, i2, this.errors);
      }, je.prototype.error = function(t2) {
        for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
          e2[r2] = arguments[r2 + 1];
        var n2 = "" + this.key + e2.map(function(t3) {
          return "[" + t3 + "]";
        }).join("");
        this.errors.push(new Ft(n2, t2));
      }, je.prototype.checkSubtype = function(t2, e2) {
        var r2 = Yt(t2, e2);
        return r2 && this.error(r2), r2;
      };
      var Ne = function(t2, e2, r2) {
        this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
        for (var n2 = 0, i2 = r2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2], o2 = a2[1];
          this.labels.push(a2[0]), this.outputs.push(o2);
        }
      };
      function Ke(t2, e2, r2) {
        return t2 * (1 - r2) + e2 * r2;
      }
      Ne.parse = function(t2, e2) {
        if (t2.length - 1 < 4)
          return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
        if ((t2.length - 1) % 2 != 0)
          return e2.error("Expected an even number of arguments.");
        var r2 = e2.parse(t2[1], 1, Ot);
        if (!r2)
          return null;
        var n2 = [], i2 = null;
        e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
        for (var a2 = 1; a2 < t2.length; a2 += 2) {
          var o2 = 1 === a2 ? -1 / 0 : t2[a2], s2 = t2[a2 + 1], u2 = a2, l2 = a2 + 1;
          if ("number" != typeof o2)
            return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u2);
          if (n2.length && n2[n2.length - 1][0] >= o2)
            return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u2);
          var p3 = e2.parse(s2, l2, i2);
          if (!p3)
            return null;
          i2 = i2 || p3.type, n2.push([o2, p3]);
        }
        return new Ne(i2, r2, n2);
      }, Ne.prototype.evaluate = function(t2) {
        var e2 = this.labels, r2 = this.outputs;
        if (1 === e2.length)
          return r2[0].evaluate(t2);
        var n2 = this.input.evaluate(t2);
        if (n2 <= e2[0])
          return r2[0].evaluate(t2);
        var i2 = e2.length;
        return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[qe(e2, n2)].evaluate(t2);
      }, Ne.prototype.eachChild = function(t2) {
        t2(this.input);
        for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
          t2(r2[e2]);
      }, Ne.prototype.outputDefined = function() {
        return this.outputs.every(function(t2) {
          return t2.outputDefined();
        });
      }, Ne.prototype.serialize = function() {
        for (var t2 = ["step", this.input.serialize()], e2 = 0; e2 < this.labels.length; e2++)
          e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
        return t2;
      };
      var Ge = Object.freeze({ __proto__: null, number: Ke, color: function(t2, e2, r2) {
        return new te(Ke(t2.r, e2.r, r2), Ke(t2.g, e2.g, r2), Ke(t2.b, e2.b, r2), Ke(t2.a, e2.a, r2));
      }, array: function(t2, e2, r2) {
        return t2.map(function(t3, n2) {
          return Ke(t3, e2[n2], r2);
        });
      } }), Ze = 6 / 29 * 3 * (6 / 29), Xe = Math.PI / 180, Je = 180 / Math.PI;
      function He(t2) {
        return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Ze + 4 / 29;
      }
      function Ye(t2) {
        return t2 > 6 / 29 ? t2 * t2 * t2 : Ze * (t2 - 4 / 29);
      }
      function $e(t2) {
        return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
      }
      function We(t2) {
        return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function Qe(t2) {
        var e2 = We(t2.r), r2 = We(t2.g), n2 = We(t2.b), i2 = He((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / 0.95047), a2 = He((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
        return { l: 116 * a2 - 16, a: 500 * (i2 - a2), b: 200 * (a2 - He((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / 1.08883)), alpha: t2.a };
      }
      function tr(t2) {
        var e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
        return e2 = 1 * Ye(e2), r2 = 0.95047 * Ye(r2), n2 = 1.08883 * Ye(n2), new te($e(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), $e(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), $e(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
      }
      function er(t2, e2, r2) {
        var n2 = e2 - t2;
        return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
      }
      var rr = { forward: Qe, reverse: tr, interpolate: function(t2, e2, r2) {
        return { l: Ke(t2.l, e2.l, r2), a: Ke(t2.a, e2.a, r2), b: Ke(t2.b, e2.b, r2), alpha: Ke(t2.alpha, e2.alpha, r2) };
      } }, nr = { forward: function(t2) {
        var e2 = Qe(t2), r2 = e2.l, n2 = e2.a, i2 = e2.b, a2 = Math.atan2(i2, n2) * Je;
        return { h: a2 < 0 ? a2 + 360 : a2, c: Math.sqrt(n2 * n2 + i2 * i2), l: r2, alpha: t2.a };
      }, reverse: function(t2) {
        var e2 = t2.h * Xe, r2 = t2.c;
        return tr({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
      }, interpolate: function(t2, e2, r2) {
        return { h: er(t2.h, e2.h, r2), c: Ke(t2.c, e2.c, r2), l: Ke(t2.l, e2.l, r2), alpha: Ke(t2.alpha, e2.alpha, r2) };
      } }, ir = Object.freeze({ __proto__: null, lab: rr, hcl: nr }), ar = function(t2, e2, r2, n2, i2) {
        this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
        for (var a2 = 0, o2 = i2; a2 < o2.length; a2 += 1) {
          var s2 = o2[a2], u2 = s2[1];
          this.labels.push(s2[0]), this.outputs.push(u2);
        }
      };
      function or(t2, e2, r2, n2) {
        var i2 = n2 - r2, a2 = t2 - r2;
        return 0 === i2 ? 0 : 1 === e2 ? a2 / i2 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i2) - 1);
      }
      ar.interpolationFactor = function(t2, e2, n2, i2) {
        var a2 = 0;
        if ("exponential" === t2.name)
          a2 = or(e2, t2.base, n2, i2);
        else if ("linear" === t2.name)
          a2 = or(e2, 1, n2, i2);
        else if ("cubic-bezier" === t2.name) {
          var o2 = t2.controlPoints;
          a2 = new r(o2[0], o2[1], o2[2], o2[3]).solve(or(e2, 1, n2, i2));
        }
        return a2;
      }, ar.parse = function(t2, e2) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2.slice(3);
        if (!Array.isArray(n2) || 0 === n2.length)
          return e2.error("Expected an interpolation type expression.", 1);
        if ("linear" === n2[0])
          n2 = { name: "linear" };
        else if ("exponential" === n2[0]) {
          var o2 = n2[1];
          if ("number" != typeof o2)
            return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
          n2 = { name: "exponential", base: o2 };
        } else {
          if ("cubic-bezier" !== n2[0])
            return e2.error("Unknown interpolation type " + String(n2[0]), 1, 0);
          var s2 = n2.slice(1);
          if (4 !== s2.length || s2.some(function(t3) {
            return "number" != typeof t3 || t3 < 0 || t3 > 1;
          }))
            return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
          n2 = { name: "cubic-bezier", controlPoints: s2 };
        }
        if (t2.length - 1 < 4)
          return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
        if ((t2.length - 1) % 2 != 0)
          return e2.error("Expected an even number of arguments.");
        if (!(i2 = e2.parse(i2, 2, Ot)))
          return null;
        var u2 = [], l2 = null;
        "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? l2 = jt : e2.expectedType && "value" !== e2.expectedType.kind && (l2 = e2.expectedType);
        for (var p3 = 0; p3 < a2.length; p3 += 2) {
          var c3 = a2[p3], h3 = a2[p3 + 1], f2 = p3 + 3, y3 = p3 + 4;
          if ("number" != typeof c3)
            return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f2);
          if (u2.length && u2[u2.length - 1][0] >= c3)
            return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f2);
          var d2 = e2.parse(h3, y3, l2);
          if (!d2)
            return null;
          l2 = l2 || d2.type, u2.push([c3, d2]);
        }
        return "number" === l2.kind || "color" === l2.kind || "array" === l2.kind && "number" === l2.itemType.kind && "number" == typeof l2.N ? new ar(l2, r2, n2, i2, u2) : e2.error("Type " + Jt(l2) + " is not interpolatable.");
      }, ar.prototype.evaluate = function(t2) {
        var e2 = this.labels, r2 = this.outputs;
        if (1 === e2.length)
          return r2[0].evaluate(t2);
        var n2 = this.input.evaluate(t2);
        if (n2 <= e2[0])
          return r2[0].evaluate(t2);
        var i2 = e2.length;
        if (n2 >= e2[i2 - 1])
          return r2[i2 - 1].evaluate(t2);
        var a2 = qe(e2, n2), o2 = ar.interpolationFactor(this.interpolation, n2, e2[a2], e2[a2 + 1]), s2 = r2[a2].evaluate(t2), u2 = r2[a2 + 1].evaluate(t2);
        return "interpolate" === this.operator ? Ge[this.type.kind.toLowerCase()](s2, u2, o2) : "interpolate-hcl" === this.operator ? nr.reverse(nr.interpolate(nr.forward(s2), nr.forward(u2), o2)) : rr.reverse(rr.interpolate(rr.forward(s2), rr.forward(u2), o2));
      }, ar.prototype.eachChild = function(t2) {
        t2(this.input);
        for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
          t2(r2[e2]);
      }, ar.prototype.outputDefined = function() {
        return this.outputs.every(function(t2) {
          return t2.outputDefined();
        });
      }, ar.prototype.serialize = function() {
        var t2;
        t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        for (var e2 = [this.operator, t2, this.input.serialize()], r2 = 0; r2 < this.labels.length; r2++)
          e2.push(this.labels[r2], this.outputs[r2].serialize());
        return e2;
      };
      var sr = function(t2, e2) {
        this.type = t2, this.args = e2;
      };
      sr.parse = function(t2, e2) {
        if (t2.length < 2)
          return e2.error("Expectected at least one argument.");
        var r2 = null, n2 = e2.expectedType;
        n2 && "value" !== n2.kind && (r2 = n2);
        for (var i2 = [], a2 = 0, o2 = t2.slice(1); a2 < o2.length; a2 += 1) {
          var s2 = e2.parse(o2[a2], 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
          if (!s2)
            return null;
          r2 = r2 || s2.type, i2.push(s2);
        }
        var u2 = n2 && i2.some(function(t3) {
          return Yt(n2, t3.type);
        });
        return new sr(u2 ? Nt : r2, i2);
      }, sr.prototype.evaluate = function(t2) {
        for (var e2, r2 = null, n2 = 0, i2 = 0, a2 = this.args; i2 < a2.length && (n2++, (r2 = a2[i2].evaluate(t2)) && r2 instanceof ie && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null === r2); i2 += 1)
          ;
        return r2;
      }, sr.prototype.eachChild = function(t2) {
        this.args.forEach(t2);
      }, sr.prototype.outputDefined = function() {
        return this.args.every(function(t2) {
          return t2.outputDefined();
        });
      }, sr.prototype.serialize = function() {
        var t2 = ["coalesce"];
        return this.eachChild(function(e2) {
          t2.push(e2.serialize());
        }), t2;
      };
      var ur = function(t2, e2) {
        this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
      };
      ur.prototype.evaluate = function(t2) {
        return this.result.evaluate(t2);
      }, ur.prototype.eachChild = function(t2) {
        for (var e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1)
          t2(r2[e2][1]);
        t2(this.result);
      }, ur.parse = function(t2, e2) {
        if (t2.length < 4)
          return e2.error("Expected at least 3 arguments, but found " + (t2.length - 1) + " instead.");
        for (var r2 = [], n2 = 1; n2 < t2.length - 1; n2 += 2) {
          var i2 = t2[n2];
          if ("string" != typeof i2)
            return e2.error("Expected string, but found " + typeof i2 + " instead.", n2);
          if (/[^a-zA-Z0-9_]/.test(i2))
            return e2.error("Variable names must contain only alphanumeric characters or '_'.", n2);
          var a2 = e2.parse(t2[n2 + 1], n2 + 1);
          if (!a2)
            return null;
          r2.push([i2, a2]);
        }
        var o2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
        return o2 ? new ur(r2, o2) : null;
      }, ur.prototype.outputDefined = function() {
        return this.result.outputDefined();
      }, ur.prototype.serialize = function() {
        for (var t2 = ["let"], e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2];
          t2.push(n2[0], n2[1].serialize());
        }
        return t2.push(this.result.serialize()), t2;
      };
      var lr = function(t2, e2, r2) {
        this.type = t2, this.index = e2, this.input = r2;
      };
      lr.parse = function(t2, e2) {
        if (3 !== t2.length)
          return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
        var r2 = e2.parse(t2[1], 1, Ot), n2 = e2.parse(t2[2], 2, Xt(e2.expectedType || Nt));
        return r2 && n2 ? new lr(n2.type.itemType, r2, n2) : null;
      }, lr.prototype.evaluate = function(t2) {
        var e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
        if (e2 < 0)
          throw new pe("Array index out of bounds: " + e2 + " < 0.");
        if (e2 >= r2.length)
          throw new pe("Array index out of bounds: " + e2 + " > " + (r2.length - 1) + ".");
        if (e2 !== Math.floor(e2))
          throw new pe("Array index must be an integer, but found " + e2 + " instead.");
        return r2[e2];
      }, lr.prototype.eachChild = function(t2) {
        t2(this.index), t2(this.input);
      }, lr.prototype.outputDefined = function() {
        return false;
      }, lr.prototype.serialize = function() {
        return ["at", this.index.serialize(), this.input.serialize()];
      };
      var pr = function(t2, e2) {
        this.type = Ut, this.needle = t2, this.haystack = e2;
      };
      pr.parse = function(t2, e2) {
        if (3 !== t2.length)
          return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
        var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Nt);
        return r2 && n2 ? $t(r2.type, [Ut, Rt, Ot, Lt, Nt]) ? new pr(r2, n2) : e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead") : null;
      }, pr.prototype.evaluate = function(t2) {
        var e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
        if (!r2)
          return false;
        if (!Wt(e2, ["boolean", "string", "number", "null"]))
          throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
        if (!Wt(r2, ["string", "array"]))
          throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
        return r2.indexOf(e2) >= 0;
      }, pr.prototype.eachChild = function(t2) {
        t2(this.needle), t2(this.haystack);
      }, pr.prototype.outputDefined = function() {
        return true;
      }, pr.prototype.serialize = function() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      };
      var cr = function(t2, e2, r2) {
        this.type = Ot, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
      };
      cr.parse = function(t2, e2) {
        if (t2.length <= 2 || t2.length >= 5)
          return e2.error("Expected 3 or 4 arguments, but found " + (t2.length - 1) + " instead.");
        var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Nt);
        if (!r2 || !n2)
          return null;
        if (!$t(r2.type, [Ut, Rt, Ot, Lt, Nt]))
          return e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead");
        if (4 === t2.length) {
          var i2 = e2.parse(t2[3], 3, Ot);
          return i2 ? new cr(r2, n2, i2) : null;
        }
        return new cr(r2, n2);
      }, cr.prototype.evaluate = function(t2) {
        var e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
        if (!Wt(e2, ["boolean", "string", "number", "null"]))
          throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
        if (!Wt(r2, ["string", "array"]))
          throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
        if (this.fromIndex) {
          var n2 = this.fromIndex.evaluate(t2);
          return r2.indexOf(e2, n2);
        }
        return r2.indexOf(e2);
      }, cr.prototype.eachChild = function(t2) {
        t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
      }, cr.prototype.outputDefined = function() {
        return false;
      }, cr.prototype.serialize = function() {
        if (null != this.fromIndex && void 0 !== this.fromIndex) {
          var t2 = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      };
      var hr = function(t2, e2, r2, n2, i2, a2) {
        this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = a2;
      };
      hr.parse = function(t2, e2) {
        if (t2.length < 5)
          return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
        if (t2.length % 2 != 1)
          return e2.error("Expected an even number of arguments.");
        var r2, n2;
        e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
        for (var i2 = {}, a2 = [], o2 = 2; o2 < t2.length - 1; o2 += 2) {
          var s2 = t2[o2], u2 = t2[o2 + 1];
          Array.isArray(s2) || (s2 = [s2]);
          var l2 = e2.concat(o2);
          if (0 === s2.length)
            return l2.error("Expected at least one branch label.");
          for (var p3 = 0, c3 = s2; p3 < c3.length; p3 += 1) {
            var h3 = c3[p3];
            if ("number" != typeof h3 && "string" != typeof h3)
              return l2.error("Branch labels must be numbers or strings.");
            if ("number" == typeof h3 && Math.abs(h3) > Number.MAX_SAFE_INTEGER)
              return l2.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            if ("number" == typeof h3 && Math.floor(h3) !== h3)
              return l2.error("Numeric branch labels must be integer values.");
            if (r2) {
              if (l2.checkSubtype(r2, se(h3)))
                return null;
            } else
              r2 = se(h3);
            if (void 0 !== i2[String(h3)])
              return l2.error("Branch labels must be unique.");
            i2[String(h3)] = a2.length;
          }
          var f2 = e2.parse(u2, o2, n2);
          if (!f2)
            return null;
          n2 = n2 || f2.type, a2.push(f2);
        }
        var y3 = e2.parse(t2[1], 1, Nt);
        if (!y3)
          return null;
        var d2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
        return d2 ? "value" !== y3.type.kind && e2.concat(1).checkSubtype(r2, y3.type) ? null : new hr(r2, n2, y3, i2, a2, d2) : null;
      }, hr.prototype.evaluate = function(t2) {
        var e2 = this.input.evaluate(t2);
        return (se(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
      }, hr.prototype.eachChild = function(t2) {
        t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
      }, hr.prototype.outputDefined = function() {
        return this.outputs.every(function(t2) {
          return t2.outputDefined();
        }) && this.otherwise.outputDefined();
      }, hr.prototype.serialize = function() {
        for (var t2 = this, e2 = ["match", this.input.serialize()], r2 = [], n2 = {}, i2 = 0, a2 = Object.keys(this.cases).sort(); i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          void 0 === (c3 = n2[this.cases[o2]]) ? (n2[this.cases[o2]] = r2.length, r2.push([this.cases[o2], [o2]])) : r2[c3][1].push(o2);
        }
        for (var s2 = function(e3) {
          return "number" === t2.inputType.kind ? Number(e3) : e3;
        }, u2 = 0, l2 = r2; u2 < l2.length; u2 += 1) {
          var p3 = l2[u2], c3 = p3[0], h3 = p3[1];
          e2.push(1 === h3.length ? s2(h3[0]) : h3.map(s2)), e2.push(this.outputs[outputIndex$1].serialize());
        }
        return e2.push(this.otherwise.serialize()), e2;
      };
      var fr = function(t2, e2, r2) {
        this.type = t2, this.branches = e2, this.otherwise = r2;
      };
      fr.parse = function(t2, e2) {
        if (t2.length < 4)
          return e2.error("Expected at least 3 arguments, but found only " + (t2.length - 1) + ".");
        if (t2.length % 2 != 0)
          return e2.error("Expected an odd number of arguments.");
        var r2;
        e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
        for (var n2 = [], i2 = 1; i2 < t2.length - 1; i2 += 2) {
          var a2 = e2.parse(t2[i2], i2, Ut);
          if (!a2)
            return null;
          var o2 = e2.parse(t2[i2 + 1], i2 + 1, r2);
          if (!o2)
            return null;
          n2.push([a2, o2]), r2 = r2 || o2.type;
        }
        var s2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
        return s2 ? new fr(r2, n2, s2) : null;
      }, fr.prototype.evaluate = function(t2) {
        for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2], i2 = n2[1];
          if (n2[0].evaluate(t2))
            return i2.evaluate(t2);
        }
        return this.otherwise.evaluate(t2);
      }, fr.prototype.eachChild = function(t2) {
        for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
          var n2 = r2[e2], i2 = n2[1];
          t2(n2[0]), t2(i2);
        }
        t2(this.otherwise);
      }, fr.prototype.outputDefined = function() {
        return this.branches.every(function(t2) {
          return t2[1].outputDefined();
        }) && this.otherwise.outputDefined();
      }, fr.prototype.serialize = function() {
        var t2 = ["case"];
        return this.eachChild(function(e2) {
          t2.push(e2.serialize());
        }), t2;
      };
      var yr = function(t2, e2, r2, n2) {
        this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
      };
      function dr(t2, e2) {
        return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
      }
      function mr(t2, e2, r2, n2) {
        return 0 === n2.compare(e2, r2);
      }
      function vr(t2, e2, r2) {
        var n2 = "==" !== t2 && "!=" !== t2;
        return function() {
          function i2(t3, e3, r3) {
            this.type = Ut, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
          }
          return i2.parse = function(t3, e3) {
            if (3 !== t3.length && 4 !== t3.length)
              return e3.error("Expected two or three arguments.");
            var r3 = t3[0], a2 = e3.parse(t3[1], 1, Nt);
            if (!a2)
              return null;
            if (!dr(r3, a2.type))
              return e3.concat(1).error('"' + r3 + `" comparisons are not supported for type '` + Jt(a2.type) + "'.");
            var o2 = e3.parse(t3[2], 2, Nt);
            if (!o2)
              return null;
            if (!dr(r3, o2.type))
              return e3.concat(2).error('"' + r3 + `" comparisons are not supported for type '` + Jt(o2.type) + "'.");
            if (a2.type.kind !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
              return e3.error("Cannot compare types '" + Jt(a2.type) + "' and '" + Jt(o2.type) + "'.");
            n2 && ("value" === a2.type.kind && "value" !== o2.type.kind ? a2 = new he(o2.type, [a2]) : "value" !== a2.type.kind && "value" === o2.type.kind && (o2 = new he(a2.type, [o2])));
            var s2 = null;
            if (4 === t3.length) {
              if ("string" !== a2.type.kind && "string" !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                return e3.error("Cannot use collator to compare non-string types.");
              if (!(s2 = e3.parse(t3[3], 3, Kt)))
                return null;
            }
            return new i2(a2, o2, s2);
          }, i2.prototype.evaluate = function(i3) {
            var a2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              var s2 = se(a2), u2 = se(o2);
              if (s2.kind !== u2.kind || "string" !== s2.kind && "number" !== s2.kind)
                throw new pe('Expected arguments for "' + t2 + '" to be (string, string) or (number, number), but found (' + s2.kind + ", " + u2.kind + ") instead.");
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              var l2 = se(a2), p3 = se(o2);
              if ("string" !== l2.kind || "string" !== p3.kind)
                return e2(i3, a2, o2);
            }
            return this.collator ? r2(i3, a2, o2, this.collator.evaluate(i3)) : e2(i3, a2, o2);
          }, i2.prototype.eachChild = function(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }, i2.prototype.outputDefined = function() {
            return true;
          }, i2.prototype.serialize = function() {
            var e3 = [t2];
            return this.eachChild(function(t3) {
              e3.push(t3.serialize());
            }), e3;
          }, i2;
        }();
      }
      yr.parse = function(t2, e2) {
        if (t2.length <= 2 || t2.length >= 5)
          return e2.error("Expected 3 or 4 arguments, but found " + (t2.length - 1) + " instead.");
        var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Ot);
        if (!r2 || !n2)
          return null;
        if (!$t(r2.type, [Xt(Nt), Rt, Nt]))
          return e2.error("Expected first argument to be of type array or string, but found " + Jt(r2.type) + " instead");
        if (4 === t2.length) {
          var i2 = e2.parse(t2[3], 3, Ot);
          return i2 ? new yr(r2.type, r2, n2, i2) : null;
        }
        return new yr(r2.type, r2, n2);
      }, yr.prototype.evaluate = function(t2) {
        var e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
        if (!Wt(e2, ["string", "array"]))
          throw new pe("Expected first argument to be of type array or string, but found " + Jt(se(e2)) + " instead.");
        if (this.endIndex) {
          var n2 = this.endIndex.evaluate(t2);
          return e2.slice(r2, n2);
        }
        return e2.slice(r2);
      }, yr.prototype.eachChild = function(t2) {
        t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
      }, yr.prototype.outputDefined = function() {
        return false;
      }, yr.prototype.serialize = function() {
        if (null != this.endIndex && void 0 !== this.endIndex) {
          var t2 = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      };
      var gr = vr("==", function(t2, e2, r2) {
        return e2 === r2;
      }, mr), xr = vr("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !mr(0, e2, r2, n2);
      }), br = vr("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), wr = vr(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), _r = vr("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), Ar = vr(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      }), Sr = function(t2, e2, r2, n2, i2) {
        this.type = Rt, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
      };
      Sr.parse = function(t2, e2) {
        if (3 !== t2.length)
          return e2.error("Expected two arguments.");
        var r2 = e2.parse(t2[1], 1, Ot);
        if (!r2)
          return null;
        var n2 = t2[2];
        if ("object" != typeof n2 || Array.isArray(n2))
          return e2.error("NumberFormat options argument must be an object.");
        var i2 = null;
        if (n2.locale && !(i2 = e2.parse(n2.locale, 1, Rt)))
          return null;
        var a2 = null;
        if (n2.currency && !(a2 = e2.parse(n2.currency, 1, Rt)))
          return null;
        var o2 = null;
        if (n2["min-fraction-digits"] && !(o2 = e2.parse(n2["min-fraction-digits"], 1, Ot)))
          return null;
        var s2 = null;
        return n2["max-fraction-digits"] && !(s2 = e2.parse(n2["max-fraction-digits"], 1, Ot)) ? null : new Sr(r2, i2, a2, o2, s2);
      }, Sr.prototype.evaluate = function(t2) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
      }, Sr.prototype.eachChild = function(t2) {
        t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
      }, Sr.prototype.outputDefined = function() {
        return false;
      }, Sr.prototype.serialize = function() {
        var t2 = {};
        return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
      };
      var kr = function(t2) {
        this.type = Ot, this.input = t2;
      };
      kr.parse = function(t2, e2) {
        if (2 !== t2.length)
          return e2.error("Expected 1 argument, but found " + (t2.length - 1) + " instead.");
        var r2 = e2.parse(t2[1], 1);
        return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error("Expected argument of type string or array, but found " + Jt(r2.type) + " instead.") : new kr(r2) : null;
      }, kr.prototype.evaluate = function(t2) {
        var e2 = this.input.evaluate(t2);
        if ("string" == typeof e2)
          return e2.length;
        if (Array.isArray(e2))
          return e2.length;
        throw new pe("Expected value to be of type string or array, but found " + Jt(se(e2)) + " instead.");
      }, kr.prototype.eachChild = function(t2) {
        t2(this.input);
      }, kr.prototype.outputDefined = function() {
        return false;
      }, kr.prototype.serialize = function() {
        var t2 = ["length"];
        return this.eachChild(function(e2) {
          t2.push(e2.serialize());
        }), t2;
      };
      var Ir = { "==": gr, "!=": xr, ">": wr, "<": br, ">=": Ar, "<=": _r, array: he, at: lr, boolean: he, case: fr, coalesce: sr, collator: be, format: fe, image: ye, in: pr, "index-of": cr, interpolate: ar, "interpolate-hcl": ar, "interpolate-lab": ar, length: kr, let: ur, literal: le, match: hr, number: he, "number-format": Sr, object: he, slice: yr, step: Ne, string: he, "to-boolean": me, "to-color": me, "to-number": me, "to-string": me, var: Ue, within: De };
      function zr(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3];
        r2 = r2.evaluate(t2), n2 = n2.evaluate(t2), i2 = i2.evaluate(t2);
        var o2 = a2 ? a2.evaluate(t2) : 1, s2 = ae(r2, n2, i2, o2);
        if (s2)
          throw new pe(s2);
        return new te(r2 / 255 * o2, n2 / 255 * o2, i2 / 255 * o2, o2);
      }
      function Cr(t2, e2) {
        return t2 in e2;
      }
      function Er(t2, e2) {
        var r2 = e2[t2];
        return void 0 === r2 ? null : r2;
      }
      function Pr(t2) {
        return { type: t2 };
      }
      function Mr(t2) {
        return { result: "success", value: t2 };
      }
      function Br(t2) {
        return { result: "error", value: t2 };
      }
      function Tr(t2) {
        return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
      }
      function Vr(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function Fr(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function Dr(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
      }
      function Lr(t2) {
        return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
      }
      function Or(t2) {
        return t2;
      }
      function Rr(t2, e2, r2) {
        return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
      }
      function Ur(t2, e2, r2, n2, i2) {
        return Rr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
      }
      function jr(t2, e2, r2) {
        if ("number" !== Dr(r2))
          return Rr(t2.default, e2.default);
        var n2 = t2.stops.length;
        if (1 === n2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        var i2 = qe(t2.stops.map(function(t3) {
          return t3[0];
        }), r2);
        return t2.stops[i2][1];
      }
      function qr(t2, e2, r2) {
        var n2 = void 0 !== t2.base ? t2.base : 1;
        if ("number" !== Dr(r2))
          return Rr(t2.default, e2.default);
        var i2 = t2.stops.length;
        if (1 === i2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        var a2 = qe(t2.stops.map(function(t3) {
          return t3[0];
        }), r2), o2 = function(t3, e3, r3, n3) {
          var i3 = n3 - r3, a3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? a3 / i3 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[a2][0], t2.stops[a2 + 1][0]), s2 = t2.stops[a2][1], u2 = t2.stops[a2 + 1][1], l2 = Ge[e2.type] || Or;
        if (t2.colorSpace && "rgb" !== t2.colorSpace) {
          var p3 = ir[t2.colorSpace];
          l2 = function(t3, e3) {
            return p3.reverse(p3.interpolate(p3.forward(t3), p3.forward(e3), o2));
          };
        }
        return "function" == typeof s2.evaluate ? { evaluate: function() {
          for (var t3 = [], e3 = arguments.length; e3--; )
            t3[e3] = arguments[e3];
          var r3 = s2.evaluate.apply(void 0, t3), n3 = u2.evaluate.apply(void 0, t3);
          if (void 0 !== r3 && void 0 !== n3)
            return l2(r3, n3, o2);
        } } : l2(s2, u2, o2);
      }
      function Nr(t2, e2, r2) {
        return "color" === e2.type ? r2 = te.parse(r2) : "formatted" === e2.type ? r2 = ne.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = ie.fromString(r2.toString()) : Dr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Rr(r2, t2.default, e2.default);
      }
      xe.register(Ir, { error: [{ kind: "error" }, [Rt], function(t2, e2) {
        throw new pe(e2[0].evaluate(t2));
      }], typeof: [Rt, [Nt], function(t2, e2) {
        return Jt(se(e2[0].evaluate(t2)));
      }], "to-rgba": [Xt(Ot, 4), [jt], function(t2, e2) {
        return e2[0].evaluate(t2).toArray();
      }], rgb: [jt, [Ot, Ot, Ot], zr], rgba: [jt, [Ot, Ot, Ot, Ot], zr], has: { type: Ut, overloads: [[[Rt], function(t2, e2) {
        return Cr(e2[0].evaluate(t2), t2.properties());
      }], [[Rt, qt], function(t2, e2) {
        var r2 = e2[1];
        return Cr(e2[0].evaluate(t2), r2.evaluate(t2));
      }]] }, get: { type: Nt, overloads: [[[Rt], function(t2, e2) {
        return Er(e2[0].evaluate(t2), t2.properties());
      }], [[Rt, qt], function(t2, e2) {
        var r2 = e2[1];
        return Er(e2[0].evaluate(t2), r2.evaluate(t2));
      }]] }, "feature-state": [Nt, [Rt], function(t2, e2) {
        return Er(e2[0].evaluate(t2), t2.featureState || {});
      }], properties: [qt, [], function(t2) {
        return t2.properties();
      }], "geometry-type": [Rt, [], function(t2) {
        return t2.geometryType();
      }], id: [Nt, [], function(t2) {
        return t2.id();
      }], zoom: [Ot, [], function(t2) {
        return t2.globals.zoom;
      }], "heatmap-density": [Ot, [], function(t2) {
        return t2.globals.heatmapDensity || 0;
      }], "line-progress": [Ot, [], function(t2) {
        return t2.globals.lineProgress || 0;
      }], accumulated: [Nt, [], function(t2) {
        return void 0 === t2.globals.accumulated ? null : t2.globals.accumulated;
      }], "+": [Ot, Pr(Ot), function(t2, e2) {
        for (var r2 = 0, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
          r2 += i2[n2].evaluate(t2);
        return r2;
      }], "*": [Ot, Pr(Ot), function(t2, e2) {
        for (var r2 = 1, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
          r2 *= i2[n2].evaluate(t2);
        return r2;
      }], "-": { type: Ot, overloads: [[[Ot, Ot], function(t2, e2) {
        var r2 = e2[1];
        return e2[0].evaluate(t2) - r2.evaluate(t2);
      }], [[Ot], function(t2, e2) {
        return -e2[0].evaluate(t2);
      }]] }, "/": [Ot, [Ot, Ot], function(t2, e2) {
        var r2 = e2[1];
        return e2[0].evaluate(t2) / r2.evaluate(t2);
      }], "%": [Ot, [Ot, Ot], function(t2, e2) {
        var r2 = e2[1];
        return e2[0].evaluate(t2) % r2.evaluate(t2);
      }], ln2: [Ot, [], function() {
        return Math.LN2;
      }], pi: [Ot, [], function() {
        return Math.PI;
      }], e: [Ot, [], function() {
        return Math.E;
      }], "^": [Ot, [Ot, Ot], function(t2, e2) {
        var r2 = e2[1];
        return Math.pow(e2[0].evaluate(t2), r2.evaluate(t2));
      }], sqrt: [Ot, [Ot], function(t2, e2) {
        return Math.sqrt(e2[0].evaluate(t2));
      }], log10: [Ot, [Ot], function(t2, e2) {
        return Math.log(e2[0].evaluate(t2)) / Math.LN10;
      }], ln: [Ot, [Ot], function(t2, e2) {
        return Math.log(e2[0].evaluate(t2));
      }], log2: [Ot, [Ot], function(t2, e2) {
        return Math.log(e2[0].evaluate(t2)) / Math.LN2;
      }], sin: [Ot, [Ot], function(t2, e2) {
        return Math.sin(e2[0].evaluate(t2));
      }], cos: [Ot, [Ot], function(t2, e2) {
        return Math.cos(e2[0].evaluate(t2));
      }], tan: [Ot, [Ot], function(t2, e2) {
        return Math.tan(e2[0].evaluate(t2));
      }], asin: [Ot, [Ot], function(t2, e2) {
        return Math.asin(e2[0].evaluate(t2));
      }], acos: [Ot, [Ot], function(t2, e2) {
        return Math.acos(e2[0].evaluate(t2));
      }], atan: [Ot, [Ot], function(t2, e2) {
        return Math.atan(e2[0].evaluate(t2));
      }], min: [Ot, Pr(Ot), function(t2, e2) {
        return Math.min.apply(Math, e2.map(function(e3) {
          return e3.evaluate(t2);
        }));
      }], max: [Ot, Pr(Ot), function(t2, e2) {
        return Math.max.apply(Math, e2.map(function(e3) {
          return e3.evaluate(t2);
        }));
      }], abs: [Ot, [Ot], function(t2, e2) {
        return Math.abs(e2[0].evaluate(t2));
      }], round: [Ot, [Ot], function(t2, e2) {
        var r2 = e2[0].evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [Ot, [Ot], function(t2, e2) {
        return Math.floor(e2[0].evaluate(t2));
      }], ceil: [Ot, [Ot], function(t2, e2) {
        return Math.ceil(e2[0].evaluate(t2));
      }], "filter-==": [Ut, [Rt, Nt], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1];
        return t2.properties()[r2.value] === n2.value;
      }], "filter-id-==": [Ut, [Nt], function(t2, e2) {
        var r2 = e2[0];
        return t2.id() === r2.value;
      }], "filter-type-==": [Ut, [Rt], function(t2, e2) {
        var r2 = e2[0];
        return t2.geometryType() === r2.value;
      }], "filter-<": [Ut, [Rt, Nt], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
        return typeof i2 == typeof a2 && i2 < a2;
      }], "filter-id-<": [Ut, [Nt], function(t2, e2) {
        var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter->": [Ut, [Rt, Nt], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
        return typeof i2 == typeof a2 && i2 > a2;
      }], "filter-id->": [Ut, [Nt], function(t2, e2) {
        var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-<=": [Ut, [Rt, Nt], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
        return typeof i2 == typeof a2 && i2 <= a2;
      }], "filter-id-<=": [Ut, [Nt], function(t2, e2) {
        var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter->=": [Ut, [Rt, Nt], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
        return typeof i2 == typeof a2 && i2 >= a2;
      }], "filter-id->=": [Ut, [Nt], function(t2, e2) {
        var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-has": [Ut, [Nt], function(t2, e2) {
        return e2[0].value in t2.properties();
      }], "filter-has-id": [Ut, [], function(t2) {
        return null !== t2.id() && void 0 !== t2.id();
      }], "filter-type-in": [Ut, [Xt(Rt)], function(t2, e2) {
        return e2[0].value.indexOf(t2.geometryType()) >= 0;
      }], "filter-id-in": [Ut, [Xt(Nt)], function(t2, e2) {
        return e2[0].value.indexOf(t2.id()) >= 0;
      }], "filter-in-small": [Ut, [Rt, Xt(Nt)], function(t2, e2) {
        var r2 = e2[0];
        return e2[1].value.indexOf(t2.properties()[r2.value]) >= 0;
      }], "filter-in-large": [Ut, [Rt, Xt(Nt)], function(t2, e2) {
        var r2 = e2[0], n2 = e2[1];
        return function(t3, e3, r3, n3) {
          for (; r3 <= n3; ) {
            var i2 = r3 + n3 >> 1;
            if (e3[i2] === t3)
              return true;
            e3[i2] > t3 ? n3 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[r2.value], n2.value, 0, n2.value.length - 1);
      }], all: { type: Ut, overloads: [[[Ut, Ut], function(t2, e2) {
        var r2 = e2[1];
        return e2[0].evaluate(t2) && r2.evaluate(t2);
      }], [Pr(Ut), function(t2, e2) {
        for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
          if (!n2[r2].evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: Ut, overloads: [[[Ut, Ut], function(t2, e2) {
        var r2 = e2[1];
        return e2[0].evaluate(t2) || r2.evaluate(t2);
      }], [Pr(Ut), function(t2, e2) {
        for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
          if (n2[r2].evaluate(t2))
            return true;
        return false;
      }]] }, "!": [Ut, [Ut], function(t2, e2) {
        return !e2[0].evaluate(t2);
      }], "is-supported-script": [Ut, [Rt], function(t2, e2) {
        var r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e2[0].evaluate(t2));
      }], upcase: [Rt, [Rt], function(t2, e2) {
        return e2[0].evaluate(t2).toUpperCase();
      }], downcase: [Rt, [Rt], function(t2, e2) {
        return e2[0].evaluate(t2).toLowerCase();
      }], concat: [Rt, Pr(Nt), function(t2, e2) {
        return e2.map(function(e3) {
          return ue(e3.evaluate(t2));
        }).join("");
      }], "resolved-locale": [Rt, [Kt], function(t2, e2) {
        return e2[0].evaluate(t2).resolvedLocale();
      }] });
      var Kr = function(t2, e2) {
        this.expression = t2, this._warningHistory = {}, this._evaluator = new ge(), this._defaultValue = e2 ? function(t3) {
          return "color" === t3.type && Lr(t3.default) ? new te(0, 0, 0, 0) : "color" === t3.type ? te.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
        }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
      };
      function Gr(t2) {
        return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Ir;
      }
      function Zr(t2, e2) {
        var r2 = new je(Ir, [], e2 ? function(t3) {
          var e3 = { color: jt, string: Rt, number: Ot, enum: Rt, boolean: Ut, formatted: Gt, resolvedImage: Zt };
          return "array" === t3.type ? Xt(e3[t3.value] || Nt, t3.length) : e3[t3.type];
        }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
        return n2 ? Mr(new Kr(n2, e2)) : Br(r2.errors);
      }
      Kr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
        return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
      }, Kr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
        this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2 || null;
        try {
          var o2 = this.expression.evaluate(this._evaluator);
          if (null == o2 || "number" == typeof o2 && o2 != o2)
            return this._defaultValue;
          if (this._enumValues && !(o2 in this._enumValues))
            throw new pe("Expected value to be one of " + Object.keys(this._enumValues).map(function(t3) {
              return JSON.stringify(t3);
            }).join(", ") + ", but found " + JSON.stringify(o2) + " instead.");
          return o2;
        } catch (t3) {
          return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
        }
      };
      var Xr = function(t2, e2) {
        this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !Oe(e2.expression);
      };
      Xr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
        return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
      }, Xr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
        return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
      };
      var Jr = function(t2, e2, r2, n2) {
        this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Oe(e2.expression), this.interpolationType = n2;
      };
      function Hr(t2, e2) {
        if ("error" === (t2 = Zr(t2, e2)).result)
          return t2;
        var r2 = t2.value.expression, n2 = Le(r2);
        if (!n2 && !Tr(e2))
          return Br([new Ft("", "data expressions not supported")]);
        var i2 = Re(r2, ["zoom"]);
        if (!i2 && !Vr(e2))
          return Br([new Ft("", "zoom expressions not supported")]);
        var a2 = function t3(e3) {
          var r3 = null;
          if (e3 instanceof ur)
            r3 = t3(e3.result);
          else if (e3 instanceof sr)
            for (var n3 = 0, i3 = e3.args; n3 < i3.length && !(r3 = t3(i3[n3])); n3 += 1)
              ;
          else
            (e3 instanceof Ne || e3 instanceof ar) && e3.input instanceof xe && "zoom" === e3.input.name && (r3 = e3);
          return r3 instanceof Ft || e3.eachChild(function(e4) {
            var n4 = t3(e4);
            n4 instanceof Ft ? r3 = n4 : !r3 && n4 ? r3 = new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r3 && n4 && r3 !== n4 && (r3 = new Ft("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), r3;
        }(r2);
        return a2 || i2 ? a2 instanceof Ft ? Br([a2]) : a2 instanceof ar && !Fr(e2) ? Br([new Ft("", '"interpolate" expressions cannot be used with this property')]) : Mr(a2 ? new Jr(n2 ? "camera" : "composite", t2.value, a2.labels, a2 instanceof ar ? a2.interpolation : void 0) : new Xr(n2 ? "constant" : "source", t2.value)) : Br([new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      Jr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
        return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
      }, Jr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
        return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
      }, Jr.prototype.interpolationFactor = function(t2, e2, r2) {
        return this.interpolationType ? ar.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
      };
      var Yr = function(t2, e2) {
        this._parameters = t2, this._specification = e2, Bt(this, function t3(e3, r2) {
          var n2, i2, a2, o2 = "color" === r2.type, s2 = e3.stops && "object" == typeof e3.stops[0][0], u2 = s2 || !(s2 || void 0 !== e3.property), l2 = e3.type || (Fr(r2) ? "exponential" : "interval");
          if (o2 && ((e3 = Bt({}, e3)).stops && (e3.stops = e3.stops.map(function(t4) {
            return [t4[0], te.parse(t4[1])];
          })), e3.default = te.parse(e3.default ? e3.default : r2.default)), e3.colorSpace && "rgb" !== e3.colorSpace && !ir[e3.colorSpace])
            throw new Error("Unknown color space: " + e3.colorSpace);
          if ("exponential" === l2)
            n2 = qr;
          else if ("interval" === l2)
            n2 = jr;
          else if ("categorical" === l2) {
            n2 = Ur, i2 = /* @__PURE__ */ Object.create(null);
            for (var p3 = 0, c3 = e3.stops; p3 < c3.length; p3 += 1) {
              var h3 = c3[p3];
              i2[h3[0]] = h3[1];
            }
            a2 = typeof e3.stops[0][0];
          } else {
            if ("identity" !== l2)
              throw new Error('Unknown function type "' + l2 + '"');
            n2 = Nr;
          }
          if (s2) {
            for (var f2 = {}, y3 = [], d2 = 0; d2 < e3.stops.length; d2++) {
              var m2 = e3.stops[d2], v3 = m2[0].zoom;
              void 0 === f2[v3] && (f2[v3] = { zoom: v3, type: e3.type, property: e3.property, default: e3.default, stops: [] }, y3.push(v3)), f2[v3].stops.push([m2[0].value, m2[1]]);
            }
            for (var g2 = [], x2 = 0, b2 = y3; x2 < b2.length; x2 += 1) {
              var w2 = b2[x2];
              g2.push([f2[w2].zoom, t3(f2[w2], r2)]);
            }
            var _24 = { name: "linear" };
            return { kind: "composite", interpolationType: _24, interpolationFactor: ar.interpolationFactor.bind(void 0, _24), zoomStops: g2.map(function(t4) {
              return t4[0];
            }), evaluate: function(t4, n3) {
              var i3 = t4.zoom;
              return qr({ stops: g2, base: e3.base }, r2, i3).evaluate(i3, n3);
            } };
          }
          if (u2) {
            var A3 = "exponential" === l2 ? { name: "exponential", base: void 0 !== e3.base ? e3.base : 1 } : null;
            return { kind: "camera", interpolationType: A3, interpolationFactor: ar.interpolationFactor.bind(void 0, A3), zoomStops: e3.stops.map(function(t4) {
              return t4[0];
            }), evaluate: function(t4) {
              return n2(e3, r2, t4.zoom, i2, a2);
            } };
          }
          return { kind: "source", evaluate: function(t4, o3) {
            var s3 = o3 && o3.properties ? o3.properties[e3.property] : void 0;
            return void 0 === s3 ? Rr(e3.default, r2.default) : n2(e3, r2, s3, i2, a2);
          } };
        }(this._parameters, this._specification));
      };
      function $r(t2) {
        var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, a2 = t2.style, o2 = t2.styleSpec, s2 = [], u2 = Dr(r2);
        if ("object" !== u2)
          return [new Pt(e2, r2, "object expected, " + u2 + " found")];
        for (var l2 in r2) {
          var p3 = l2.split(".")[0], c3 = n2[p3] || n2["*"], h3 = void 0;
          if (i2[p3])
            h3 = i2[p3];
          else if (n2[p3])
            h3 = An;
          else if (i2["*"])
            h3 = i2["*"];
          else {
            if (!n2["*"]) {
              s2.push(new Pt(e2, r2[l2], 'unknown property "' + l2 + '"'));
              continue;
            }
            h3 = An;
          }
          s2 = s2.concat(h3({ key: (e2 ? e2 + "." : e2) + l2, value: r2[l2], valueSpec: c3, style: a2, styleSpec: o2, object: r2, objectKey: l2 }, r2));
        }
        for (var f2 in n2)
          i2[f2] || n2[f2].required && void 0 === n2[f2].default && void 0 === r2[f2] && s2.push(new Pt(e2, r2, 'missing required property "' + f2 + '"'));
        return s2;
      }
      function Wr(t2) {
        var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.key, o2 = t2.arrayElementValidator || An;
        if ("array" !== Dr(e2))
          return [new Pt(a2, e2, "array expected, " + Dr(e2) + " found")];
        if (r2.length && e2.length !== r2.length)
          return [new Pt(a2, e2, "array length " + r2.length + " expected, length " + e2.length + " found")];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [new Pt(a2, e2, "array length at least " + r2["min-length"] + " expected, length " + e2.length + " found")];
        var s2 = { type: r2.value, values: r2.values };
        i2.$version < 7 && (s2.function = r2.function), "object" === Dr(r2.value) && (s2 = r2.value);
        for (var u2 = [], l2 = 0; l2 < e2.length; l2++)
          u2 = u2.concat(o2({ array: e2, arrayIndex: l2, value: e2[l2], valueSpec: s2, style: n2, styleSpec: i2, key: a2 + "[" + l2 + "]" }));
        return u2;
      }
      function Qr(t2) {
        var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = Dr(r2);
        return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Pt(e2, r2, "number expected, " + i2 + " found")] : "minimum" in n2 && r2 < n2.minimum ? [new Pt(e2, r2, r2 + " is less than the minimum value " + n2.minimum)] : "maximum" in n2 && r2 > n2.maximum ? [new Pt(e2, r2, r2 + " is greater than the maximum value " + n2.maximum)] : [];
      }
      function tn(t2) {
        var e2, r2, n2, i2 = t2.valueSpec, a2 = Tt(t2.value.type), o2 = {}, s2 = "categorical" !== a2 && void 0 === t2.value.property, u2 = !s2, l2 = "array" === Dr(t2.value.stops) && "array" === Dr(t2.value.stops[0]) && "object" === Dr(t2.value.stops[0][0]), p3 = $r({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if ("identity" === a2)
            return [new Pt(t3.key, t3.value, 'identity function may not have a "stops" property')];
          var e3 = [], r3 = t3.value;
          return e3 = e3.concat(Wr({ key: t3.key, value: r3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: c3 })), "array" === Dr(r3) && 0 === r3.length && e3.push(new Pt(t3.key, r3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return An({ key: t3.key, value: t3.value, valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return "identity" === a2 && s2 && p3.push(new Pt(t2.key, t2.value, 'missing required property "property"')), "identity" === a2 || t2.value.stops || p3.push(new Pt(t2.key, t2.value, 'missing required property "stops"')), "exponential" === a2 && t2.valueSpec.expression && !Fr(t2.valueSpec) && p3.push(new Pt(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (u2 && !Tr(t2.valueSpec) ? p3.push(new Pt(t2.key, t2.value, "property functions not supported")) : s2 && !Vr(t2.valueSpec) && p3.push(new Pt(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== a2 && !l2 || void 0 !== t2.value.property || p3.push(new Pt(t2.key, t2.value, '"property" property is required')), p3;
        function c3(t3) {
          var e3 = [], a3 = t3.value, s3 = t3.key;
          if ("array" !== Dr(a3))
            return [new Pt(s3, a3, "array expected, " + Dr(a3) + " found")];
          if (2 !== a3.length)
            return [new Pt(s3, a3, "array length 2 expected, length " + a3.length + " found")];
          if (l2) {
            if ("object" !== Dr(a3[0]))
              return [new Pt(s3, a3, "object expected, " + Dr(a3[0]) + " found")];
            if (void 0 === a3[0].zoom)
              return [new Pt(s3, a3, "object stop key must have zoom")];
            if (void 0 === a3[0].value)
              return [new Pt(s3, a3, "object stop key must have value")];
            if (n2 && n2 > Tt(a3[0].zoom))
              return [new Pt(s3, a3[0].zoom, "stop zoom values must appear in ascending order")];
            Tt(a3[0].zoom) !== n2 && (n2 = Tt(a3[0].zoom), r2 = void 0, o2 = {}), e3 = e3.concat($r({ key: s3 + "[0]", value: a3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Qr, value: h3 } }));
          } else
            e3 = e3.concat(h3({ key: s3 + "[0]", value: a3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, a3));
          return Gr(Vt(a3[1])) ? e3.concat([new Pt(s3 + "[1]", a3[1], "expressions are not allowed in function stops.")]) : e3.concat(An({ key: s3 + "[1]", value: a3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function h3(t3, n3) {
          var s3 = Dr(t3.value), u3 = Tt(t3.value), l3 = null !== t3.value ? t3.value : n3;
          if (e2) {
            if (s3 !== e2)
              return [new Pt(t3.key, l3, s3 + " stop domain type must match previous stop domain type " + e2)];
          } else
            e2 = s3;
          if ("number" !== s3 && "string" !== s3 && "boolean" !== s3)
            return [new Pt(t3.key, l3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== s3 && "categorical" !== a2) {
            var p4 = "number expected, " + s3 + " found";
            return Tr(i2) && void 0 === a2 && (p4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt(t3.key, l3, p4)];
          }
          return "categorical" !== a2 || "number" !== s3 || isFinite(u3) && Math.floor(u3) === u3 ? "categorical" !== a2 && "number" === s3 && void 0 !== r2 && u3 < r2 ? [new Pt(t3.key, l3, "stop domain values must appear in ascending order")] : (r2 = u3, "categorical" === a2 && u3 in o2 ? [new Pt(t3.key, l3, "stop domain values must be unique")] : (o2[u3] = true, [])) : [new Pt(t3.key, l3, "integer expected, found " + u3)];
        }
      }
      function en(t2) {
        var e2 = ("property" === t2.expressionContext ? Hr : Zr)(Vt(t2.value), t2.valueSpec);
        if ("error" === e2.result)
          return e2.value.map(function(e3) {
            return new Pt("" + t2.key + e3.key, t2.value, e3.message);
          });
        var r2 = e2.value.expression || e2.value._styleExpression.expression;
        if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
          return [new Pt(t2.key, t2.value, 'Invalid data expression for "' + t2.propertyKey + '". Output values must be contained as literals within the expression.')];
        if ("property" === t2.expressionContext && "layout" === t2.propertyType && !Oe(r2))
          return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t2.expressionContext && !Oe(r2))
          return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
        if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
          if (!Re(r2, ["zoom", "feature-state"]))
            return [new Pt(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t2.expressionContext && !Le(r2))
            return [new Pt(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function rn(t2) {
        var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
        return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Tt(r2)) && i2.push(new Pt(e2, r2, "expected one of [" + n2.values.join(", ") + "], " + JSON.stringify(r2) + " found")) : -1 === Object.keys(n2.values).indexOf(Tt(r2)) && i2.push(new Pt(e2, r2, "expected one of [" + Object.keys(n2.values).join(", ") + "], " + JSON.stringify(r2) + " found")), i2;
      }
      function nn(t2) {
        if (true === t2 || false === t2)
          return true;
        if (!Array.isArray(t2) || 0 === t2.length)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
          case "in":
            return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (var e2 = 0, r2 = t2.slice(1); e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              if (!nn(n2) && "boolean" != typeof n2)
                return false;
            }
            return true;
          default:
            return true;
        }
      }
      Yr.deserialize = function(t2) {
        return new Yr(t2._parameters, t2._specification);
      }, Yr.serialize = function(t2) {
        return { _parameters: t2._parameters, _specification: t2._specification };
      };
      var an = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
      function on2(t2) {
        if (null == t2)
          return { filter: function() {
            return true;
          }, needGeometry: false };
        nn(t2) || (t2 = un(t2));
        var e2 = Zr(t2, an);
        if ("error" === e2.result)
          throw new Error(e2.value.map(function(t3) {
            return t3.key + ": " + t3.message;
          }).join(", "));
        return { filter: function(t3, r2, n2) {
          return e2.value.evaluate(t3, r2, {}, n2);
        }, needGeometry: function t3(e3) {
          if (!Array.isArray(e3))
            return false;
          if ("within" === e3[0])
            return true;
          for (var r2 = 1; r2 < e3.length; r2++)
            if (t3(e3[r2]))
              return true;
          return false;
        }(t2) };
      }
      function sn(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function un(t2) {
        if (!t2)
          return true;
        var e2, r2 = t2[0];
        return t2.length <= 1 ? "any" !== r2 : "==" === r2 ? ln(t2[1], t2[2], "==") : "!=" === r2 ? hn(ln(t2[1], t2[2], "==")) : "<" === r2 || ">" === r2 || "<=" === r2 || ">=" === r2 ? ln(t2[1], t2[2], r2) : "any" === r2 ? (e2 = t2.slice(1), ["any"].concat(e2.map(un))) : "all" === r2 ? ["all"].concat(t2.slice(1).map(un)) : "none" === r2 ? ["all"].concat(t2.slice(1).map(un).map(hn)) : "in" === r2 ? pn(t2[1], t2.slice(2)) : "!in" === r2 ? hn(pn(t2[1], t2.slice(2))) : "has" === r2 ? cn(t2[1]) : "!has" === r2 ? hn(cn(t2[1])) : "within" !== r2 || t2;
      }
      function ln(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return ["filter-type-" + r2, e2];
          case "$id":
            return ["filter-id-" + r2, e2];
          default:
            return ["filter-" + r2, t2, e2];
        }
      }
      function pn(t2, e2) {
        if (0 === e2.length)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some(function(t3) {
              return typeof t3 != typeof e2[0];
            }) ? ["filter-in-large", t2, ["literal", e2.sort(sn)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function cn(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function hn(t2) {
        return ["!", t2];
      }
      function fn(t2) {
        return nn(Vt(t2.value)) ? en(Bt({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t3(e2) {
          var r2 = e2.value, n2 = e2.key;
          if ("array" !== Dr(r2))
            return [new Pt(n2, r2, "array expected, " + Dr(r2) + " found")];
          var i2, a2 = e2.styleSpec, o2 = [];
          if (r2.length < 1)
            return [new Pt(n2, r2, "filter array must have at least 1 element")];
          switch (o2 = o2.concat(rn({ key: n2 + "[0]", value: r2[0], valueSpec: a2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), Tt(r2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              r2.length >= 2 && "$type" === Tt(r2[1]) && o2.push(new Pt(n2, r2, '"$type" cannot be use with operator "' + r2[0] + '"'));
            case "==":
            case "!=":
              3 !== r2.length && o2.push(new Pt(n2, r2, 'filter array for operator "' + r2[0] + '" must have 3 elements'));
            case "in":
            case "!in":
              r2.length >= 2 && "string" !== (i2 = Dr(r2[1])) && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
              for (var s2 = 2; s2 < r2.length; s2++)
                i2 = Dr(r2[s2]), "$type" === Tt(r2[1]) ? o2 = o2.concat(rn({ key: n2 + "[" + s2 + "]", value: r2[s2], valueSpec: a2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && o2.push(new Pt(n2 + "[" + s2 + "]", r2[s2], "string, number, or boolean expected, " + i2 + " found"));
              break;
            case "any":
            case "all":
            case "none":
              for (var u2 = 1; u2 < r2.length; u2++)
                o2 = o2.concat(t3({ key: n2 + "[" + u2 + "]", value: r2[u2], style: e2.style, styleSpec: e2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "string" !== i2 && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
              break;
            case "within":
              i2 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "object" !== i2 && o2.push(new Pt(n2 + "[1]", r2[1], "object expected, " + i2 + " found"));
          }
          return o2;
        }(t2);
      }
      function yn(t2, e2) {
        var r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, s2 = i2[e2 + "_" + t2.layerType];
        if (!s2)
          return [];
        var u2 = o2.match(/^(.*)-transition$/);
        if ("paint" === e2 && u2 && s2[u2[1]] && s2[u2[1]].transition)
          return An({ key: r2, value: a2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
        var l2, p3 = t2.valueSpec || s2[o2];
        if (!p3)
          return [new Pt(r2, a2, 'unknown property "' + o2 + '"')];
        if ("string" === Dr(a2) && Tr(p3) && !p3.tokens && (l2 = /^{([^}]+)}$/.exec(a2)))
          return [new Pt(r2, a2, '"' + o2 + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(l2[1]) + " }`.")];
        var c3 = [];
        return "symbol" === t2.layerType && ("text-field" === o2 && n2 && !n2.glyphs && c3.push(new Pt(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Lr(Vt(a2)) && "identity" === Tt(a2.type) && c3.push(new Pt(r2, a2, '"text-font" does not support identity functions'))), c3.concat(An({ key: t2.key, value: a2, valueSpec: p3, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
      }
      function dn(t2) {
        return yn(t2, "paint");
      }
      function mn(t2) {
        return yn(t2, "layout");
      }
      function vn(t2) {
        var e2 = [], r2 = t2.value, n2 = t2.key, i2 = t2.style, a2 = t2.styleSpec;
        r2.type || r2.ref || e2.push(new Pt(n2, r2, 'either "type" or "ref" is required'));
        var o2, s2 = Tt(r2.type), u2 = Tt(r2.ref);
        if (r2.id)
          for (var l2 = Tt(r2.id), p3 = 0; p3 < t2.arrayIndex; p3++) {
            var c3 = i2.layers[p3];
            Tt(c3.id) === l2 && e2.push(new Pt(n2, r2.id, 'duplicate layer id "' + r2.id + '", previously used at line ' + c3.id.__line__));
          }
        if ("ref" in r2)
          ["type", "source", "source-layer", "filter", "layout"].forEach(function(t3) {
            t3 in r2 && e2.push(new Pt(n2, r2[t3], '"' + t3 + '" is prohibited for ref layers'));
          }), i2.layers.forEach(function(t3) {
            Tt(t3.id) === u2 && (o2 = t3);
          }), o2 ? o2.ref ? e2.push(new Pt(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = Tt(o2.type) : e2.push(new Pt(n2, r2.ref, 'ref layer "' + u2 + '" not found'));
        else if ("background" !== s2)
          if (r2.source) {
            var h3 = i2.sources && i2.sources[r2.source], f2 = h3 && Tt(h3.type);
            h3 ? "vector" === f2 && "raster" === s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a raster source')) : "raster" === f2 && "raster" !== s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a vector source')) : "vector" !== f2 || r2["source-layer"] ? "raster-dem" === f2 && "hillshade" !== s2 ? e2.push(new Pt(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === f2 && h3.lineMetrics || e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" must specify a "source-layer"')) : e2.push(new Pt(n2, r2.source, 'source "' + r2.source + '" not found'));
          } else
            e2.push(new Pt(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat($r({ key: n2, value: r2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": function() {
          return [];
        }, type: function() {
          return An({ key: n2 + ".type", value: r2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" });
        }, filter: fn, layout: function(t3) {
          return $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
            return mn(Bt({ layerType: s2 }, t4));
          } } });
        }, paint: function(t3) {
          return $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
            return dn(Bt({ layerType: s2 }, t4));
          } } });
        } } }));
      }
      function gn(t2) {
        var e2 = t2.value, r2 = t2.key, n2 = Dr(e2);
        return "string" !== n2 ? [new Pt(r2, e2, "string expected, " + n2 + " found")] : [];
      }
      var xn = { promoteId: function(t2) {
        var e2 = t2.key, r2 = t2.value;
        if ("string" === Dr(r2))
          return gn({ key: e2, value: r2 });
        var n2 = [];
        for (var i2 in r2)
          n2.push.apply(n2, gn({ key: e2 + "." + i2, value: r2[i2] }));
        return n2;
      } };
      function bn(t2) {
        var e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
        if (!e2.type)
          return [new Pt(r2, e2, '"type" is required')];
        var a2, o2 = Tt(e2.type);
        switch (o2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return $r({ key: r2, value: e2, valueSpec: n2["source_" + o2.replace("-", "_")], style: t2.style, styleSpec: n2, objectElementValidators: xn });
          case "geojson":
            if (a2 = $r({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: xn }), e2.cluster)
              for (var s2 in e2.clusterProperties) {
                var u2 = e2.clusterProperties[s2], l2 = u2[0], p3 = "string" == typeof l2 ? [l2, ["accumulated"], ["get", s2]] : l2;
                a2.push.apply(a2, en({ key: r2 + "." + s2 + ".map", value: u2[1], expressionContext: "cluster-map" })), a2.push.apply(a2, en({ key: r2 + "." + s2 + ".reduce", value: p3, expressionContext: "cluster-reduce" }));
              }
            return a2;
          case "video":
            return $r({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
          case "image":
            return $r({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
          case "canvas":
            return [new Pt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return rn({ key: r2 + ".type", value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
        }
      }
      function wn(t2) {
        var e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style, a2 = [], o2 = Dr(e2);
        if (void 0 === e2)
          return a2;
        if ("object" !== o2)
          return a2.concat([new Pt("light", e2, "object expected, " + o2 + " found")]);
        for (var s2 in e2) {
          var u2 = s2.match(/^(.*)-transition$/);
          a2 = a2.concat(u2 && n2[u2[1]] && n2[u2[1]].transition ? An({ key: s2, value: e2[s2], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[s2] ? An({ key: s2, value: e2[s2], valueSpec: n2[s2], style: i2, styleSpec: r2 }) : [new Pt(s2, e2[s2], 'unknown property "' + s2 + '"')]);
        }
        return a2;
      }
      var _n = { "*": function() {
        return [];
      }, array: Wr, boolean: function(t2) {
        var e2 = t2.value, r2 = t2.key, n2 = Dr(e2);
        return "boolean" !== n2 ? [new Pt(r2, e2, "boolean expected, " + n2 + " found")] : [];
      }, number: Qr, color: function(t2) {
        var e2 = t2.key, r2 = t2.value, n2 = Dr(r2);
        return "string" !== n2 ? [new Pt(e2, r2, "color expected, " + n2 + " found")] : null === Qt(r2) ? [new Pt(e2, r2, 'color expected, "' + r2 + '" found')] : [];
      }, constants: Mt, enum: rn, filter: fn, function: tn, layer: vn, object: $r, source: bn, light: wn, string: gn, formatted: function(t2) {
        return 0 === gn(t2).length ? [] : en(t2);
      }, resolvedImage: function(t2) {
        return 0 === gn(t2).length ? [] : en(t2);
      } };
      function An(t2) {
        var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
        return r2.expression && Lr(Tt(e2)) ? tn(t2) : r2.expression && Gr(Vt(e2)) ? en(t2) : r2.type && _n[r2.type] ? _n[r2.type](t2) : $r(Bt({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function Sn(t2) {
        var e2 = t2.value, r2 = t2.key, n2 = gn(t2);
        return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function kn(t2, e2) {
        void 0 === e2 && (e2 = Et);
        var r2 = [];
        return r2 = r2.concat(An({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Sn, "*": function() {
          return [];
        } } })), t2.constants && (r2 = r2.concat(Mt({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), In(r2);
      }
      function In(t2) {
        return [].concat(t2).sort(function(t3, e2) {
          return t3.line - e2.line;
        });
      }
      function zn(t2) {
        return function() {
          for (var e2 = [], r2 = arguments.length; r2--; )
            e2[r2] = arguments[r2];
          return In(t2.apply(this, e2));
        };
      }
      kn.source = zn(bn), kn.light = zn(wn), kn.layer = zn(vn), kn.filter = zn(fn), kn.paintProperty = zn(dn), kn.layoutProperty = zn(mn);
      var Cn = kn, En = Cn.light, Pn = Cn.paintProperty, Mn = Cn.layoutProperty;
      function Bn(t2, e2) {
        var r2 = false;
        if (e2 && e2.length)
          for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
            t2.fire(new zt(new Error(i2[n2].message))), r2 = true;
        return r2;
      }
      var Tn = Vn;
      function Vn(t2, e2, r2) {
        var n2 = this.cells = [];
        if (t2 instanceof ArrayBuffer) {
          this.arrayBuffer = t2;
          var i2 = new Int32Array(this.arrayBuffer);
          t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
          for (var a2 = 0; a2 < this.d * this.d; a2++) {
            var o2 = i2[3 + a2], s2 = i2[3 + a2 + 1];
            n2.push(o2 === s2 ? null : i2.subarray(o2, s2));
          }
          var u2 = i2[3 + n2.length + 1];
          this.keys = i2.subarray(i2[3 + n2.length], u2), this.bboxes = i2.subarray(u2), this.insert = this._insertReadonly;
        } else {
          this.d = e2 + 2 * r2;
          for (var l2 = 0; l2 < this.d * this.d; l2++)
            n2.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
        var p3 = r2 / e2 * t2;
        this.min = -p3, this.max = t2 + p3;
      }
      Vn.prototype.insert = function(t2, e2, r2, n2, i2) {
        this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
      }, Vn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Vn.prototype._insertCell = function(t2, e2, r2, n2, i2, a2) {
        this.cells[i2].push(a2);
      }, Vn.prototype.query = function(t2, e2, r2, n2, i2) {
        var a2 = this.min, o2 = this.max;
        if (t2 <= a2 && e2 <= a2 && o2 <= r2 && o2 <= n2 && !i2)
          return Array.prototype.slice.call(this.keys);
        var s2 = [];
        return this._forEachCell(t2, e2, r2, n2, this._queryCell, s2, {}, i2), s2;
      }, Vn.prototype._queryCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
        var u2 = this.cells[i2];
        if (null !== u2)
          for (var l2 = this.keys, p3 = this.bboxes, c3 = 0; c3 < u2.length; c3++) {
            var h3 = u2[c3];
            if (void 0 === o2[h3]) {
              var f2 = 4 * h3;
              (s2 ? s2(p3[f2 + 0], p3[f2 + 1], p3[f2 + 2], p3[f2 + 3]) : t2 <= p3[f2 + 2] && e2 <= p3[f2 + 3] && r2 >= p3[f2 + 0] && n2 >= p3[f2 + 1]) ? (o2[h3] = true, a2.push(l2[h3])) : o2[h3] = false;
            }
          }
      }, Vn.prototype._forEachCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
        for (var u2 = this._convertToCellCoord(t2), l2 = this._convertToCellCoord(e2), p3 = this._convertToCellCoord(r2), c3 = this._convertToCellCoord(n2), h3 = u2; h3 <= p3; h3++)
          for (var f2 = l2; f2 <= c3; f2++) {
            var y3 = this.d * f2 + h3;
            if ((!s2 || s2(this._convertFromCellCoord(h3), this._convertFromCellCoord(f2), this._convertFromCellCoord(h3 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r2, n2, y3, a2, o2, s2))
              return;
          }
      }, Vn.prototype._convertFromCellCoord = function(t2) {
        return (t2 - this.padding) / this.scale;
      }, Vn.prototype._convertToCellCoord = function(t2) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
      }, Vn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
          r2 += this.cells[n2].length;
        var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
        i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
        for (var a2 = e2, o2 = 0; o2 < t2.length; o2++) {
          var s2 = t2[o2];
          i2[3 + o2] = a2, i2.set(s2, a2), a2 += s2.length;
        }
        return i2[3 + t2.length] = a2, i2.set(this.keys, a2), i2[3 + t2.length + 1] = a2 += this.keys.length, i2.set(this.bboxes, a2), a2 += this.bboxes.length, i2.buffer;
      };
      var Fn = o.ImageData, Dn = o.ImageBitmap, Ln = {};
      function On(t2, e2, r2) {
        void 0 === r2 && (r2 = {}), Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), Ln[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
      }
      for (var Rn in On("Object", Object), Tn.serialize = function(t2, e2) {
        var r2 = t2.toArrayBuffer();
        return e2 && e2.push(r2), { buffer: r2 };
      }, Tn.deserialize = function(t2) {
        return new Tn(t2.buffer);
      }, On("Grid", Tn), On("Color", te), On("Error", Error), On("ResolvedImage", ie), On("StylePropertyFunction", Yr), On("StyleExpression", Kr, { omit: ["_evaluator"] }), On("ZoomDependentExpression", Jr), On("ZoomConstantExpression", Xr), On("CompoundExpression", xe, { omit: ["_evaluate"] }), Ir)
        Ir[Rn]._classRegistryKey || On("Expression_" + Rn, Ir[Rn]);
      function Un(t2) {
        return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
      }
      function jn(t2) {
        return Dn && t2 instanceof Dn;
      }
      function qn(t2, e2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
          return t2;
        if (Un(t2) || jn(t2))
          return e2 && e2.push(t2), t2;
        if (ArrayBuffer.isView(t2)) {
          var r2 = t2;
          return e2 && e2.push(r2.buffer), r2;
        }
        if (t2 instanceof Fn)
          return e2 && e2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          for (var n2 = [], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1)
            n2.push(qn(a2[i2], e2));
          return n2;
        }
        if ("object" == typeof t2) {
          var o2 = t2.constructor, s2 = o2._classRegistryKey;
          if (!s2)
            throw new Error("can't serialize object of unregistered class");
          var u2 = o2.serialize ? o2.serialize(t2, e2) : {};
          if (!o2.serialize) {
            for (var l2 in t2)
              if (t2.hasOwnProperty(l2) && !(Ln[s2].omit.indexOf(l2) >= 0)) {
                var p3 = t2[l2];
                u2[l2] = Ln[s2].shallow.indexOf(l2) >= 0 ? p3 : qn(p3, e2);
              }
            t2 instanceof Error && (u2.message = t2.message);
          }
          if (u2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== s2 && (u2.$name = s2), u2;
        }
        throw new Error("can't serialize object of type " + typeof t2);
      }
      function Nn(t2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || Un(t2) || jn(t2) || ArrayBuffer.isView(t2) || t2 instanceof Fn)
          return t2;
        if (Array.isArray(t2))
          return t2.map(Nn);
        if ("object" == typeof t2) {
          var e2 = t2.$name || "Object", r2 = Ln[e2].klass;
          if (!r2)
            throw new Error("can't deserialize unregistered class " + e2);
          if (r2.deserialize)
            return r2.deserialize(t2);
          for (var n2 = Object.create(r2.prototype), i2 = 0, a2 = Object.keys(t2); i2 < a2.length; i2 += 1) {
            var o2 = a2[i2];
            if ("$name" !== o2) {
              var s2 = t2[o2];
              n2[o2] = Ln[e2].shallow.indexOf(o2) >= 0 ? s2 : Nn(s2);
            }
          }
          return n2;
        }
        throw new Error("can't deserialize object of type " + typeof t2);
      }
      var Kn = function() {
        this.first = true;
      };
      Kn.prototype.update = function(t2, e2) {
        var r2 = Math.floor(t2);
        return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
      };
      var Gn = { "Latin-1 Supplement": function(t2) {
        return t2 >= 128 && t2 <= 255;
      }, Arabic: function(t2) {
        return t2 >= 1536 && t2 <= 1791;
      }, "Arabic Supplement": function(t2) {
        return t2 >= 1872 && t2 <= 1919;
      }, "Arabic Extended-A": function(t2) {
        return t2 >= 2208 && t2 <= 2303;
      }, "Hangul Jamo": function(t2) {
        return t2 >= 4352 && t2 <= 4607;
      }, "Unified Canadian Aboriginal Syllabics": function(t2) {
        return t2 >= 5120 && t2 <= 5759;
      }, Khmer: function(t2) {
        return t2 >= 6016 && t2 <= 6143;
      }, "Unified Canadian Aboriginal Syllabics Extended": function(t2) {
        return t2 >= 6320 && t2 <= 6399;
      }, "General Punctuation": function(t2) {
        return t2 >= 8192 && t2 <= 8303;
      }, "Letterlike Symbols": function(t2) {
        return t2 >= 8448 && t2 <= 8527;
      }, "Number Forms": function(t2) {
        return t2 >= 8528 && t2 <= 8591;
      }, "Miscellaneous Technical": function(t2) {
        return t2 >= 8960 && t2 <= 9215;
      }, "Control Pictures": function(t2) {
        return t2 >= 9216 && t2 <= 9279;
      }, "Optical Character Recognition": function(t2) {
        return t2 >= 9280 && t2 <= 9311;
      }, "Enclosed Alphanumerics": function(t2) {
        return t2 >= 9312 && t2 <= 9471;
      }, "Geometric Shapes": function(t2) {
        return t2 >= 9632 && t2 <= 9727;
      }, "Miscellaneous Symbols": function(t2) {
        return t2 >= 9728 && t2 <= 9983;
      }, "Miscellaneous Symbols and Arrows": function(t2) {
        return t2 >= 11008 && t2 <= 11263;
      }, "CJK Radicals Supplement": function(t2) {
        return t2 >= 11904 && t2 <= 12031;
      }, "Kangxi Radicals": function(t2) {
        return t2 >= 12032 && t2 <= 12255;
      }, "Ideographic Description Characters": function(t2) {
        return t2 >= 12272 && t2 <= 12287;
      }, "CJK Symbols and Punctuation": function(t2) {
        return t2 >= 12288 && t2 <= 12351;
      }, Hiragana: function(t2) {
        return t2 >= 12352 && t2 <= 12447;
      }, Katakana: function(t2) {
        return t2 >= 12448 && t2 <= 12543;
      }, Bopomofo: function(t2) {
        return t2 >= 12544 && t2 <= 12591;
      }, "Hangul Compatibility Jamo": function(t2) {
        return t2 >= 12592 && t2 <= 12687;
      }, Kanbun: function(t2) {
        return t2 >= 12688 && t2 <= 12703;
      }, "Bopomofo Extended": function(t2) {
        return t2 >= 12704 && t2 <= 12735;
      }, "CJK Strokes": function(t2) {
        return t2 >= 12736 && t2 <= 12783;
      }, "Katakana Phonetic Extensions": function(t2) {
        return t2 >= 12784 && t2 <= 12799;
      }, "Enclosed CJK Letters and Months": function(t2) {
        return t2 >= 12800 && t2 <= 13055;
      }, "CJK Compatibility": function(t2) {
        return t2 >= 13056 && t2 <= 13311;
      }, "CJK Unified Ideographs Extension A": function(t2) {
        return t2 >= 13312 && t2 <= 19903;
      }, "Yijing Hexagram Symbols": function(t2) {
        return t2 >= 19904 && t2 <= 19967;
      }, "CJK Unified Ideographs": function(t2) {
        return t2 >= 19968 && t2 <= 40959;
      }, "Yi Syllables": function(t2) {
        return t2 >= 40960 && t2 <= 42127;
      }, "Yi Radicals": function(t2) {
        return t2 >= 42128 && t2 <= 42191;
      }, "Hangul Jamo Extended-A": function(t2) {
        return t2 >= 43360 && t2 <= 43391;
      }, "Hangul Syllables": function(t2) {
        return t2 >= 44032 && t2 <= 55215;
      }, "Hangul Jamo Extended-B": function(t2) {
        return t2 >= 55216 && t2 <= 55295;
      }, "Private Use Area": function(t2) {
        return t2 >= 57344 && t2 <= 63743;
      }, "CJK Compatibility Ideographs": function(t2) {
        return t2 >= 63744 && t2 <= 64255;
      }, "Arabic Presentation Forms-A": function(t2) {
        return t2 >= 64336 && t2 <= 65023;
      }, "Vertical Forms": function(t2) {
        return t2 >= 65040 && t2 <= 65055;
      }, "CJK Compatibility Forms": function(t2) {
        return t2 >= 65072 && t2 <= 65103;
      }, "Small Form Variants": function(t2) {
        return t2 >= 65104 && t2 <= 65135;
      }, "Arabic Presentation Forms-B": function(t2) {
        return t2 >= 65136 && t2 <= 65279;
      }, "Halfwidth and Fullwidth Forms": function(t2) {
        return t2 >= 65280 && t2 <= 65519;
      } };
      function Zn(t2) {
        for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
          if (Xn(r2[e2].charCodeAt(0)))
            return true;
        return false;
      }
      function Xn(t2) {
        return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Gn["Bopomofo Extended"](t2) || Gn.Bopomofo(t2) || Gn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Gn["CJK Compatibility Ideographs"](t2) || Gn["CJK Compatibility"](t2) || Gn["CJK Radicals Supplement"](t2) || Gn["CJK Strokes"](t2) || !(!Gn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Gn["CJK Unified Ideographs Extension A"](t2) || Gn["CJK Unified Ideographs"](t2) || Gn["Enclosed CJK Letters and Months"](t2) || Gn["Hangul Compatibility Jamo"](t2) || Gn["Hangul Jamo Extended-A"](t2) || Gn["Hangul Jamo Extended-B"](t2) || Gn["Hangul Jamo"](t2) || Gn["Hangul Syllables"](t2) || Gn.Hiragana(t2) || Gn["Ideographic Description Characters"](t2) || Gn.Kanbun(t2) || Gn["Kangxi Radicals"](t2) || Gn["Katakana Phonetic Extensions"](t2) || Gn.Katakana(t2) && 12540 !== t2 || !(!Gn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Gn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Gn["Unified Canadian Aboriginal Syllabics"](t2) || Gn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Gn["Vertical Forms"](t2) || Gn["Yijing Hexagram Symbols"](t2) || Gn["Yi Syllables"](t2) || Gn["Yi Radicals"](t2))));
      }
      function Jn(t2) {
        return !(Xn(t2) || function(t3) {
          return !!(Gn["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Gn["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Gn["Letterlike Symbols"](t3) || Gn["Number Forms"](t3) || Gn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Gn["Control Pictures"](t3) && 9251 !== t3 || Gn["Optical Character Recognition"](t3) || Gn["Enclosed Alphanumerics"](t3) || Gn["Geometric Shapes"](t3) || Gn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Gn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Gn["CJK Symbols and Punctuation"](t3) || Gn.Katakana(t3) || Gn["Private Use Area"](t3) || Gn["CJK Compatibility Forms"](t3) || Gn["Small Form Variants"](t3) || Gn["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
        }(t2));
      }
      function Hn(t2) {
        return t2 >= 1424 && t2 <= 2303 || Gn["Arabic Presentation Forms-A"](t2) || Gn["Arabic Presentation Forms-B"](t2);
      }
      function Yn(t2, e2) {
        return !(!e2 && Hn(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Gn.Khmer(t2));
      }
      function $n(t2) {
        for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
          if (Hn(r2[e2].charCodeAt(0)))
            return true;
        return false;
      }
      var Wn = null, Qn = "unavailable", ti = null, ei = function(t2) {
        t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Qn = "error"), Wn && Wn(t2);
      };
      function ri() {
        ni.fire(new It("pluginStateChange", { pluginStatus: Qn, pluginURL: ti }));
      }
      var ni = new Ct(), ii = function() {
        return Qn;
      }, ai = function() {
        if ("deferred" !== Qn || !ti)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Qn = "loading", ri(), ti && bt({ url: ti }, function(t2) {
          t2 ? ei(t2) : (Qn = "loaded", ri());
        });
      }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
        return "loaded" === Qn || null != oi.applyArabicShaping;
      }, isLoading: function() {
        return "loading" === Qn;
      }, setState: function(t2) {
        Qn = t2.pluginStatus, ti = t2.pluginURL;
      }, isParsed: function() {
        return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
      }, getPluginURL: function() {
        return ti;
      } }, si = function(t2, e2) {
        this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Kn(), this.transition = {});
      };
      si.prototype.isSupportedScript = function(t2) {
        return function(t3, e2) {
          for (var r2 = 0, n2 = t3; r2 < n2.length; r2 += 1)
            if (!Yn(n2[r2].charCodeAt(0), e2))
              return false;
          return true;
        }(t2, oi.isLoaded());
      }, si.prototype.crossFadingFactor = function() {
        return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }, si.prototype.getCrossfadeParameters = function() {
        var t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
        return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
      };
      var ui = function(t2, e2) {
        this.property = t2, this.value = e2, this.expression = function(t3, e3) {
          if (Lr(t3))
            return new Yr(t3, e3);
          if (Gr(t3)) {
            var r2 = Hr(t3, e3);
            if ("error" === r2.result)
              throw new Error(r2.value.map(function(t4) {
                return t4.key + ": " + t4.message;
              }).join(", "));
            return r2.value;
          }
          var n2 = t3;
          return "string" == typeof t3 && "color" === e3.type && (n2 = te.parse(t3)), { kind: "constant", evaluate: function() {
            return n2;
          } };
        }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
      };
      ui.prototype.isDataDriven = function() {
        return "source" === this.expression.kind || "composite" === this.expression.kind;
      }, ui.prototype.possiblyEvaluate = function(t2, e2, r2) {
        return this.property.possiblyEvaluate(this, t2, e2, r2);
      };
      var li = function(t2) {
        this.property = t2, this.value = new ui(t2, void 0);
      };
      li.prototype.transitioned = function(t2, e2) {
        return new ci(this.property, this.value, e2, h2({}, t2.transition, this.transition), t2.now);
      }, li.prototype.untransitioned = function() {
        return new ci(this.property, this.value, null, {}, 0);
      };
      var pi = function(t2) {
        this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
      };
      pi.prototype.getValue = function(t2) {
        return w(this._values[t2].value.value);
      }, pi.prototype.setValue = function(t2, e2) {
        this._values.hasOwnProperty(t2) || (this._values[t2] = new li(this._values[t2].property)), this._values[t2].value = new ui(this._values[t2].property, null === e2 ? void 0 : w(e2));
      }, pi.prototype.getTransition = function(t2) {
        return w(this._values[t2].transition);
      }, pi.prototype.setTransition = function(t2, e2) {
        this._values.hasOwnProperty(t2) || (this._values[t2] = new li(this._values[t2].property)), this._values[t2].transition = w(e2) || void 0;
      }, pi.prototype.serialize = function() {
        for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
          var n2 = r2[e2], i2 = this.getValue(n2);
          void 0 !== i2 && (t2[n2] = i2);
          var a2 = this.getTransition(n2);
          void 0 !== a2 && (t2[n2 + "-transition"] = a2);
        }
        return t2;
      }, pi.prototype.transitioned = function(t2, e2) {
        for (var r2 = new hi(this._properties), n2 = 0, i2 = Object.keys(this._values); n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          r2._values[a2] = this._values[a2].transitioned(t2, e2._values[a2]);
        }
        return r2;
      }, pi.prototype.untransitioned = function() {
        for (var t2 = new hi(this._properties), e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
          var n2 = r2[e2];
          t2._values[n2] = this._values[n2].untransitioned();
        }
        return t2;
      };
      var ci = function(t2, e2, r2, n2, i2) {
        this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
      };
      ci.prototype.possiblyEvaluate = function(t2, e2, r2) {
        var n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), a2 = this.prior;
        if (a2) {
          if (n2 > this.end)
            return this.prior = null, i2;
          if (this.value.isDataDriven())
            return this.prior = null, i2;
          if (n2 < this.begin)
            return a2.possiblyEvaluate(t2, e2, r2);
          var o2 = (n2 - this.begin) / (this.end - this.begin);
          return this.property.interpolate(a2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
            if (t3 <= 0)
              return 0;
            if (t3 >= 1)
              return 1;
            var e3 = t3 * t3, r3 = e3 * t3;
            return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
          }(o2));
        }
        return i2;
      };
      var hi = function(t2) {
        this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
      };
      hi.prototype.possiblyEvaluate = function(t2, e2, r2) {
        for (var n2 = new di(this._properties), i2 = 0, a2 = Object.keys(this._values); i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          n2._values[o2] = this._values[o2].possiblyEvaluate(t2, e2, r2);
        }
        return n2;
      }, hi.prototype.hasTransition = function() {
        for (var t2 = 0, e2 = Object.keys(this._values); t2 < e2.length; t2 += 1)
          if (this._values[e2[t2]].prior)
            return true;
        return false;
      };
      var fi = function(t2) {
        this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
      };
      fi.prototype.getValue = function(t2) {
        return w(this._values[t2].value);
      }, fi.prototype.setValue = function(t2, e2) {
        this._values[t2] = new ui(this._values[t2].property, null === e2 ? void 0 : w(e2));
      }, fi.prototype.serialize = function() {
        for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
          var n2 = r2[e2], i2 = this.getValue(n2);
          void 0 !== i2 && (t2[n2] = i2);
        }
        return t2;
      }, fi.prototype.possiblyEvaluate = function(t2, e2, r2) {
        for (var n2 = new di(this._properties), i2 = 0, a2 = Object.keys(this._values); i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          n2._values[o2] = this._values[o2].possiblyEvaluate(t2, e2, r2);
        }
        return n2;
      };
      var yi = function(t2, e2, r2) {
        this.property = t2, this.value = e2, this.parameters = r2;
      };
      yi.prototype.isConstant = function() {
        return "constant" === this.value.kind;
      }, yi.prototype.constantOr = function(t2) {
        return "constant" === this.value.kind ? this.value.value : t2;
      }, yi.prototype.evaluate = function(t2, e2, r2, n2) {
        return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
      };
      var di = function(t2) {
        this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
      };
      di.prototype.get = function(t2) {
        return this._values[t2];
      };
      var mi = function(t2) {
        this.specification = t2;
      };
      mi.prototype.possiblyEvaluate = function(t2, e2) {
        return t2.expression.evaluate(e2);
      }, mi.prototype.interpolate = function(t2, e2, r2) {
        var n2 = Ge[this.specification.type];
        return n2 ? n2(t2, e2, r2) : t2;
      };
      var vi = function(t2, e2) {
        this.specification = t2, this.overrides = e2;
      };
      vi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
        return new yi(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
      }, vi.prototype.interpolate = function(t2, e2, r2) {
        if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
          return t2;
        if (void 0 === t2.value.value || void 0 === e2.value.value)
          return new yi(this, { kind: "constant", value: void 0 }, t2.parameters);
        var n2 = Ge[this.specification.type];
        return n2 ? new yi(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
      }, vi.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
        return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, a2);
      };
      var gi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(t3, e3, r2, n2) {
          if (void 0 === t3.value)
            return new yi(this, { kind: "constant", value: void 0 }, e3);
          if ("constant" === t3.expression.kind) {
            var i2 = t3.expression.evaluate(e3, null, {}, r2, n2), a2 = "resolvedImage" === t3.property.specification.type && "string" != typeof i2 ? i2.name : i2, o2 = this._calculate(a2, a2, a2, e3);
            return new yi(this, { kind: "constant", value: o2 }, e3);
          }
          if ("camera" === t3.expression.kind) {
            var s2 = this._calculate(t3.expression.evaluate({ zoom: e3.zoom - 1 }), t3.expression.evaluate({ zoom: e3.zoom }), t3.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
            return new yi(this, { kind: "constant", value: s2 }, e3);
          }
          return new yi(this, t3.expression, e3);
        }, e2.prototype.evaluate = function(t3, e3, r2, n2, i2, a2) {
          if ("source" === t3.kind) {
            var o2 = t3.evaluate(e3, r2, n2, i2, a2);
            return this._calculate(o2, o2, o2, e3);
          }
          return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t3.value;
        }, e2.prototype._calculate = function(t3, e3, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r2, to: e3 };
        }, e2.prototype.interpolate = function(t3) {
          return t3;
        }, e2;
      }(vi), xi = function(t2) {
        this.specification = t2;
      };
      xi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
        if (void 0 !== t2.value) {
          if ("constant" === t2.expression.kind) {
            var i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
            return this._calculate(i2, i2, i2, e2);
          }
          return this._calculate(t2.expression.evaluate(new si(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new si(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new si(Math.floor(e2.zoom + 1), e2)), e2);
        }
      }, xi.prototype._calculate = function(t2, e2, r2, n2) {
        return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
      }, xi.prototype.interpolate = function(t2) {
        return t2;
      };
      var bi = function(t2) {
        this.specification = t2;
      };
      bi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
        return !!t2.expression.evaluate(e2, null, {}, r2, n2);
      }, bi.prototype.interpolate = function() {
        return false;
      };
      var wi = function(t2) {
        for (var e2 in this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t2) {
          var r2 = t2[e2];
          r2.specification.overridable && this.overridableProperties.push(e2);
          var n2 = this.defaultPropertyValues[e2] = new ui(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new li(r2);
          this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
        }
      };
      On("DataDrivenProperty", vi), On("DataConstantProperty", mi), On("CrossFadedDataDrivenProperty", gi), On("CrossFadedProperty", xi), On("ColorRampProperty", bi);
      var _i = function(t2) {
        function e2(e3, r2) {
          if (t2.call(this), this.id = e3.id, this.type = e3.type, this._featureFilter = { filter: function() {
            return true;
          }, needGeometry: false }, "custom" !== e3.type && (this.metadata = (e3 = e3).metadata, this.minzoom = e3.minzoom, this.maxzoom = e3.maxzoom, "background" !== e3.type && (this.source = e3.source, this.sourceLayer = e3["source-layer"], this.filter = e3.filter), r2.layout && (this._unevaluatedLayout = new fi(r2.layout)), r2.paint)) {
            for (var n2 in this._transitionablePaint = new pi(r2.paint), e3.paint)
              this.setPaintProperty(n2, e3.paint[n2], { validate: false });
            for (var i2 in e3.layout)
              this.setLayoutProperty(i2, e3.layout[i2], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new di(r2.paint);
          }
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getCrossfadeParameters = function() {
          return this._crossfadeParameters;
        }, e2.prototype.getLayoutProperty = function(t3) {
          return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
        }, e2.prototype.setLayoutProperty = function(t3, e3, r2) {
          void 0 === r2 && (r2 = {}), null != e3 && this._validate(Mn, "layers." + this.id + ".layout." + t3, t3, e3, r2) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3);
        }, e2.prototype.getPaintProperty = function(t3) {
          return g(t3, "-transition") ? this._transitionablePaint.getTransition(t3.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t3);
        }, e2.prototype.setPaintProperty = function(t3, e3, r2) {
          if (void 0 === r2 && (r2 = {}), null != e3 && this._validate(Pn, "layers." + this.id + ".paint." + t3, t3, e3, r2))
            return false;
          if (g(t3, "-transition"))
            return this._transitionablePaint.setTransition(t3.slice(0, -"-transition".length), e3 || void 0), false;
          var n2 = this._transitionablePaint._values[t3], i2 = "cross-faded-data-driven" === n2.property.specification["property-type"], a2 = n2.value.isDataDriven(), o2 = n2.value;
          this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
          var s2 = this._transitionablePaint._values[t3].value;
          return s2.isDataDriven() || a2 || i2 || this._handleOverridablePaintPropertyUpdate(t3, o2, s2);
        }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
        }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, e3, r2) {
          return false;
        }, e2.prototype.isHidden = function(t3) {
          return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
        }, e2.prototype.updateTransitions = function(t3) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
        }, e2.prototype.hasTransition = function() {
          return this._transitioningPaint.hasTransition();
        }, e2.prototype.recalculate = function(t3, e3) {
          t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e3);
        }, e2.prototype.serialize = function() {
          var t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), b(t3, function(t4, e3) {
            return !(void 0 === t4 || "layout" === e3 && !Object.keys(t4).length || "paint" === e3 && !Object.keys(t4).length);
          });
        }, e2.prototype._validate = function(t3, e3, r2, n2, i2) {
          return void 0 === i2 && (i2 = {}), (!i2 || false !== i2.validate) && Bn(this, t3.call(Cn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: Et, style: { glyphs: true, sprite: true } }));
        }, e2.prototype.is3D = function() {
          return false;
        }, e2.prototype.isTileClipped = function() {
          return false;
        }, e2.prototype.hasOffscreenPass = function() {
          return false;
        }, e2.prototype.resize = function() {
        }, e2.prototype.isStateDependent = function() {
          for (var t3 in this.paint._values) {
            var e3 = this.paint.get(t3);
            if (e3 instanceof yi && Tr(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
              return true;
          }
          return false;
        }, e2;
      }(Ct), Ai = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Si = function(t2, e2) {
        this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }, ki = function() {
        this.isTransferred = false, this.capacity = -1, this.resize(0);
      };
      function Ii(t2, e2) {
        void 0 === e2 && (e2 = 1);
        var r2 = 0, n2 = 0;
        return { members: t2.map(function(t3) {
          var i2 = Ai[t3.type].BYTES_PER_ELEMENT, a2 = r2 = zi(r2, Math.max(e2, i2)), o2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * o2, { name: t3.name, type: t3.type, components: o2, offset: a2 };
        }), size: zi(r2, Math.max(n2, e2)), alignment: e2 };
      }
      function zi(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }
      ki.serialize = function(t2, e2) {
        return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
      }, ki.deserialize = function(t2) {
        var e2 = Object.create(this.prototype);
        return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
      }, ki.prototype._trim = function() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }, ki.prototype.clear = function() {
        this.length = 0;
      }, ki.prototype.resize = function(t2) {
        this.reserve(t2), this.length = t2;
      }, ki.prototype.reserve = function(t2) {
        if (t2 > this.capacity) {
          this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          var e2 = this.uint8;
          this._refreshViews(), e2 && this.uint8.set(e2);
        }
      }, ki.prototype._refreshViews = function() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      };
      var Ci = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3) {
          var r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t3, e3);
        }, e2.prototype.emplace = function(t3, e3, r2) {
          var n2 = 2 * t3;
          return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t3;
        }, e2;
      }(ki);
      Ci.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ci);
      var Ei = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
          var i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
          var a2 = 4 * t3;
          return this.int16[a2 + 0] = e3, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, t3;
        }, e2;
      }(ki);
      Ei.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Ei);
      var Pi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
          var o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
          var s2 = 6 * t3;
          return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
        }, e2;
      }(ki);
      Pi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Pi);
      var Mi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
          var o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
          var s2 = 4 * t3, u2 = 8 * t3;
          return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = a2, this.uint8[u2 + 7] = o2, t3;
        }, e2;
      }(ki);
      Mi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Mi);
      var Bi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3) {
          var r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t3, e3);
        }, e2.prototype.emplace = function(t3, e3, r2) {
          var n2 = 2 * t3;
          return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t3;
        }, e2;
      }(ki);
      Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Bi);
      var Ti = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2) {
          var p3 = this.length;
          return this.resize(p3 + 1), this.emplace(p3, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3) {
          var c3 = 10 * t3;
          return this.uint16[c3 + 0] = e3, this.uint16[c3 + 1] = r2, this.uint16[c3 + 2] = n2, this.uint16[c3 + 3] = i2, this.uint16[c3 + 4] = a2, this.uint16[c3 + 5] = o2, this.uint16[c3 + 6] = s2, this.uint16[c3 + 7] = u2, this.uint16[c3 + 8] = l2, this.uint16[c3 + 9] = p3, t3;
        }, e2;
      }(ki);
      Ti.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Ti);
      var Vi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3) {
          var h3 = this.length;
          return this.resize(h3 + 1), this.emplace(h3, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3) {
          var f2 = 12 * t3;
          return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = s2, this.uint16[f2 + 7] = u2, this.int16[f2 + 8] = l2, this.int16[f2 + 9] = p3, this.int16[f2 + 10] = c3, this.int16[f2 + 11] = h3, t3;
        }, e2;
      }(ki);
      Vi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Vi);
      var Fi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2) {
          var n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2) {
          var i2 = 3 * t3;
          return this.float32[i2 + 0] = e3, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t3;
        }, e2;
      }(ki);
      Fi.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Fi);
      var Di = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3) {
          var e3 = this.length;
          return this.resize(e3 + 1), this.emplace(e3, t3);
        }, e2.prototype.emplace = function(t3, e3) {
          return this.uint32[1 * t3 + 0] = e3, t3;
        }, e2;
      }(ki);
      Di.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Di);
      var Li = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2) {
          var l2 = this.length;
          return this.resize(l2 + 1), this.emplace(l2, t3, e3, r2, n2, i2, a2, o2, s2, u2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2) {
          var p3 = 10 * t3, c3 = 5 * t3;
          return this.int16[p3 + 0] = e3, this.int16[p3 + 1] = r2, this.int16[p3 + 2] = n2, this.int16[p3 + 3] = i2, this.int16[p3 + 4] = a2, this.int16[p3 + 5] = o2, this.uint32[c3 + 3] = s2, this.uint16[p3 + 8] = u2, this.uint16[p3 + 9] = l2, t3;
        }, e2;
      }(ki);
      Li.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Li);
      var Oi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
          var o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
          var s2 = 6 * t3;
          return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
        }, e2;
      }(ki);
      Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);
      var Ri = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2) {
          var a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t3, e3, r2, n2, i2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2) {
          var o2 = 4 * t3, s2 = 8 * t3;
          return this.float32[o2 + 0] = e3, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.int16[s2 + 6] = i2, this.int16[s2 + 7] = a2, t3;
        }, e2;
      }(ki);
      Ri.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ri);
      var Ui = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
          var i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
          var a2 = 12 * t3, o2 = 3 * t3;
          return this.uint8[a2 + 0] = e3, this.uint8[a2 + 1] = r2, this.float32[o2 + 1] = n2, this.float32[o2 + 2] = i2, t3;
        }, e2;
      }(ki);
      Ui.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ui);
      var ji = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2) {
          var n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2) {
          var i2 = 3 * t3;
          return this.uint16[i2 + 0] = e3, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t3;
        }, e2;
      }(ki);
      ji.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", ji);
      var qi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2) {
          var v3 = this.length;
          return this.resize(v3 + 1), this.emplace(v3, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2, v3) {
          var g2 = 24 * t3, x2 = 12 * t3, b2 = 48 * t3;
          return this.int16[g2 + 0] = e3, this.int16[g2 + 1] = r2, this.uint16[g2 + 2] = n2, this.uint16[g2 + 3] = i2, this.uint32[x2 + 2] = a2, this.uint32[x2 + 3] = o2, this.uint32[x2 + 4] = s2, this.uint16[g2 + 10] = u2, this.uint16[g2 + 11] = l2, this.uint16[g2 + 12] = p3, this.float32[x2 + 7] = c3, this.float32[x2 + 8] = h3, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = y3, this.uint8[b2 + 38] = d2, this.uint32[x2 + 10] = m2, this.int16[g2 + 22] = v3, t3;
        }, e2;
      }(ki);
      qi.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", qi);
      var Ni = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2, v3, g2, x2, b2, w2, _24, A3, S2, k2, I3, z2) {
          var C2 = this.length;
          return this.resize(C2 + 1), this.emplace(C2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2, v3, g2, x2, b2, w2, _24, A3, S2, k2, I3, z2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2, m2, v3, g2, x2, b2, w2, _24, A3, S2, k2, I3, z2, C2) {
          var E2 = 34 * t3, P2 = 17 * t3;
          return this.int16[E2 + 0] = e3, this.int16[E2 + 1] = r2, this.int16[E2 + 2] = n2, this.int16[E2 + 3] = i2, this.int16[E2 + 4] = a2, this.int16[E2 + 5] = o2, this.int16[E2 + 6] = s2, this.int16[E2 + 7] = u2, this.uint16[E2 + 8] = l2, this.uint16[E2 + 9] = p3, this.uint16[E2 + 10] = c3, this.uint16[E2 + 11] = h3, this.uint16[E2 + 12] = f2, this.uint16[E2 + 13] = y3, this.uint16[E2 + 14] = d2, this.uint16[E2 + 15] = m2, this.uint16[E2 + 16] = v3, this.uint16[E2 + 17] = g2, this.uint16[E2 + 18] = x2, this.uint16[E2 + 19] = b2, this.uint16[E2 + 20] = w2, this.uint16[E2 + 21] = _24, this.uint16[E2 + 22] = A3, this.uint32[P2 + 12] = S2, this.float32[P2 + 13] = k2, this.float32[P2 + 14] = I3, this.float32[P2 + 15] = z2, this.float32[P2 + 16] = C2, t3;
        }, e2;
      }(ki);
      Ni.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ni);
      var Ki = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3) {
          var e3 = this.length;
          return this.resize(e3 + 1), this.emplace(e3, t3);
        }, e2.prototype.emplace = function(t3, e3) {
          return this.float32[1 * t3 + 0] = e3, t3;
        }, e2;
      }(ki);
      Ki.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Ki);
      var Gi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2) {
          var n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2) {
          var i2 = 3 * t3;
          return this.int16[i2 + 0] = e3, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t3;
        }, e2;
      }(ki);
      Gi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Gi);
      var Zi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2) {
          var n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2) {
          var i2 = 4 * t3;
          return this.uint32[2 * t3 + 0] = e3, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t3;
        }, e2;
      }(ki);
      Zi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Zi);
      var Xi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3) {
          var r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t3, e3);
        }, e2.prototype.emplace = function(t3, e3, r2) {
          var n2 = 2 * t3;
          return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t3;
        }, e2;
      }(ki);
      Xi.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Xi);
      var Ji = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3) {
          var e3 = this.length;
          return this.resize(e3 + 1), this.emplace(e3, t3);
        }, e2.prototype.emplace = function(t3, e3) {
          return this.uint16[1 * t3 + 0] = e3, t3;
        }, e2;
      }(ki);
      Ji.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Ji);
      var Hi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
          var i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
        }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
          var a2 = 4 * t3;
          return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, t3;
        }, e2;
      }(ki);
      Hi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Hi);
      var Yi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var r2 = { anchorPointX: { configurable: true }, anchorPointY: { configurable: true }, x1: { configurable: true }, y1: { configurable: true }, x2: { configurable: true }, y2: { configurable: true }, featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true }, anchorPoint: { configurable: true } };
        return r2.anchorPointX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, r2.anchorPointY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, r2.x1.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, r2.y1.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, r2.x2.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, r2.y2.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, r2.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, r2.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, r2.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, r2.anchorPoint.get = function() {
          return new i(this.anchorPointX, this.anchorPointY);
        }, Object.defineProperties(e2.prototype, r2), e2;
      }(Si);
      Yi.prototype.size = 20;
      var $i = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
          return new Yi(this, t3);
        }, e2;
      }(Li);
      On("CollisionBoxArray", $i);
      var Wi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, glyphStartIndex: { configurable: true }, numGlyphs: { configurable: true }, vertexStartIndex: { configurable: true }, lineStartIndex: { configurable: true }, lineLength: { configurable: true }, segment: { configurable: true }, lowerSize: { configurable: true }, upperSize: { configurable: true }, lineOffsetX: { configurable: true }, lineOffsetY: { configurable: true }, writingMode: { configurable: true }, placedOrientation: { configurable: true }, hidden: { configurable: true }, crossTileID: { configurable: true }, associatedIconIndex: { configurable: true } };
        return r2.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, r2.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, r2.glyphStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, r2.numGlyphs.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, r2.vertexStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 2];
        }, r2.lineStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, r2.lineLength.get = function() {
          return this._structArray.uint32[this._pos4 + 4];
        }, r2.segment.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, r2.lowerSize.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, r2.upperSize.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, r2.lineOffsetX.get = function() {
          return this._structArray.float32[this._pos4 + 7];
        }, r2.lineOffsetY.get = function() {
          return this._structArray.float32[this._pos4 + 8];
        }, r2.writingMode.get = function() {
          return this._structArray.uint8[this._pos1 + 36];
        }, r2.placedOrientation.get = function() {
          return this._structArray.uint8[this._pos1 + 37];
        }, r2.placedOrientation.set = function(t3) {
          this._structArray.uint8[this._pos1 + 37] = t3;
        }, r2.hidden.get = function() {
          return this._structArray.uint8[this._pos1 + 38];
        }, r2.hidden.set = function(t3) {
          this._structArray.uint8[this._pos1 + 38] = t3;
        }, r2.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 10];
        }, r2.crossTileID.set = function(t3) {
          this._structArray.uint32[this._pos4 + 10] = t3;
        }, r2.associatedIconIndex.get = function() {
          return this._structArray.int16[this._pos2 + 22];
        }, Object.defineProperties(e2.prototype, r2), e2;
      }(Si);
      Wi.prototype.size = 48;
      var Qi = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
          return new Wi(this, t3);
        }, e2;
      }(qi);
      On("PlacedSymbolArray", Qi);
      var ta = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, rightJustifiedTextSymbolIndex: { configurable: true }, centerJustifiedTextSymbolIndex: { configurable: true }, leftJustifiedTextSymbolIndex: { configurable: true }, verticalPlacedTextSymbolIndex: { configurable: true }, placedIconSymbolIndex: { configurable: true }, verticalPlacedIconSymbolIndex: { configurable: true }, key: { configurable: true }, textBoxStartIndex: { configurable: true }, textBoxEndIndex: { configurable: true }, verticalTextBoxStartIndex: { configurable: true }, verticalTextBoxEndIndex: { configurable: true }, iconBoxStartIndex: { configurable: true }, iconBoxEndIndex: { configurable: true }, verticalIconBoxStartIndex: { configurable: true }, verticalIconBoxEndIndex: { configurable: true }, featureIndex: { configurable: true }, numHorizontalGlyphVertices: { configurable: true }, numVerticalGlyphVertices: { configurable: true }, numIconVertices: { configurable: true }, numVerticalIconVertices: { configurable: true }, useRuntimeCollisionCircles: { configurable: true }, crossTileID: { configurable: true }, textBoxScale: { configurable: true }, textOffset0: { configurable: true }, textOffset1: { configurable: true }, collisionCircleDiameter: { configurable: true } };
        return r2.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, r2.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, r2.rightJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, r2.centerJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, r2.leftJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, r2.verticalPlacedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, r2.placedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 6];
        }, r2.verticalPlacedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 7];
        }, r2.key.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, r2.textBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, r2.textBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, r2.verticalTextBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, r2.verticalTextBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, r2.iconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 13];
        }, r2.iconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 14];
        }, r2.verticalIconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 15];
        }, r2.verticalIconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 16];
        }, r2.featureIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 17];
        }, r2.numHorizontalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 18];
        }, r2.numVerticalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 19];
        }, r2.numIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 20];
        }, r2.numVerticalIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 21];
        }, r2.useRuntimeCollisionCircles.get = function() {
          return this._structArray.uint16[this._pos2 + 22];
        }, r2.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 12];
        }, r2.crossTileID.set = function(t3) {
          this._structArray.uint32[this._pos4 + 12] = t3;
        }, r2.textBoxScale.get = function() {
          return this._structArray.float32[this._pos4 + 13];
        }, r2.textOffset0.get = function() {
          return this._structArray.float32[this._pos4 + 14];
        }, r2.textOffset1.get = function() {
          return this._structArray.float32[this._pos4 + 15];
        }, r2.collisionCircleDiameter.get = function() {
          return this._structArray.float32[this._pos4 + 16];
        }, Object.defineProperties(e2.prototype, r2), e2;
      }(Si);
      ta.prototype.size = 68;
      var ea = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
          return new ta(this, t3);
        }, e2;
      }(Ni);
      On("SymbolInstanceArray", ea);
      var ra = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getoffsetX = function(t3) {
          return this.float32[1 * t3 + 0];
        }, e2;
      }(Ki);
      On("GlyphOffsetArray", ra);
      var na = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getx = function(t3) {
          return this.int16[3 * t3 + 0];
        }, e2.prototype.gety = function(t3) {
          return this.int16[3 * t3 + 1];
        }, e2.prototype.gettileUnitDistanceFromAnchor = function(t3) {
          return this.int16[3 * t3 + 2];
        }, e2;
      }(Gi);
      On("SymbolLineVertexArray", na);
      var ia = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var r2 = { featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true } };
        return r2.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 0];
        }, r2.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, r2.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, Object.defineProperties(e2.prototype, r2), e2;
      }(Si);
      ia.prototype.size = 8;
      var aa = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
          return new ia(this, t3);
        }, e2;
      }(Zi);
      On("FeatureIndexArray", aa);
      var oa = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, sa = function(t2) {
        void 0 === t2 && (t2 = []), this.segments = t2;
      };
      function ua(t2, e2) {
        return 256 * (t2 = p2(Math.floor(t2), 0, 255)) + p2(Math.floor(e2), 0, 255);
      }
      sa.prototype.prepareSegment = function(t2, e2, r2, n2) {
        var i2 = this.segments[this.segments.length - 1];
        return t2 > sa.MAX_VERTEX_ARRAY_LENGTH && A2("Max vertices per segment is " + sa.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t2), (!i2 || i2.vertexLength + t2 > sa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
      }, sa.prototype.get = function() {
        return this.segments;
      }, sa.prototype.destroy = function() {
        for (var t2 = 0, e2 = this.segments; t2 < e2.length; t2 += 1) {
          var r2 = e2[t2];
          for (var n2 in r2.vaos)
            r2.vaos[n2].destroy();
        }
      }, sa.simpleSegment = function(t2, e2, r2, n2) {
        return new sa([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
      }, sa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", sa);
      var la = Ii([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), pa = e(function(t2) {
        t2.exports = function(t3, e2) {
          var r2, n2, i2, a2, o2, s2, u2, l2;
          for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e2, o2 = 3432918353, s2 = 461845907, l2 = 0; l2 < n2; )
            u2 = 255 & t3.charCodeAt(l2) | (255 & t3.charCodeAt(++l2)) << 8 | (255 & t3.charCodeAt(++l2)) << 16 | (255 & t3.charCodeAt(++l2)) << 24, ++l2, i2 = 27492 + (65535 & (a2 = 5 * (65535 & (i2 = (i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & u2) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
          switch (u2 = 0, r2) {
            case 3:
              u2 ^= (255 & t3.charCodeAt(l2 + 2)) << 16;
            case 2:
              u2 ^= (255 & t3.charCodeAt(l2 + 1)) << 8;
            case 1:
              i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & (u2 ^= 255 & t3.charCodeAt(l2))) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
      }), ca = e(function(t2) {
        t2.exports = function(t3, e2) {
          for (var r2, n2 = t3.length, i2 = e2 ^ n2, a2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(a2) | (255 & t3.charCodeAt(++a2)) << 8 | (255 & t3.charCodeAt(++a2)) << 16 | (255 & t3.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t3.charCodeAt(a2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t3.charCodeAt(a2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(a2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
      }), ha = pa, fa = ca;
      ha.murmur3 = pa, ha.murmur2 = fa;
      var ya = function() {
        this.ids = [], this.positions = [], this.indexed = false;
      };
      ya.prototype.add = function(t2, e2, r2, n2) {
        this.ids.push(ma(t2)), this.positions.push(e2, r2, n2);
      }, ya.prototype.getPositions = function(t2) {
        for (var e2 = ma(t2), r2 = 0, n2 = this.ids.length - 1; r2 < n2; ) {
          var i2 = r2 + n2 >> 1;
          this.ids[i2] >= e2 ? n2 = i2 : r2 = i2 + 1;
        }
        for (var a2 = []; this.ids[r2] === e2; )
          a2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
        return a2;
      }, ya.serialize = function(t2, e2) {
        var r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
        return function t3(e3, r3, n3, i2) {
          for (; n3 < i2; ) {
            for (var a2 = e3[n3 + i2 >> 1], o2 = n3 - 1, s2 = i2 + 1; ; ) {
              do {
                o2++;
              } while (e3[o2] < a2);
              do {
                s2--;
              } while (e3[s2] > a2);
              if (o2 >= s2)
                break;
              va(e3, o2, s2), va(r3, 3 * o2, 3 * s2), va(r3, 3 * o2 + 1, 3 * s2 + 1), va(r3, 3 * o2 + 2, 3 * s2 + 2);
            }
            s2 - n3 < i2 - s2 ? (t3(e3, r3, n3, s2), n3 = s2 + 1) : (t3(e3, r3, s2 + 1, i2), i2 = s2);
          }
        }(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
      }, ya.deserialize = function(t2) {
        var e2 = new ya();
        return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
      };
      var da = Math.pow(2, 53) - 1;
      function ma(t2) {
        var e2 = +t2;
        return !isNaN(e2) && e2 <= da ? e2 : ha(String(t2));
      }
      function va(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      On("FeaturePositionMap", ya);
      var ga = function(t2, e2) {
        this.gl = t2.gl, this.location = e2;
      }, xa = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = 0;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
        }, e2;
      }(ga), ba = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = 0;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
        }, e2;
      }(ga), wa = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = [0, 0];
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
        }, e2;
      }(ga), _a = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = [0, 0, 0];
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
        }, e2;
      }(ga), Aa = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = [0, 0, 0, 0];
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
        }, e2;
      }(ga), Sa = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = te.transparent;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
        }, e2;
      }(ga), ka = new Float32Array(16), Ia = function(t2) {
        function e2(e3, r2) {
          t2.call(this, e3, r2), this.current = ka;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
            return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
          for (var e3 = 1; e3 < 16; e3++)
            if (t3[e3] !== this.current[e3]) {
              this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
              break;
            }
        }, e2;
      }(ga);
      function za(t2) {
        return [ua(255 * t2.r, 255 * t2.g), ua(255 * t2.b, 255 * t2.a)];
      }
      var Ca = function(t2, e2, r2) {
        this.value = t2, this.uniformNames = e2.map(function(t3) {
          return "u_" + t3;
        }), this.type = r2;
      };
      Ca.prototype.setUniform = function(t2, e2, r2) {
        t2.set(r2.constantOr(this.value));
      }, Ca.prototype.getBinding = function(t2, e2, r2) {
        return "color" === this.type ? new Sa(t2, e2) : new ba(t2, e2);
      };
      var Ea = function(t2, e2) {
        this.uniformNames = e2.map(function(t3) {
          return "u_" + t3;
        }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      };
      Ea.prototype.setConstantPatternPositions = function(t2, e2) {
        this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
      }, Ea.prototype.setUniform = function(t2, e2, r2, n2) {
        var i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
        i2 && t2.set(i2);
      }, Ea.prototype.getBinding = function(t2, e2, r2) {
        return "u_pattern" === r2.substr(0, 9) ? new Aa(t2, e2) : new ba(t2, e2);
      };
      var Pa = function(t2, e2, r2, n2) {
        this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t3) {
          return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 };
        }), this.paintVertexArray = new n2();
      };
      Pa.prototype.populatePaintArray = function(t2, e2, r2, n2, i2) {
        var a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new si(0), e2, {}, n2, [], i2);
        this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
      }, Pa.prototype.updatePaintArray = function(t2, e2, r2, n2) {
        var i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
        this._setPaintValue(t2, e2, i2);
      }, Pa.prototype._setPaintValue = function(t2, e2, r2) {
        if ("color" === this.type)
          for (var n2 = za(r2), i2 = t2; i2 < e2; i2++)
            this.paintVertexArray.emplace(i2, n2[0], n2[1]);
        else {
          for (var a2 = t2; a2 < e2; a2++)
            this.paintVertexArray.emplace(a2, r2);
          this.maxValue = Math.max(this.maxValue, Math.abs(r2));
        }
      }, Pa.prototype.upload = function(t2) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Pa.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      };
      var Ma = function(t2, e2, r2, n2, i2, a2) {
        this.expression = t2, this.uniformNames = e2.map(function(t3) {
          return "u_" + t3 + "_t";
        }), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t3) {
          return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 };
        }), this.paintVertexArray = new a2();
      };
      Ma.prototype.populatePaintArray = function(t2, e2, r2, n2, i2) {
        var a2 = this.expression.evaluate(new si(this.zoom), e2, {}, n2, [], i2), o2 = this.expression.evaluate(new si(this.zoom + 1), e2, {}, n2, [], i2), s2 = this.paintVertexArray.length;
        this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2, o2);
      }, Ma.prototype.updatePaintArray = function(t2, e2, r2, n2) {
        var i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
        this._setPaintValue(t2, e2, i2, a2);
      }, Ma.prototype._setPaintValue = function(t2, e2, r2, n2) {
        if ("color" === this.type)
          for (var i2 = za(r2), a2 = za(n2), o2 = t2; o2 < e2; o2++)
            this.paintVertexArray.emplace(o2, i2[0], i2[1], a2[0], a2[1]);
        else {
          for (var s2 = t2; s2 < e2; s2++)
            this.paintVertexArray.emplace(s2, r2, n2);
          this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
        }
      }, Ma.prototype.upload = function(t2) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Ma.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }, Ma.prototype.setUniform = function(t2, e2) {
        var r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = p2(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
        t2.set(n2);
      }, Ma.prototype.getBinding = function(t2, e2, r2) {
        return new ba(t2, e2);
      };
      var Ba = function(t2, e2, r2, n2, i2, a2) {
        this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
      };
      Ba.prototype.populatePaintArray = function(t2, e2, r2) {
        var n2 = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
      }, Ba.prototype.updatePaintArray = function(t2, e2, r2, n2, i2) {
        this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
      }, Ba.prototype._setPaintValues = function(t2, e2, r2, n2) {
        if (n2 && r2) {
          var i2 = n2[r2.min], a2 = n2[r2.mid], o2 = n2[r2.max];
          if (i2 && a2 && o2)
            for (var s2 = t2; s2 < e2; s2++)
              this.zoomInPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], i2.tl[0], i2.tl[1], i2.br[0], i2.br[1], a2.pixelRatio, i2.pixelRatio), this.zoomOutPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], a2.pixelRatio, o2.pixelRatio);
        }
      }, Ba.prototype.upload = function(t2) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, la.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, la.members, this.expression.isStateDependent));
      }, Ba.prototype.destroy = function() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      };
      var Ta = function(t2, e2, r2) {
        this.binders = {}, this._buffers = [];
        var n2 = [];
        for (var i2 in t2.paint._values)
          if (r2(i2)) {
            var a2 = t2.paint.get(i2);
            if (a2 instanceof yi && Tr(a2.property.specification)) {
              var o2 = Fa(i2, t2.type), s2 = a2.value, u2 = a2.property.specification.type, l2 = a2.property.useIntegerZoom, p3 = a2.property.specification["property-type"], c3 = "cross-faded" === p3 || "cross-faded-data-driven" === p3;
              if ("constant" === s2.kind)
                this.binders[i2] = c3 ? new Ea(s2.value, o2) : new Ca(s2.value, o2, u2), n2.push("/u_" + i2);
              else if ("source" === s2.kind || c3) {
                var h3 = Da(i2, u2, "source");
                this.binders[i2] = c3 ? new Ba(s2, u2, l2, e2, h3, t2.id) : new Pa(s2, o2, u2, h3), n2.push("/a_" + i2);
              } else {
                var f2 = Da(i2, u2, "composite");
                this.binders[i2] = new Ma(s2, o2, u2, l2, e2, f2), n2.push("/z_" + i2);
              }
            }
          }
        this.cacheKey = n2.sort().join("");
      };
      Ta.prototype.getMaxValue = function(t2) {
        var e2 = this.binders[t2];
        return e2 instanceof Pa || e2 instanceof Ma ? e2.maxValue : 0;
      }, Ta.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2) {
        for (var a2 in this.binders) {
          var o2 = this.binders[a2];
          (o2 instanceof Pa || o2 instanceof Ma || o2 instanceof Ba) && o2.populatePaintArray(t2, e2, r2, n2, i2);
        }
      }, Ta.prototype.setConstantPatternPositions = function(t2, e2) {
        for (var r2 in this.binders) {
          var n2 = this.binders[r2];
          n2 instanceof Ea && n2.setConstantPatternPositions(t2, e2);
        }
      }, Ta.prototype.updatePaintArrays = function(t2, e2, r2, n2, i2) {
        var a2 = false;
        for (var o2 in t2)
          for (var s2 = 0, u2 = e2.getPositions(o2); s2 < u2.length; s2 += 1) {
            var l2 = u2[s2], p3 = r2.feature(l2.index);
            for (var c3 in this.binders) {
              var h3 = this.binders[c3];
              if ((h3 instanceof Pa || h3 instanceof Ma || h3 instanceof Ba) && true === h3.expression.isStateDependent) {
                var f2 = n2.paint.get(c3);
                h3.expression = f2.value, h3.updatePaintArray(l2.start, l2.end, p3, t2[o2], i2), a2 = true;
              }
            }
          }
        return a2;
      }, Ta.prototype.defines = function() {
        var t2 = [];
        for (var e2 in this.binders) {
          var r2 = this.binders[e2];
          (r2 instanceof Ca || r2 instanceof Ea) && t2.push.apply(t2, r2.uniformNames.map(function(t3) {
            return "#define HAS_UNIFORM_" + t3;
          }));
        }
        return t2;
      }, Ta.prototype.getBinderAttributes = function() {
        var t2 = [];
        for (var e2 in this.binders) {
          var r2 = this.binders[e2];
          if (r2 instanceof Pa || r2 instanceof Ma)
            for (var n2 = 0; n2 < r2.paintVertexAttributes.length; n2++)
              t2.push(r2.paintVertexAttributes[n2].name);
          else if (r2 instanceof Ba)
            for (var i2 = 0; i2 < la.members.length; i2++)
              t2.push(la.members[i2].name);
        }
        return t2;
      }, Ta.prototype.getBinderUniforms = function() {
        var t2 = [];
        for (var e2 in this.binders) {
          var r2 = this.binders[e2];
          if (r2 instanceof Ca || r2 instanceof Ea || r2 instanceof Ma)
            for (var n2 = 0, i2 = r2.uniformNames; n2 < i2.length; n2 += 1)
              t2.push(i2[n2]);
        }
        return t2;
      }, Ta.prototype.getPaintVertexBuffers = function() {
        return this._buffers;
      }, Ta.prototype.getUniforms = function(t2, e2) {
        var r2 = [];
        for (var n2 in this.binders) {
          var i2 = this.binders[n2];
          if (i2 instanceof Ca || i2 instanceof Ea || i2 instanceof Ma)
            for (var a2 = 0, o2 = i2.uniformNames; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2];
              if (e2[s2]) {
                var u2 = i2.getBinding(t2, e2[s2], s2);
                r2.push({ name: s2, property: n2, binding: u2 });
              }
            }
        }
        return r2;
      }, Ta.prototype.setUniforms = function(t2, e2, r2, n2) {
        for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1) {
          var o2 = a2[i2], s2 = o2.name, u2 = o2.property;
          this.binders[u2].setUniform(o2.binding, n2, r2.get(u2), s2);
        }
      }, Ta.prototype.updatePaintBuffers = function(t2) {
        for (var e2 in this._buffers = [], this.binders) {
          var r2 = this.binders[e2];
          if (t2 && r2 instanceof Ba) {
            var n2 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
            n2 && this._buffers.push(n2);
          } else
            (r2 instanceof Pa || r2 instanceof Ma) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
        }
      }, Ta.prototype.upload = function(t2) {
        for (var e2 in this.binders) {
          var r2 = this.binders[e2];
          (r2 instanceof Pa || r2 instanceof Ma || r2 instanceof Ba) && r2.upload(t2);
        }
        this.updatePaintBuffers();
      }, Ta.prototype.destroy = function() {
        for (var t2 in this.binders) {
          var e2 = this.binders[t2];
          (e2 instanceof Pa || e2 instanceof Ma || e2 instanceof Ba) && e2.destroy();
        }
      };
      var Va = function(t2, e2, r2) {
        void 0 === r2 && (r2 = function() {
          return true;
        }), this.programConfigurations = {};
        for (var n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          this.programConfigurations[a2.id] = new Ta(a2, e2, r2);
        }
        this.needsUpload = false, this._featureMap = new ya(), this._bufferOffset = 0;
      };
      function Fa(t2, e2) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(e2 + "-", "").replace(/-/g, "_")];
      }
      function Da(t2, e2, r2) {
        var n2 = { color: { source: Bi, composite: Hi }, number: { source: Ki, composite: Bi } }, i2 = function(t3) {
          return { "line-pattern": { source: Ti, composite: Ti }, "fill-pattern": { source: Ti, composite: Ti }, "fill-extrusion-pattern": { source: Ti, composite: Ti } }[t3];
        }(t2);
        return i2 && i2[r2] || n2[e2][r2];
      }
      Va.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2, a2) {
        for (var o2 in this.programConfigurations)
          this.programConfigurations[o2].populatePaintArrays(t2, e2, n2, i2, a2);
        void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
      }, Va.prototype.updatePaintArrays = function(t2, e2, r2, n2) {
        for (var i2 = 0, a2 = r2; i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          this.needsUpload = this.programConfigurations[o2.id].updatePaintArrays(t2, this._featureMap, e2, o2, n2) || this.needsUpload;
        }
      }, Va.prototype.get = function(t2) {
        return this.programConfigurations[t2];
      }, Va.prototype.upload = function(t2) {
        if (this.needsUpload) {
          for (var e2 in this.programConfigurations)
            this.programConfigurations[e2].upload(t2);
          this.needsUpload = false;
        }
      }, Va.prototype.destroy = function() {
        for (var t2 in this.programConfigurations)
          this.programConfigurations[t2].destroy();
      }, On("ConstantBinder", Ca), On("CrossFadedConstantBinder", Ea), On("SourceExpressionBinder", Pa), On("CrossFadedCompositeBinder", Ba), On("CompositeExpressionBinder", Ma), On("ProgramConfiguration", Ta, { omit: ["_buffers"] }), On("ProgramConfigurationSet", Va);
      var La = Math.pow(2, 14) - 1, Oa = -La - 1;
      function Ra(t2) {
        for (var e2 = 8192 / t2.extent, r2 = t2.loadGeometry(), n2 = 0; n2 < r2.length; n2++)
          for (var i2 = r2[n2], a2 = 0; a2 < i2.length; a2++) {
            var o2 = i2[a2], s2 = Math.round(o2.x * e2), u2 = Math.round(o2.y * e2);
            o2.x = p2(s2, Oa, La), o2.y = p2(u2, Oa, La), (s2 < o2.x || s2 > o2.x + 1 || u2 < o2.y || u2 > o2.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        return r2;
      }
      function Ua(t2, e2) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ra(t2) : [] };
      }
      function ja(t2, e2, r2, n2, i2) {
        t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }
      var qa = function(t2) {
        this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
          return t3.id;
        }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.segments = new sa(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter(function(t3) {
          return t3.isStateDependent();
        }).map(function(t3) {
          return t3.id;
        });
      };
      function Na(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          if (Wa(e2, t2[r2]))
            return true;
        for (var n2 = 0; n2 < e2.length; n2++)
          if (Wa(t2, e2[n2]))
            return true;
        return !!Xa(t2, e2);
      }
      function Ka(t2, e2, r2) {
        return !!Wa(t2, e2) || !!Ha(e2, t2, r2);
      }
      function Ga(t2, e2) {
        if (1 === t2.length)
          return $a(e2, t2[0]);
        for (var r2 = 0; r2 < e2.length; r2++)
          for (var n2 = e2[r2], i2 = 0; i2 < n2.length; i2++)
            if (Wa(t2, n2[i2]))
              return true;
        for (var a2 = 0; a2 < t2.length; a2++)
          if ($a(e2, t2[a2]))
            return true;
        for (var o2 = 0; o2 < e2.length; o2++)
          if (Xa(t2, e2[o2]))
            return true;
        return false;
      }
      function Za(t2, e2, r2) {
        if (t2.length > 1) {
          if (Xa(t2, e2))
            return true;
          for (var n2 = 0; n2 < e2.length; n2++)
            if (Ha(e2[n2], t2, r2))
              return true;
        }
        for (var i2 = 0; i2 < t2.length; i2++)
          if (Ha(t2[i2], e2, r2))
            return true;
        return false;
      }
      function Xa(t2, e2) {
        if (0 === t2.length || 0 === e2.length)
          return false;
        for (var r2 = 0; r2 < t2.length - 1; r2++)
          for (var n2 = t2[r2], i2 = t2[r2 + 1], a2 = 0; a2 < e2.length - 1; a2++)
            if (Ja(n2, i2, e2[a2], e2[a2 + 1]))
              return true;
        return false;
      }
      function Ja(t2, e2, r2, n2) {
        return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
      }
      function Ha(t2, e2, r2) {
        var n2 = r2 * r2;
        if (1 === e2.length)
          return t2.distSqr(e2[0]) < n2;
        for (var i2 = 1; i2 < e2.length; i2++)
          if (Ya(t2, e2[i2 - 1], e2[i2]) < n2)
            return true;
        return false;
      }
      function Ya(t2, e2, r2) {
        var n2 = e2.distSqr(r2);
        if (0 === n2)
          return t2.distSqr(e2);
        var i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function $a(t2, e2) {
        for (var r2, n2, i2, a2 = false, o2 = 0; o2 < t2.length; o2++)
          for (var s2 = 0, u2 = (r2 = t2[o2]).length - 1; s2 < r2.length; u2 = s2++)
            (n2 = r2[s2]).y > e2.y != (i2 = r2[u2]).y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (a2 = !a2);
        return a2;
      }
      function Wa(t2, e2) {
        for (var r2 = false, n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
          var a2 = t2[n2], o2 = t2[i2];
          a2.y > e2.y != o2.y > e2.y && e2.x < (o2.x - a2.x) * (e2.y - a2.y) / (o2.y - a2.y) + a2.x && (r2 = !r2);
        }
        return r2;
      }
      function Qa(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        var a2 = S(t2, e2, r2[0]);
        return a2 !== S(t2, e2, r2[1]) || a2 !== S(t2, e2, r2[2]) || a2 !== S(t2, e2, r2[3]);
      }
      function to(t2, e2, r2) {
        var n2 = e2.paint.get(t2).value;
        return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function eo(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function ro(t2, e2, r2, n2, a2) {
        if (!e2[0] && !e2[1])
          return t2;
        var o2 = i.convert(e2)._mult(a2);
        "viewport" === r2 && o2._rotate(-n2);
        for (var s2 = [], u2 = 0; u2 < t2.length; u2++)
          s2.push(t2[u2].sub(o2));
        return s2;
      }
      qa.prototype.populate = function(t2, e2, r2) {
        var n2 = this.layers[0], i2 = [], a2 = null;
        "circle" === n2.type && (a2 = n2.layout.get("circle-sort-key"));
        for (var o2 = 0, s2 = t2; o2 < s2.length; o2 += 1) {
          var u2 = s2[o2], l2 = u2.feature, p3 = u2.id, c3 = u2.index, h3 = u2.sourceLayerIndex, f2 = this.layers[0]._featureFilter.needGeometry, y3 = Ua(l2, f2);
          if (this.layers[0]._featureFilter.filter(new si(this.zoom), y3, r2)) {
            var d2 = a2 ? a2.evaluate(y3, {}, r2) : void 0, m2 = { id: p3, properties: l2.properties, type: l2.type, sourceLayerIndex: h3, index: c3, geometry: f2 ? y3.geometry : Ra(l2), patterns: {}, sortKey: d2 };
            i2.push(m2);
          }
        }
        a2 && i2.sort(function(t3, e3) {
          return t3.sortKey - e3.sortKey;
        });
        for (var v3 = 0, g2 = i2; v3 < g2.length; v3 += 1) {
          var x2 = g2[v3], b2 = x2.geometry, w2 = x2.index, _24 = x2.sourceLayerIndex, A3 = t2[w2].feature;
          this.addFeature(x2, b2, w2, r2), e2.featureIndex.insert(A3, b2, w2, _24, this.index);
        }
      }, qa.prototype.update = function(t2, e2, r2) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
      }, qa.prototype.isEmpty = function() {
        return 0 === this.layoutVertexArray.length;
      }, qa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, qa.prototype.upload = function(t2) {
        this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, oa), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
      }, qa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, qa.prototype.addFeature = function(t2, e2, r2, n2) {
        for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1)
          for (var o2 = 0, s2 = a2[i2]; o2 < s2.length; o2 += 1) {
            var u2 = s2[o2], l2 = u2.x, p3 = u2.y;
            if (!(l2 < 0 || l2 >= 8192 || p3 < 0 || p3 >= 8192)) {
              var c3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), h3 = c3.vertexLength;
              ja(this.layoutVertexArray, l2, p3, -1, -1), ja(this.layoutVertexArray, l2, p3, 1, -1), ja(this.layoutVertexArray, l2, p3, 1, 1), ja(this.layoutVertexArray, l2, p3, -1, 1), this.indexArray.emplaceBack(h3, h3 + 1, h3 + 2), this.indexArray.emplaceBack(h3, h3 + 3, h3 + 2), c3.vertexLength += 4, c3.primitiveLength += 2;
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
      }, On("CircleBucket", qa, { omit: ["layers"] });
      var no = new wi({ "circle-sort-key": new vi(Et.layout_circle["circle-sort-key"]) }), io = { paint: new wi({ "circle-radius": new vi(Et.paint_circle["circle-radius"]), "circle-color": new vi(Et.paint_circle["circle-color"]), "circle-blur": new vi(Et.paint_circle["circle-blur"]), "circle-opacity": new vi(Et.paint_circle["circle-opacity"]), "circle-translate": new mi(Et.paint_circle["circle-translate"]), "circle-translate-anchor": new mi(Et.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new mi(Et.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new mi(Et.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new vi(Et.paint_circle["circle-stroke-width"]), "circle-stroke-color": new vi(Et.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new vi(Et.paint_circle["circle-stroke-opacity"]) }), layout: no }, ao = "undefined" != typeof Float32Array ? Float32Array : Array;
      function oo(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function so(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p3 = e2[7], c3 = e2[8], h3 = e2[9], f2 = e2[10], y3 = e2[11], d2 = e2[12], m2 = e2[13], v3 = e2[14], g2 = e2[15], x2 = r2[0], b2 = r2[1], w2 = r2[2], _24 = r2[3];
        return t2[0] = x2 * n2 + b2 * s2 + w2 * c3 + _24 * d2, t2[1] = x2 * i2 + b2 * u2 + w2 * h3 + _24 * m2, t2[2] = x2 * a2 + b2 * l2 + w2 * f2 + _24 * v3, t2[3] = x2 * o2 + b2 * p3 + w2 * y3 + _24 * g2, t2[4] = (x2 = r2[4]) * n2 + (b2 = r2[5]) * s2 + (w2 = r2[6]) * c3 + (_24 = r2[7]) * d2, t2[5] = x2 * i2 + b2 * u2 + w2 * h3 + _24 * m2, t2[6] = x2 * a2 + b2 * l2 + w2 * f2 + _24 * v3, t2[7] = x2 * o2 + b2 * p3 + w2 * y3 + _24 * g2, t2[8] = (x2 = r2[8]) * n2 + (b2 = r2[9]) * s2 + (w2 = r2[10]) * c3 + (_24 = r2[11]) * d2, t2[9] = x2 * i2 + b2 * u2 + w2 * h3 + _24 * m2, t2[10] = x2 * a2 + b2 * l2 + w2 * f2 + _24 * v3, t2[11] = x2 * o2 + b2 * p3 + w2 * y3 + _24 * g2, t2[12] = (x2 = r2[12]) * n2 + (b2 = r2[13]) * s2 + (w2 = r2[14]) * c3 + (_24 = r2[15]) * d2, t2[13] = x2 * i2 + b2 * u2 + w2 * h3 + _24 * m2, t2[14] = x2 * a2 + b2 * l2 + w2 * f2 + _24 * v3, t2[15] = x2 * o2 + b2 * p3 + w2 * y3 + _24 * g2, t2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = arguments, e2 = 0, r2 = arguments.length; r2--; )
          e2 += t2[r2] * t2[r2];
        return Math.sqrt(e2);
      });
      var uo, lo = so;
      function po(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * a2 + r2[12] * o2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * a2 + r2[13] * o2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * a2 + r2[14] * o2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * a2 + r2[15] * o2, t2;
      }
      uo = new ao(3), ao != Float32Array && (uo[0] = 0, uo[1] = 0, uo[2] = 0), function() {
        var t2 = new ao(4);
        ao != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0);
      }();
      var co = (function() {
        var t2 = new ao(2);
        ao != Float32Array && (t2[0] = 0, t2[1] = 0);
      }(), function(t2) {
        function e2(e3) {
          t2.call(this, e3, io);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
          return new qa(t3);
        }, e2.prototype.queryRadius = function(t3) {
          var e3 = t3;
          return to("circle-radius", this, e3) + to("circle-stroke-width", this, e3) + eo(this.paint.get("circle-translate"));
        }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2, s2) {
          for (var u2 = ro(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, o2), l2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), p3 = "map" === this.paint.get("circle-pitch-alignment"), c3 = p3 ? u2 : function(t4, e4) {
            return t4.map(function(t5) {
              return ho(t5, e4);
            });
          }(u2, s2), h3 = p3 ? l2 * o2 : l2, f2 = 0, y3 = n2; f2 < y3.length; f2 += 1)
            for (var d2 = 0, m2 = y3[f2]; d2 < m2.length; d2 += 1) {
              var v3 = m2[d2], g2 = p3 ? v3 : ho(v3, s2), x2 = h3, b2 = po([], [v3.x, v3.y, 0, 1], s2);
              if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x2 *= b2[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x2 *= a2.cameraToCenterDistance / b2[3]), Ka(c3, g2, x2))
                return true;
            }
          return false;
        }, e2;
      }(_i));
      function ho(t2, e2) {
        var r2 = po([], [t2.x, t2.y, 0, 1], e2);
        return new i(r2[0] / r2[3], r2[1] / r2[3]);
      }
      var fo = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(qa);
      function yo(t2, e2, r2, n2) {
        var i2 = e2.width, a2 = e2.height;
        if (n2) {
          if (n2 instanceof Uint8ClampedArray)
            n2 = new Uint8Array(n2.buffer);
          else if (n2.length !== i2 * a2 * r2)
            throw new RangeError("mismatched image size");
        } else
          n2 = new Uint8Array(i2 * a2 * r2);
        return t2.width = i2, t2.height = a2, t2.data = n2, t2;
      }
      function mo(t2, e2, r2) {
        var n2 = e2.width, i2 = e2.height;
        if (n2 !== t2.width || i2 !== t2.height) {
          var a2 = yo({}, { width: n2, height: i2 }, r2);
          vo(t2, a2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = a2.data;
        }
      }
      function vo(t2, e2, r2, n2, i2, a2) {
        if (0 === i2.width || 0 === i2.height)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        for (var o2 = t2.data, s2 = e2.data, u2 = 0; u2 < i2.height; u2++)
          for (var l2 = ((r2.y + u2) * t2.width + r2.x) * a2, p3 = ((n2.y + u2) * e2.width + n2.x) * a2, c3 = 0; c3 < i2.width * a2; c3++)
            s2[p3 + c3] = o2[l2 + c3];
        return e2;
      }
      On("HeatmapBucket", fo, { omit: ["layers"] });
      var go = function(t2, e2) {
        yo(this, t2, 1, e2);
      };
      go.prototype.resize = function(t2) {
        mo(this, t2, 1);
      }, go.prototype.clone = function() {
        return new go({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, go.copy = function(t2, e2, r2, n2, i2) {
        vo(t2, e2, r2, n2, i2, 1);
      };
      var xo = function(t2, e2) {
        yo(this, t2, 4, e2);
      };
      xo.prototype.resize = function(t2) {
        mo(this, t2, 4);
      }, xo.prototype.replace = function(t2, e2) {
        e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
      }, xo.prototype.clone = function() {
        return new xo({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, xo.copy = function(t2, e2, r2, n2, i2) {
        vo(t2, e2, r2, n2, i2, 4);
      }, On("AlphaImage", go), On("RGBAImage", xo);
      var bo = { paint: new wi({ "heatmap-radius": new vi(Et.paint_heatmap["heatmap-radius"]), "heatmap-weight": new vi(Et.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new mi(Et.paint_heatmap["heatmap-intensity"]), "heatmap-color": new bi(Et.paint_heatmap["heatmap-color"]), "heatmap-opacity": new mi(Et.paint_heatmap["heatmap-opacity"]) }) };
      function wo(t2) {
        var e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new xo({ width: r2, height: n2 }), a2 = function(r3, n3, a3) {
          e2[t2.evaluationKey] = a3;
          var o3 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * o3.r / o3.a), i2.data[r3 + n3 + 1] = Math.floor(255 * o3.g / o3.a), i2.data[r3 + n3 + 2] = Math.floor(255 * o3.b / o3.a), i2.data[r3 + n3 + 3] = Math.floor(255 * o3.a);
        };
        if (t2.clips)
          for (var o2 = 0, s2 = 0; o2 < n2; ++o2, s2 += 4 * r2)
            for (var u2 = 0, l2 = 0; u2 < r2; u2++, l2 += 4) {
              var p3 = u2 / (r2 - 1), c3 = t2.clips[o2];
              a2(s2, l2, c3.start * (1 - p3) + c3.end * p3);
            }
        else
          for (var h3 = 0, f2 = 0; h3 < r2; h3++, f2 += 4)
            a2(0, f2, h3 / (r2 - 1));
        return i2;
      }
      var _o = function(t2) {
        function e2(e3) {
          t2.call(this, e3, bo), this._updateColorRamp();
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
          return new fo(t3);
        }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
          "heatmap-color" === t3 && this._updateColorRamp();
        }, e2.prototype._updateColorRamp = function() {
          this.colorRamp = wo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }, e2.prototype.resize = function() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }, e2.prototype.queryRadius = function() {
          return 0;
        }, e2.prototype.queryIntersectsFeature = function() {
          return false;
        }, e2.prototype.hasOffscreenPass = function() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }, e2;
      }(_i), Ao = { paint: new wi({ "hillshade-illumination-direction": new mi(Et.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new mi(Et.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new mi(Et.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new mi(Et.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new mi(Et.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new mi(Et.paint_hillshade["hillshade-accent-color"]) }) }, So = function(t2) {
        function e2(e3) {
          t2.call(this, e3, Ao);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.hasOffscreenPass = function() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }, e2;
      }(_i), ko = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Io = Co, zo = Co;
      function Co(t2, e2, r2) {
        r2 = r2 || 2;
        var n2, i2, a2, o2, s2, u2, l2, p3 = e2 && e2.length, c3 = p3 ? e2[0] * r2 : t2.length, h3 = Eo(t2, 0, c3, r2, true), f2 = [];
        if (!h3 || h3.next === h3.prev)
          return f2;
        if (p3 && (h3 = function(t3, e3, r3, n3) {
          var i3, a3, o3, s3 = [];
          for (i3 = 0, a3 = e3.length; i3 < a3; i3++)
            (o3 = Eo(t3, e3[i3] * n3, i3 < a3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === o3.next && (o3.steiner = true), s3.push(Uo(o3));
          for (s3.sort(Do), i3 = 0; i3 < s3.length; i3++)
            Lo(s3[i3], r3), r3 = Po(r3, r3.next);
          return r3;
        }(t2, e2, h3, r2)), t2.length > 80 * r2) {
          n2 = a2 = t2[0], i2 = o2 = t2[1];
          for (var y3 = r2; y3 < c3; y3 += r2)
            (s2 = t2[y3]) < n2 && (n2 = s2), (u2 = t2[y3 + 1]) < i2 && (i2 = u2), s2 > a2 && (a2 = s2), u2 > o2 && (o2 = u2);
          l2 = 0 !== (l2 = Math.max(a2 - n2, o2 - i2)) ? 1 / l2 : 0;
        }
        return Mo(h3, f2, r2, n2, i2, l2), f2;
      }
      function Eo(t2, e2, r2, n2, i2) {
        var a2, o2;
        if (i2 === Qo(t2, e2, r2, n2) > 0)
          for (a2 = e2; a2 < r2; a2 += n2)
            o2 = Yo(a2, t2[a2], t2[a2 + 1], o2);
        else
          for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
            o2 = Yo(a2, t2[a2], t2[a2 + 1], o2);
        return o2 && Ko(o2, o2.next) && ($o(o2), o2 = o2.next), o2;
      }
      function Po(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        var r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !Ko(n2, n2.next) && 0 !== No(n2.prev, n2, n2.next))
            n2 = n2.next;
          else {
            if ($o(n2), (n2 = e2 = n2.prev) === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function Mo(t2, e2, r2, n2, i2, a2, o2) {
        if (t2) {
          !o2 && a2 && function(t3, e3, r3, n3) {
            var i3 = t3;
            do {
              null === i3.z && (i3.z = Ro(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              var e4, r4, n4, i4, a3, o3, s3, u3, l3 = 1;
              do {
                for (r4 = t4, t4 = null, a3 = null, o3 = 0; r4; ) {
                  for (o3++, n4 = r4, s3 = 0, e4 = 0; e4 < l3 && (s3++, n4 = n4.nextZ); e4++)
                    ;
                  for (u3 = l3; s3 > 0 || u3 > 0 && n4; )
                    0 !== s3 && (0 === u3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, s3--) : (i4 = n4, n4 = n4.nextZ, u3--), a3 ? a3.nextZ = i4 : t4 = i4, i4.prevZ = a3, a3 = i4;
                  r4 = n4;
                }
                a3.nextZ = null, l3 *= 2;
              } while (o3 > 1);
            }(i3);
          }(t2, n2, i2, a2);
          for (var s2, u2, l2 = t2; t2.prev !== t2.next; )
            if (s2 = t2.prev, u2 = t2.next, a2 ? To(t2, n2, i2, a2) : Bo(t2))
              e2.push(s2.i / r2), e2.push(t2.i / r2), e2.push(u2.i / r2), $o(t2), t2 = u2.next, l2 = u2.next;
            else if ((t2 = u2) === l2) {
              o2 ? 1 === o2 ? Mo(t2 = Vo(Po(t2), e2, r2), e2, r2, n2, i2, a2, 2) : 2 === o2 && Fo(t2, e2, r2, n2, i2, a2) : Mo(Po(t2), e2, r2, n2, i2, a2, 1);
              break;
            }
        }
      }
      function Bo(t2) {
        var e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (No(e2, r2, n2) >= 0)
          return false;
        for (var i2 = t2.next.next; i2 !== t2.prev; ) {
          if (jo(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && No(i2.prev, i2, i2.next) >= 0)
            return false;
          i2 = i2.next;
        }
        return true;
      }
      function To(t2, e2, r2, n2) {
        var i2 = t2.prev, a2 = t2, o2 = t2.next;
        if (No(i2, a2, o2) >= 0)
          return false;
        for (var s2 = i2.x > a2.x ? i2.x > o2.x ? i2.x : o2.x : a2.x > o2.x ? a2.x : o2.x, u2 = i2.y > a2.y ? i2.y > o2.y ? i2.y : o2.y : a2.y > o2.y ? a2.y : o2.y, l2 = Ro(i2.x < a2.x ? i2.x < o2.x ? i2.x : o2.x : a2.x < o2.x ? a2.x : o2.x, i2.y < a2.y ? i2.y < o2.y ? i2.y : o2.y : a2.y < o2.y ? a2.y : o2.y, e2, r2, n2), p3 = Ro(s2, u2, e2, r2, n2), c3 = t2.prevZ, h3 = t2.nextZ; c3 && c3.z >= l2 && h3 && h3.z <= p3; ) {
          if (c3 !== t2.prev && c3 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, c3.x, c3.y) && No(c3.prev, c3, c3.next) >= 0)
            return false;
          if (c3 = c3.prevZ, h3 !== t2.prev && h3 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, h3.x, h3.y) && No(h3.prev, h3, h3.next) >= 0)
            return false;
          h3 = h3.nextZ;
        }
        for (; c3 && c3.z >= l2; ) {
          if (c3 !== t2.prev && c3 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, c3.x, c3.y) && No(c3.prev, c3, c3.next) >= 0)
            return false;
          c3 = c3.prevZ;
        }
        for (; h3 && h3.z <= p3; ) {
          if (h3 !== t2.prev && h3 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, h3.x, h3.y) && No(h3.prev, h3, h3.next) >= 0)
            return false;
          h3 = h3.nextZ;
        }
        return true;
      }
      function Vo(t2, e2, r2) {
        var n2 = t2;
        do {
          var i2 = n2.prev, a2 = n2.next.next;
          !Ko(i2, a2) && Go(i2, n2, n2.next, a2) && Jo(i2, a2) && Jo(a2, i2) && (e2.push(i2.i / r2), e2.push(n2.i / r2), e2.push(a2.i / r2), $o(n2), $o(n2.next), n2 = t2 = a2), n2 = n2.next;
        } while (n2 !== t2);
        return Po(n2);
      }
      function Fo(t2, e2, r2, n2, i2, a2) {
        var o2 = t2;
        do {
          for (var s2 = o2.next.next; s2 !== o2.prev; ) {
            if (o2.i !== s2.i && qo(o2, s2)) {
              var u2 = Ho(o2, s2);
              return o2 = Po(o2, o2.next), u2 = Po(u2, u2.next), Mo(o2, e2, r2, n2, i2, a2), void Mo(u2, e2, r2, n2, i2, a2);
            }
            s2 = s2.next;
          }
          o2 = o2.next;
        } while (o2 !== t2);
      }
      function Do(t2, e2) {
        return t2.x - e2.x;
      }
      function Lo(t2, e2) {
        if (e2 = function(t3, e3) {
          var r3, n2 = e3, i2 = t3.x, a2 = t3.y, o2 = -1 / 0;
          do {
            if (a2 <= n2.y && a2 >= n2.next.y && n2.next.y !== n2.y) {
              var s2 = n2.x + (a2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
              if (s2 <= i2 && s2 > o2) {
                if (o2 = s2, s2 === i2) {
                  if (a2 === n2.y)
                    return n2;
                  if (a2 === n2.next.y)
                    return n2.next;
                }
                r3 = n2.x < n2.next.x ? n2 : n2.next;
              }
            }
            n2 = n2.next;
          } while (n2 !== e3);
          if (!r3)
            return null;
          if (i2 === o2)
            return r3;
          var u2, l2 = r3, p3 = r3.x, c3 = r3.y, h3 = 1 / 0;
          n2 = r3;
          do {
            i2 >= n2.x && n2.x >= p3 && i2 !== n2.x && jo(a2 < c3 ? i2 : o2, a2, p3, c3, a2 < c3 ? o2 : i2, a2, n2.x, n2.y) && (u2 = Math.abs(a2 - n2.y) / (i2 - n2.x), Jo(n2, t3) && (u2 < h3 || u2 === h3 && (n2.x > r3.x || n2.x === r3.x && Oo(r3, n2))) && (r3 = n2, h3 = u2)), n2 = n2.next;
          } while (n2 !== l2);
          return r3;
        }(t2, e2)) {
          var r2 = Ho(e2, t2);
          Po(e2, e2.next), Po(r2, r2.next);
        }
      }
      function Oo(t2, e2) {
        return No(t2.prev, t2, e2.prev) < 0 && No(e2.next, t2, t2.next) < 0;
      }
      function Ro(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function Uo(t2) {
        var e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function jo(t2, e2, r2, n2, i2, a2, o2, s2) {
        return (i2 - o2) * (e2 - s2) - (t2 - o2) * (a2 - s2) >= 0 && (t2 - o2) * (n2 - s2) - (r2 - o2) * (e2 - s2) >= 0 && (r2 - o2) * (a2 - s2) - (i2 - o2) * (n2 - s2) >= 0;
      }
      function qo(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          var r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Go(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (Jo(t2, e2) && Jo(e2, t2) && function(t3, e3) {
          var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, a2 = (t3.y + e3.y) / 2;
          do {
            r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (No(t2.prev, t2, e2.prev) || No(t2, e2.prev, e2)) || Ko(t2, e2) && No(t2.prev, t2, t2.next) > 0 && No(e2.prev, e2, e2.next) > 0);
      }
      function No(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function Ko(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function Go(t2, e2, r2, n2) {
        var i2 = Xo(No(t2, e2, r2)), a2 = Xo(No(t2, e2, n2)), o2 = Xo(No(r2, n2, t2)), s2 = Xo(No(r2, n2, e2));
        return i2 !== a2 && o2 !== s2 || !(0 !== i2 || !Zo(t2, r2, e2)) || !(0 !== a2 || !Zo(t2, n2, e2)) || !(0 !== o2 || !Zo(r2, t2, n2)) || !(0 !== s2 || !Zo(r2, e2, n2));
      }
      function Zo(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function Xo(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Jo(t2, e2) {
        return No(t2.prev, t2, t2.next) < 0 ? No(t2, e2, t2.next) >= 0 && No(t2, t2.prev, e2) >= 0 : No(t2, e2, t2.prev) < 0 || No(t2, t2.next, e2) < 0;
      }
      function Ho(t2, e2) {
        var r2 = new Wo(t2.i, t2.x, t2.y), n2 = new Wo(e2.i, e2.x, e2.y), i2 = t2.next, a2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
      }
      function Yo(t2, e2, r2, n2) {
        var i2 = new Wo(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function $o(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Wo(t2, e2, r2) {
        this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Qo(t2, e2, r2, n2) {
        for (var i2 = 0, a2 = e2, o2 = r2 - n2; a2 < r2; a2 += n2)
          i2 += (t2[o2] - t2[a2]) * (t2[a2 + 1] + t2[o2 + 1]), o2 = a2;
        return i2;
      }
      function ts(t2, e2, r2, n2, i2) {
        !function t3(e3, r3, n3, i3, a2) {
          for (; i3 > n3; ) {
            if (i3 - n3 > 600) {
              var o2 = i3 - n3 + 1, s2 = r3 - n3 + 1, u2 = Math.log(o2), l2 = 0.5 * Math.exp(2 * u2 / 3), p3 = 0.5 * Math.sqrt(u2 * l2 * (o2 - l2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1);
              t3(e3, r3, Math.max(n3, Math.floor(r3 - s2 * l2 / o2 + p3)), Math.min(i3, Math.floor(r3 + (o2 - s2) * l2 / o2 + p3)), a2);
            }
            var c3 = e3[r3], h3 = n3, f2 = i3;
            for (es(e3, n3, r3), a2(e3[i3], c3) > 0 && es(e3, n3, i3); h3 < f2; ) {
              for (es(e3, h3, f2), h3++, f2--; a2(e3[h3], c3) < 0; )
                h3++;
              for (; a2(e3[f2], c3) > 0; )
                f2--;
            }
            0 === a2(e3[n3], c3) ? es(e3, n3, f2) : es(e3, ++f2, i3), f2 <= r3 && (n3 = f2 + 1), r3 <= f2 && (i3 = f2 - 1);
          }
        }(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || rs);
      }
      function es(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function rs(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function ns(t2, e2) {
        var r2 = t2.length;
        if (r2 <= 1)
          return [t2];
        for (var n2, i2, a2 = [], o2 = 0; o2 < r2; o2++) {
          var s2 = k(t2[o2]);
          0 !== s2 && (t2[o2].area = Math.abs(s2), void 0 === i2 && (i2 = s2 < 0), i2 === s2 < 0 ? (n2 && a2.push(n2), n2 = [t2[o2]]) : n2.push(t2[o2]));
        }
        if (n2 && a2.push(n2), e2 > 1)
          for (var u2 = 0; u2 < a2.length; u2++)
            a2[u2].length <= e2 || (ts(a2[u2], e2, 1, a2[u2].length - 1, is2), a2[u2] = a2[u2].slice(0, e2));
        return a2;
      }
      function is2(t2, e2) {
        return e2.area - t2.area;
      }
      function as(t2, e2, r2) {
        for (var n2 = r2.patternDependencies, i2 = false, a2 = 0, o2 = e2; a2 < o2.length; a2 += 1) {
          var s2 = o2[a2].paint.get(t2 + "-pattern");
          s2.isConstant() || (i2 = true);
          var u2 = s2.constantOr(null);
          u2 && (i2 = true, n2[u2.to] = true, n2[u2.from] = true);
        }
        return i2;
      }
      function os(t2, e2, r2, n2, i2) {
        for (var a2 = i2.patternDependencies, o2 = 0, s2 = e2; o2 < s2.length; o2 += 1) {
          var u2 = s2[o2], l2 = u2.paint.get(t2 + "-pattern").value;
          if ("constant" !== l2.kind) {
            var p3 = l2.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), c3 = l2.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), h3 = l2.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
            c3 = c3 && c3.name ? c3.name : c3, h3 = h3 && h3.name ? h3.name : h3, a2[p3 = p3 && p3.name ? p3.name : p3] = true, a2[c3] = true, a2[h3] = true, r2.patterns[u2.id] = { min: p3, mid: c3, max: h3 };
          }
        }
        return r2;
      }
      Co.deviation = function(t2, e2, r2, n2) {
        var i2 = e2 && e2.length, a2 = Math.abs(Qo(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
        if (i2)
          for (var o2 = 0, s2 = e2.length; o2 < s2; o2++)
            a2 -= Math.abs(Qo(t2, e2[o2] * r2, o2 < s2 - 1 ? e2[o2 + 1] * r2 : t2.length, r2));
        var u2 = 0;
        for (o2 = 0; o2 < n2.length; o2 += 3) {
          var l2 = n2[o2] * r2, p3 = n2[o2 + 1] * r2, c3 = n2[o2 + 2] * r2;
          u2 += Math.abs((t2[l2] - t2[c3]) * (t2[p3 + 1] - t2[l2 + 1]) - (t2[l2] - t2[p3]) * (t2[c3 + 1] - t2[l2 + 1]));
        }
        return 0 === a2 && 0 === u2 ? 0 : Math.abs((u2 - a2) / a2);
      }, Co.flatten = function(t2) {
        for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
          for (var a2 = 0; a2 < t2[i2].length; a2++)
            for (var o2 = 0; o2 < e2; o2++)
              r2.vertices.push(t2[i2][a2][o2]);
          i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
        }
        return r2;
      }, Io.default = zo;
      var ss = function(t2) {
        this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
          return t3.id;
        }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.indexArray2 = new Xi(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.segments2 = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
          return t3.isStateDependent();
        }).map(function(t3) {
          return t3.id;
        });
      };
      ss.prototype.populate = function(t2, e2, r2) {
        this.hasPattern = as("fill", this.layers, e2);
        for (var n2 = this.layers[0].layout.get("fill-sort-key"), i2 = [], a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
          var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p3 = s2.index, c3 = s2.sourceLayerIndex, h3 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h3);
          if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
            var y3 = n2 ? n2.evaluate(f2, {}, r2, e2.availableImages) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c3, index: p3, geometry: h3 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y3 };
            i2.push(d2);
          }
        }
        n2 && i2.sort(function(t3, e3) {
          return t3.sortKey - e3.sortKey;
        });
        for (var m2 = 0, v3 = i2; m2 < v3.length; m2 += 1) {
          var g2 = v3[m2], x2 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
          if (this.hasPattern) {
            var _24 = os("fill", this.layers, g2, this.zoom, e2);
            this.patternFeatures.push(_24);
          } else
            this.addFeature(g2, x2, b2, r2, {});
          e2.featureIndex.insert(t2[b2].feature, x2, b2, w2, this.index);
        }
      }, ss.prototype.update = function(t2, e2, r2) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
      }, ss.prototype.addFeatures = function(t2, e2, r2) {
        for (var n2 = 0, i2 = this.patternFeatures; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          this.addFeature(a2, a2.geometry, a2.index, e2, r2);
        }
      }, ss.prototype.isEmpty = function() {
        return 0 === this.layoutVertexArray.length;
      }, ss.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, ss.prototype.upload = function(t2) {
        this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ko), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
      }, ss.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }, ss.prototype.addFeature = function(t2, e2, r2, n2, i2) {
        for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
          for (var s2 = o2[a2], u2 = 0, l2 = 0, p3 = s2; l2 < p3.length; l2 += 1)
            u2 += p3[l2].length;
          for (var c3 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray), h3 = c3.vertexLength, f2 = [], y3 = [], d2 = 0, m2 = s2; d2 < m2.length; d2 += 1) {
            var v3 = m2[d2];
            if (0 !== v3.length) {
              v3 !== s2[0] && y3.push(f2.length / 2);
              var g2 = this.segments2.prepareSegment(v3.length, this.layoutVertexArray, this.indexArray2), x2 = g2.vertexLength;
              this.layoutVertexArray.emplaceBack(v3[0].x, v3[0].y), this.indexArray2.emplaceBack(x2 + v3.length - 1, x2), f2.push(v3[0].x), f2.push(v3[0].y);
              for (var b2 = 1; b2 < v3.length; b2++)
                this.layoutVertexArray.emplaceBack(v3[b2].x, v3[b2].y), this.indexArray2.emplaceBack(x2 + b2 - 1, x2 + b2), f2.push(v3[b2].x), f2.push(v3[b2].y);
              g2.vertexLength += v3.length, g2.primitiveLength += v3.length;
            }
          }
          for (var w2 = Io(f2, y3), _24 = 0; _24 < w2.length; _24 += 3)
            this.indexArray.emplaceBack(h3 + w2[_24], h3 + w2[_24 + 1], h3 + w2[_24 + 2]);
          c3.vertexLength += u2, c3.primitiveLength += w2.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
      }, On("FillBucket", ss, { omit: ["layers", "patternFeatures"] });
      var us = new wi({ "fill-sort-key": new vi(Et.layout_fill["fill-sort-key"]) }), ls = { paint: new wi({ "fill-antialias": new mi(Et.paint_fill["fill-antialias"]), "fill-opacity": new vi(Et.paint_fill["fill-opacity"]), "fill-color": new vi(Et.paint_fill["fill-color"]), "fill-outline-color": new vi(Et.paint_fill["fill-outline-color"]), "fill-translate": new mi(Et.paint_fill["fill-translate"]), "fill-translate-anchor": new mi(Et.paint_fill["fill-translate-anchor"]), "fill-pattern": new gi(Et.paint_fill["fill-pattern"]) }), layout: us }, ps = function(t2) {
        function e2(e3) {
          t2.call(this, e3, ls);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
          t2.prototype.recalculate.call(this, e3, r2);
          var n2 = this.paint._values["fill-outline-color"];
          "constant" === n2.value.kind && void 0 === n2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }, e2.prototype.createBucket = function(t3) {
          return new ss(t3);
        }, e2.prototype.queryRadius = function() {
          return eo(this.paint.get("fill-translate"));
        }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2) {
          return Ga(ro(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, o2), n2);
        }, e2.prototype.isTileClipped = function() {
          return true;
        }, e2;
      }(_i), cs = Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, hs = fs;
      function fs(t2, e2, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(ys, this, e2);
      }
      function ys(t2, e2, r2) {
        1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
      }
      function ds(t2) {
        for (var e2, r2, n2 = 0, i2 = 0, a2 = t2.length, o2 = a2 - 1; i2 < a2; o2 = i2++)
          n2 += ((r2 = t2[o2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
        return n2;
      }
      fs.types = ["Unknown", "Point", "LineString", "Polygon"], fs.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, a2 = 0, o2 = 0, s2 = 0, u2 = []; t2.pos < r2; ) {
          if (a2 <= 0) {
            var l2 = t2.readVarint();
            n2 = 7 & l2, a2 = l2 >> 3;
          }
          if (a2--, 1 === n2 || 2 === n2)
            o2 += t2.readSVarint(), s2 += t2.readSVarint(), 1 === n2 && (e2 && u2.push(e2), e2 = []), e2.push(new i(o2, s2));
          else {
            if (7 !== n2)
              throw new Error("unknown command " + n2);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && u2.push(e2), u2;
      }, fs.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, a2 = 0, o2 = 1 / 0, s2 = -1 / 0, u2 = 1 / 0, l2 = -1 / 0; t2.pos < e2; ) {
          if (n2 <= 0) {
            var p3 = t2.readVarint();
            r2 = 7 & p3, n2 = p3 >> 3;
          }
          if (n2--, 1 === r2 || 2 === r2)
            (i2 += t2.readSVarint()) < o2 && (o2 = i2), i2 > s2 && (s2 = i2), (a2 += t2.readSVarint()) < u2 && (u2 = a2), a2 > l2 && (l2 = a2);
          else if (7 !== r2)
            throw new Error("unknown command " + r2);
        }
        return [o2, u2, s2, l2];
      }, fs.prototype.toGeoJSON = function(t2, e2, r2) {
        var n2, i2, a2 = this.extent * Math.pow(2, r2), o2 = this.extent * t2, s2 = this.extent * e2, u2 = this.loadGeometry(), l2 = fs.types[this.type];
        function p3(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [360 * (r3.x + o2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + s2) / a2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var c3 = [];
            for (n2 = 0; n2 < u2.length; n2++)
              c3[n2] = u2[n2][0];
            p3(u2 = c3);
            break;
          case 2:
            for (n2 = 0; n2 < u2.length; n2++)
              p3(u2[n2]);
            break;
          case 3:
            for (u2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], a3 = 0; a3 < e3; a3++) {
                var o3 = ds(t3[a3]);
                0 !== o3 && (void 0 === n3 && (n3 = o3 < 0), n3 === o3 < 0 ? (r3 && i3.push(r3), r3 = [t3[a3]]) : r3.push(t3[a3]));
              }
              return r3 && i3.push(r3), i3;
            }(u2), n2 = 0; n2 < u2.length; n2++)
              for (i2 = 0; i2 < u2[n2].length; i2++)
                p3(u2[n2][i2]);
        }
        1 === u2.length ? u2 = u2[0] : l2 = "Multi" + l2;
        var h3 = { type: "Feature", geometry: { type: l2, coordinates: u2 }, properties: this.properties };
        return "id" in this && (h3.id = this.id), h3;
      };
      var ms = vs;
      function vs(t2, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(gs, this, e2), this.length = this._features.length;
      }
      function gs(t2, e2, r2) {
        15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      function xs(t2, e2, r2) {
        if (3 === t2) {
          var n2 = new ms(r2, r2.readVarint() + r2.pos);
          n2.length && (e2[n2.name] = n2);
        }
      }
      vs.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new hs(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var bs = { VectorTile: function(t2, e2) {
        this.layers = t2.readFields(xs, {}, e2);
      }, VectorTileFeature: hs, VectorTileLayer: ms }, ws = bs.VectorTileFeature.types, _s = Math.pow(2, 13);
      function As(t2, e2, r2, n2, i2, a2, o2, s2) {
        t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * _s) + o2, i2 * _s * 2, a2 * _s * 2, Math.round(s2));
      }
      var Ss = function(t2) {
        this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
          return t3.id;
        }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Pi(), this.indexArray = new ji(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
          return t3.isStateDependent();
        }).map(function(t3) {
          return t3.id;
        });
      };
      function ks(t2, e2) {
        return t2.x === e2.x && (t2.x < 0 || t2.x > 8192) || t2.y === e2.y && (t2.y < 0 || t2.y > 8192);
      }
      Ss.prototype.populate = function(t2, e2, r2) {
        this.features = [], this.hasPattern = as("fill-extrusion", this.layers, e2);
        for (var n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2], o2 = a2.feature, s2 = a2.id, u2 = a2.index, l2 = a2.sourceLayerIndex, p3 = this.layers[0]._featureFilter.needGeometry, c3 = Ua(o2, p3);
          if (this.layers[0]._featureFilter.filter(new si(this.zoom), c3, r2)) {
            var h3 = { id: s2, sourceLayerIndex: l2, index: u2, geometry: p3 ? c3.geometry : Ra(o2), properties: o2.properties, type: o2.type, patterns: {} };
            this.hasPattern ? this.features.push(os("fill-extrusion", this.layers, h3, this.zoom, e2)) : this.addFeature(h3, h3.geometry, u2, r2, {}), e2.featureIndex.insert(o2, h3.geometry, u2, l2, this.index, true);
          }
        }
      }, Ss.prototype.addFeatures = function(t2, e2, r2) {
        for (var n2 = 0, i2 = this.features; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          this.addFeature(a2, a2.geometry, a2.index, e2, r2);
        }
      }, Ss.prototype.update = function(t2, e2, r2) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
      }, Ss.prototype.isEmpty = function() {
        return 0 === this.layoutVertexArray.length;
      }, Ss.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Ss.prototype.upload = function(t2) {
        this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
      }, Ss.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Ss.prototype.addFeature = function(t2, e2, r2, n2, i2) {
        for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
          for (var s2 = o2[a2], u2 = 0, l2 = 0, p3 = s2; l2 < p3.length; l2 += 1)
            u2 += p3[l2].length;
          for (var c3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h3 = 0, f2 = s2; h3 < f2.length; h3 += 1) {
            var y3 = f2[h3];
            if (0 !== y3.length && !((B2 = y3).every(function(t3) {
              return t3.x < 0;
            }) || B2.every(function(t3) {
              return t3.x > 8192;
            }) || B2.every(function(t3) {
              return t3.y < 0;
            }) || B2.every(function(t3) {
              return t3.y > 8192;
            })))
              for (var d2 = 0, m2 = 0; m2 < y3.length; m2++) {
                var v3 = y3[m2];
                if (m2 >= 1) {
                  var g2 = y3[m2 - 1];
                  if (!ks(v3, g2)) {
                    c3.vertexLength + 4 > sa.MAX_VERTEX_ARRAY_LENGTH && (c3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var x2 = v3.sub(g2)._perp()._unit(), b2 = g2.dist(v3);
                    d2 + b2 > 32768 && (d2 = 0), As(this.layoutVertexArray, v3.x, v3.y, x2.x, x2.y, 0, 0, d2), As(this.layoutVertexArray, v3.x, v3.y, x2.x, x2.y, 0, 1, d2), As(this.layoutVertexArray, g2.x, g2.y, x2.x, x2.y, 0, 0, d2 += b2), As(this.layoutVertexArray, g2.x, g2.y, x2.x, x2.y, 0, 1, d2);
                    var w2 = c3.vertexLength;
                    this.indexArray.emplaceBack(w2, w2 + 2, w2 + 1), this.indexArray.emplaceBack(w2 + 1, w2 + 2, w2 + 3), c3.vertexLength += 4, c3.primitiveLength += 2;
                  }
                }
              }
          }
          if (c3.vertexLength + u2 > sa.MAX_VERTEX_ARRAY_LENGTH && (c3 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray)), "Polygon" === ws[t2.type]) {
            for (var _24 = [], A3 = [], S2 = c3.vertexLength, k2 = 0, I3 = s2; k2 < I3.length; k2 += 1) {
              var z2 = I3[k2];
              if (0 !== z2.length) {
                z2 !== s2[0] && A3.push(_24.length / 2);
                for (var C2 = 0; C2 < z2.length; C2++) {
                  var E2 = z2[C2];
                  As(this.layoutVertexArray, E2.x, E2.y, 0, 0, 1, 1, 0), _24.push(E2.x), _24.push(E2.y);
                }
              }
            }
            for (var P2 = Io(_24, A3), M2 = 0; M2 < P2.length; M2 += 3)
              this.indexArray.emplaceBack(S2 + P2[M2], S2 + P2[M2 + 2], S2 + P2[M2 + 1]);
            c3.primitiveLength += P2.length / 3, c3.vertexLength += u2;
          }
        }
        var B2;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
      }, On("FillExtrusionBucket", Ss, { omit: ["layers", "features"] });
      var Is = { paint: new wi({ "fill-extrusion-opacity": new mi(Et["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new vi(Et["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gi(Et["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new vi(Et["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new vi(Et["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new mi(Et["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, zs = function(t2) {
        function e2(e3) {
          t2.call(this, e3, Is);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
          return new Ss(t3);
        }, e2.prototype.queryRadius = function() {
          return eo(this.paint.get("fill-extrusion-translate"));
        }, e2.prototype.is3D = function() {
          return true;
        }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2, u2) {
          var l2 = ro(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o2.angle, s2), p3 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c3 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h3 = function(t4, e4, r3, n3) {
            for (var a3 = [], o3 = 0, s3 = t4; o3 < s3.length; o3 += 1) {
              var u3 = s3[o3], l3 = [u3.x, u3.y, 0, 1];
              po(l3, l3, e4), a3.push(new i(l3[0] / l3[3], l3[1] / l3[3]));
            }
            return a3;
          }(l2, u2), f2 = function(t4, e4, r3, n3) {
            for (var a3 = [], o3 = [], s3 = n3[8] * e4, u3 = n3[9] * e4, l3 = n3[10] * e4, p4 = n3[11] * e4, c4 = n3[8] * r3, h4 = n3[9] * r3, f3 = n3[10] * r3, y3 = n3[11] * r3, d2 = 0, m2 = t4; d2 < m2.length; d2 += 1) {
              for (var v3 = [], g2 = [], x2 = 0, b2 = m2[d2]; x2 < b2.length; x2 += 1) {
                var w2 = b2[x2], _24 = w2.x, A3 = w2.y, S2 = n3[0] * _24 + n3[4] * A3 + n3[12], k2 = n3[1] * _24 + n3[5] * A3 + n3[13], I3 = n3[2] * _24 + n3[6] * A3 + n3[14], z2 = n3[3] * _24 + n3[7] * A3 + n3[15], C2 = I3 + l3, E2 = z2 + p4, P2 = S2 + c4, M2 = k2 + h4, B2 = I3 + f3, T2 = z2 + y3, V3 = new i((S2 + s3) / E2, (k2 + u3) / E2);
                V3.z = C2 / E2, v3.push(V3);
                var F2 = new i(P2 / T2, M2 / T2);
                F2.z = B2 / T2, g2.push(F2);
              }
              a3.push(v3), o3.push(g2);
            }
            return [a3, o3];
          }(n2, c3, p3, u2);
          return function(t4, e4, r3) {
            var n3 = 1 / 0;
            Ga(r3, e4) && (n3 = Es(r3, e4[0]));
            for (var i2 = 0; i2 < e4.length; i2++)
              for (var a3 = e4[i2], o3 = t4[i2], s3 = 0; s3 < a3.length - 1; s3++) {
                var u3 = a3[s3], l3 = [u3, a3[s3 + 1], o3[s3 + 1], o3[s3], u3];
                Na(r3, l3) && (n3 = Math.min(n3, Es(r3, l3)));
              }
            return n3 !== 1 / 0 && n3;
          }(f2[0], f2[1], h3);
        }, e2;
      }(_i);
      function Cs(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function Es(t2, e2) {
        if (1 === t2.length) {
          for (var r2, n2 = 0, i2 = e2[n2++]; !r2 || i2.equals(r2); )
            if (!(r2 = e2[n2++]))
              return 1 / 0;
          for (; n2 < e2.length; n2++) {
            var a2 = e2[n2], o2 = t2[0], s2 = r2.sub(i2), u2 = a2.sub(i2), l2 = o2.sub(i2), p3 = Cs(s2, s2), c3 = Cs(s2, u2), h3 = Cs(u2, u2), f2 = Cs(l2, s2), y3 = Cs(l2, u2), d2 = p3 * h3 - c3 * c3, m2 = (h3 * f2 - c3 * y3) / d2, v3 = (p3 * y3 - c3 * f2) / d2, g2 = i2.z * (1 - m2 - v3) + r2.z * m2 + a2.z * v3;
            if (isFinite(g2))
              return g2;
          }
          return 1 / 0;
        }
        for (var x2 = 1 / 0, b2 = 0, w2 = e2; b2 < w2.length; b2 += 1)
          x2 = Math.min(x2, w2[b2].z);
        return x2;
      }
      var Ps = Ii([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, Ms = Ii([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, Bs = bs.VectorTileFeature.types, Ts = Math.cos(Math.PI / 180 * 37.5), Vs = Math.pow(2, 14) / 0.5, Fs = function(t2) {
        var e2 = this;
        this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
          return t3.id;
        }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(t3) {
          e2.gradients[t3.id] = {};
        }), this.layoutVertexArray = new Mi(), this.layoutVertexArray2 = new Bi(), this.indexArray = new ji(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(t3) {
          return t3.isStateDependent();
        }).map(function(t3) {
          return t3.id;
        });
      };
      Fs.prototype.populate = function(t2, e2, r2) {
        this.hasPattern = as("line", this.layers, e2);
        for (var n2 = this.layers[0].layout.get("line-sort-key"), i2 = [], a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
          var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p3 = s2.index, c3 = s2.sourceLayerIndex, h3 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h3);
          if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
            var y3 = n2 ? n2.evaluate(f2, {}, r2) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c3, index: p3, geometry: h3 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y3 };
            i2.push(d2);
          }
        }
        n2 && i2.sort(function(t3, e3) {
          return t3.sortKey - e3.sortKey;
        });
        for (var m2 = 0, v3 = i2; m2 < v3.length; m2 += 1) {
          var g2 = v3[m2], x2 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
          if (this.hasPattern) {
            var _24 = os("line", this.layers, g2, this.zoom, e2);
            this.patternFeatures.push(_24);
          } else
            this.addFeature(g2, x2, b2, r2, {});
          e2.featureIndex.insert(t2[b2].feature, x2, b2, w2, this.index);
        }
      }, Fs.prototype.update = function(t2, e2, r2) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
      }, Fs.prototype.addFeatures = function(t2, e2, r2) {
        for (var n2 = 0, i2 = this.patternFeatures; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          this.addFeature(a2, a2.geometry, a2.index, e2, r2);
        }
      }, Fs.prototype.isEmpty = function() {
        return 0 === this.layoutVertexArray.length;
      }, Fs.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Fs.prototype.upload = function(t2) {
        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ms)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ps), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
      }, Fs.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Fs.prototype.lineFeatureClips = function(t2) {
        if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
          return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
      }, Fs.prototype.addFeature = function(t2, e2, r2, n2, i2) {
        var a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), s2 = a2.get("line-cap"), u2 = a2.get("line-miter-limit"), l2 = a2.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(t2);
        for (var p3 = 0, c3 = e2; p3 < c3.length; p3 += 1)
          this.addLine(c3[p3], t2, o2, s2, u2, l2);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
      }, Fs.prototype.addLine = function(t2, e2, r2, n2, i2, a2) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (var o2 = 0; o2 < t2.length - 1; o2++)
            this.totalDistance += t2[o2].dist(t2[o2 + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        for (var s2 = "Polygon" === Bs[e2.type], u2 = t2.length; u2 >= 2 && t2[u2 - 1].equals(t2[u2 - 2]); )
          u2--;
        for (var l2 = 0; l2 < u2 - 1 && t2[l2].equals(t2[l2 + 1]); )
          l2++;
        if (!(u2 < (s2 ? 3 : 2))) {
          "bevel" === r2 && (i2 = 1.05);
          var p3, c3 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, h3 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray), f2 = void 0, y3 = void 0, d2 = void 0, m2 = void 0;
          this.e1 = this.e2 = -1, s2 && (m2 = t2[l2].sub(p3 = t2[u2 - 2])._unit()._perp());
          for (var v3 = l2; v3 < u2; v3++)
            if (!(y3 = v3 === u2 - 1 ? s2 ? t2[l2 + 1] : void 0 : t2[v3 + 1]) || !t2[v3].equals(y3)) {
              m2 && (d2 = m2), p3 && (f2 = p3), p3 = t2[v3], m2 = y3 ? y3.sub(p3)._unit()._perp() : d2;
              var g2 = (d2 = d2 || m2).add(m2);
              0 === g2.x && 0 === g2.y || g2._unit();
              var x2 = d2.x * m2.x + d2.y * m2.y, b2 = g2.x * m2.x + g2.y * m2.y, w2 = 0 !== b2 ? 1 / b2 : 1 / 0, _24 = 2 * Math.sqrt(2 - 2 * b2), A3 = b2 < Ts && f2 && y3, S2 = d2.x * m2.y - d2.y * m2.x > 0;
              if (A3 && v3 > l2) {
                var k2 = p3.dist(f2);
                if (k2 > 2 * c3) {
                  var I3 = p3.sub(p3.sub(f2)._mult(c3 / k2)._round());
                  this.updateDistance(f2, I3), this.addCurrentVertex(I3, d2, 0, 0, h3), f2 = I3;
                }
              }
              var z2 = f2 && y3, C2 = z2 ? r2 : s2 ? "butt" : n2;
              if (z2 && "round" === C2 && (w2 < a2 ? C2 = "miter" : w2 <= 2 && (C2 = "fakeround")), "miter" === C2 && w2 > i2 && (C2 = "bevel"), "bevel" === C2 && (w2 > 2 && (C2 = "flipbevel"), w2 < i2 && (C2 = "miter")), f2 && this.updateDistance(f2, p3), "miter" === C2)
                g2._mult(w2), this.addCurrentVertex(p3, g2, 0, 0, h3);
              else if ("flipbevel" === C2) {
                if (w2 > 100)
                  g2 = m2.mult(-1);
                else {
                  var E2 = w2 * d2.add(m2).mag() / d2.sub(m2).mag();
                  g2._perp()._mult(E2 * (S2 ? -1 : 1));
                }
                this.addCurrentVertex(p3, g2, 0, 0, h3), this.addCurrentVertex(p3, g2.mult(-1), 0, 0, h3);
              } else if ("bevel" === C2 || "fakeround" === C2) {
                var P2 = -Math.sqrt(w2 * w2 - 1), M2 = S2 ? P2 : 0, B2 = S2 ? 0 : P2;
                if (f2 && this.addCurrentVertex(p3, d2, M2, B2, h3), "fakeround" === C2)
                  for (var T2 = Math.round(180 * _24 / Math.PI / 20), V3 = 1; V3 < T2; V3++) {
                    var F2 = V3 / T2;
                    if (0.5 !== F2) {
                      var D2 = F2 - 0.5;
                      F2 += F2 * D2 * (F2 - 1) * ((1.0904 + x2 * (x2 * (3.55645 - 1.43519 * x2) - 3.2452)) * D2 * D2 + (0.848013 + x2 * (0.215638 * x2 - 1.06021)));
                    }
                    var L2 = m2.sub(d2)._mult(F2)._add(d2)._unit()._mult(S2 ? -1 : 1);
                    this.addHalfVertex(p3, L2.x, L2.y, false, S2, 0, h3);
                  }
                y3 && this.addCurrentVertex(p3, m2, -M2, -B2, h3);
              } else if ("butt" === C2)
                this.addCurrentVertex(p3, g2, 0, 0, h3);
              else if ("square" === C2) {
                var O3 = f2 ? 1 : -1;
                this.addCurrentVertex(p3, g2, O3, O3, h3);
              } else
                "round" === C2 && (f2 && (this.addCurrentVertex(p3, d2, 0, 0, h3), this.addCurrentVertex(p3, d2, 1, 1, h3, true)), y3 && (this.addCurrentVertex(p3, m2, -1, -1, h3, true), this.addCurrentVertex(p3, m2, 0, 0, h3)));
              if (A3 && v3 < u2 - 1) {
                var R2 = p3.dist(y3);
                if (R2 > 2 * c3) {
                  var U2 = p3.add(y3.sub(p3)._mult(c3 / R2)._round());
                  this.updateDistance(p3, U2), this.addCurrentVertex(U2, m2, 0, 0, h3), p3 = U2;
                }
              }
            }
        }
      }, Fs.prototype.addCurrentVertex = function(t2, e2, r2, n2, i2, a2) {
        void 0 === a2 && (a2 = false);
        var o2 = e2.y * n2 - e2.x, s2 = -e2.y - e2.x * n2;
        this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, a2, false, r2, i2), this.addHalfVertex(t2, o2, s2, a2, true, -n2, i2), this.distance > Vs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t2, e2, r2, n2, i2, a2));
      }, Fs.prototype.addHalfVertex = function(t2, e2, r2, n2, i2, a2, o2) {
        var s2 = 0.5 * (this.lineClips ? this.scaledDistance * (Vs - 1) : this.scaledDistance);
        this.layoutVertexArray.emplaceBack((t2.x << 1) + (n2 ? 1 : 0), (t2.y << 1) + (i2 ? 1 : 0), Math.round(63 * e2) + 128, Math.round(63 * r2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & s2) << 2, s2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
        var u2 = o2.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), i2 ? this.e2 = u2 : this.e1 = u2;
      }, Fs.prototype.updateScaledDistance = function() {
        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
      }, Fs.prototype.updateDistance = function(t2, e2) {
        this.distance += t2.dist(e2), this.updateScaledDistance();
      }, On("LineBucket", Fs, { omit: ["layers", "patternFeatures"] });
      var Ds = new wi({ "line-cap": new mi(Et.layout_line["line-cap"]), "line-join": new vi(Et.layout_line["line-join"]), "line-miter-limit": new mi(Et.layout_line["line-miter-limit"]), "line-round-limit": new mi(Et.layout_line["line-round-limit"]), "line-sort-key": new vi(Et.layout_line["line-sort-key"]) }), Ls = { paint: new wi({ "line-opacity": new vi(Et.paint_line["line-opacity"]), "line-color": new vi(Et.paint_line["line-color"]), "line-translate": new mi(Et.paint_line["line-translate"]), "line-translate-anchor": new mi(Et.paint_line["line-translate-anchor"]), "line-width": new vi(Et.paint_line["line-width"]), "line-gap-width": new vi(Et.paint_line["line-gap-width"]), "line-offset": new vi(Et.paint_line["line-offset"]), "line-blur": new vi(Et.paint_line["line-blur"]), "line-dasharray": new xi(Et.paint_line["line-dasharray"]), "line-pattern": new gi(Et.paint_line["line-pattern"]), "line-gradient": new bi(Et.paint_line["line-gradient"]) }), layout: Ds }, Os = new (function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(e3, r2) {
          return r2 = new si(Math.floor(r2.zoom), { now: r2.now, fadeDuration: r2.fadeDuration, zoomHistory: r2.zoomHistory, transition: r2.transition }), t2.prototype.possiblyEvaluate.call(this, e3, r2);
        }, e2.prototype.evaluate = function(e3, r2, n2, i2) {
          return r2 = h2({}, r2, { zoom: Math.floor(r2.zoom) }), t2.prototype.evaluate.call(this, e3, r2, n2, i2);
        }, e2;
      }(vi))(Ls.paint.properties["line-width"].specification);
      Os.useIntegerZoom = true;
      var Rs = function(t2) {
        function e2(e3) {
          t2.call(this, e3, Ls), this.gradientVersion = 0;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
          "line-gradient" === t3 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ne, this.gradientVersion = (this.gradientVersion + 1) % s);
        }, e2.prototype.gradientExpression = function() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }, e2.prototype.recalculate = function(e3, r2) {
          t2.prototype.recalculate.call(this, e3, r2), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e3);
        }, e2.prototype.createBucket = function(t3) {
          return new Fs(t3);
        }, e2.prototype.queryRadius = function(t3) {
          var e3 = t3, r2 = Us(to("line-width", this, e3), to("line-gap-width", this, e3)), n2 = to("line-offset", this, e3);
          return r2 / 2 + Math.abs(n2) + eo(this.paint.get("line-translate"));
        }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2) {
          var u2 = ro(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o2.angle, s2), l2 = s2 / 2 * Us(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), p3 = this.paint.get("line-offset").evaluate(e3, r2);
          return p3 && (n2 = function(t4, e4) {
            for (var r3 = [], n3 = new i(0, 0), a3 = 0; a3 < t4.length; a3++) {
              for (var o3 = t4[a3], s3 = [], u3 = 0; u3 < o3.length; u3++) {
                var l3 = o3[u3], p4 = o3[u3 + 1], c3 = 0 === u3 ? n3 : l3.sub(o3[u3 - 1])._unit()._perp(), h3 = u3 === o3.length - 1 ? n3 : p4.sub(l3)._unit()._perp(), f2 = c3._add(h3)._unit();
                f2._mult(1 / (f2.x * h3.x + f2.y * h3.y)), s3.push(f2._mult(e4)._add(l3));
              }
              r3.push(s3);
            }
            return r3;
          }(n2, p3 * s2)), function(t4, e4, r3) {
            for (var n3 = 0; n3 < e4.length; n3++) {
              var i2 = e4[n3];
              if (t4.length >= 3) {
                for (var a3 = 0; a3 < i2.length; a3++)
                  if (Wa(t4, i2[a3]))
                    return true;
              }
              if (Za(t4, i2, r3))
                return true;
            }
            return false;
          }(u2, n2, l2);
        }, e2.prototype.isTileClipped = function() {
          return true;
        }, e2;
      }(_i);
      function Us(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      var js = Ii([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), qs = Ii([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Ns = (Ii([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), Ii([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Ks = (Ii([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Gs = Ii([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function Zs(t2, e2, r2) {
        return t2.sections.forEach(function(t3) {
          t3.text = function(t4, e3, r3) {
            var n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), oi.applyArabicShaping && (t4 = oi.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      Ii([{ name: "triangle", components: 3, type: "Uint16" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ii([{ type: "Float32", name: "offsetX" }]), Ii([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var Xs = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, Js = function(t2, e2, r2, n2, i2) {
        var a2, o2, s2 = 8 * i2 - n2 - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, p3 = -7, c3 = r2 ? i2 - 1 : 0, h3 = r2 ? -1 : 1, f2 = t2[e2 + c3];
        for (c3 += h3, a2 = f2 & (1 << -p3) - 1, f2 >>= -p3, p3 += s2; p3 > 0; a2 = 256 * a2 + t2[e2 + c3], c3 += h3, p3 -= 8)
          ;
        for (o2 = a2 & (1 << -p3) - 1, a2 >>= -p3, p3 += n2; p3 > 0; o2 = 256 * o2 + t2[e2 + c3], c3 += h3, p3 -= 8)
          ;
        if (0 === a2)
          a2 = 1 - l2;
        else {
          if (a2 === u2)
            return o2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          o2 += Math.pow(2, n2), a2 -= l2;
        }
        return (f2 ? -1 : 1) * o2 * Math.pow(2, a2 - n2);
      }, Hs = function(t2, e2, r2, n2, i2, a2) {
        var o2, s2, u2, l2 = 8 * a2 - i2 - 1, p3 = (1 << l2) - 1, c3 = p3 >> 1, h3 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, y3 = n2 ? 1 : -1, d2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s2 = isNaN(e2) ? 1 : 0, o2 = p3) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (u2 = Math.pow(2, -o2)) < 1 && (o2--, u2 *= 2), (e2 += o2 + c3 >= 1 ? h3 / u2 : h3 * Math.pow(2, 1 - c3)) * u2 >= 2 && (o2++, u2 /= 2), o2 + c3 >= p3 ? (s2 = 0, o2 = p3) : o2 + c3 >= 1 ? (s2 = (e2 * u2 - 1) * Math.pow(2, i2), o2 += c3) : (s2 = e2 * Math.pow(2, c3 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & s2, f2 += y3, s2 /= 256, i2 -= 8)
          ;
        for (o2 = o2 << i2 | s2, l2 += i2; l2 > 0; t2[r2 + f2] = 255 & o2, f2 += y3, o2 /= 256, l2 -= 8)
          ;
        t2[r2 + f2 - y3] |= 128 * d2;
      }, Ys = $s;
      function $s(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      $s.Varint = 0, $s.Fixed64 = 1, $s.Bytes = 2, $s.Fixed32 = 5;
      var Ws = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function Qs(t2) {
        return t2.type === $s.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function tu(t2, e2, r2) {
        return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function eu(t2, e2, r2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1; i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function ru(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeVarint(t2[r2]);
      }
      function nu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSVarint(t2[r2]);
      }
      function iu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFloat(t2[r2]);
      }
      function au(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeDouble(t2[r2]);
      }
      function ou(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeBoolean(t2[r2]);
      }
      function su(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed32(t2[r2]);
      }
      function uu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed32(t2[r2]);
      }
      function lu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed64(t2[r2]);
      }
      function pu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed64(t2[r2]);
      }
      function cu(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function hu(t2, e2, r2) {
        t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
      }
      function fu(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      function yu(t2, e2, r2) {
        1 === t2 && r2.readMessage(du, e2);
      }
      function du(t2, e2, r2) {
        if (3 === t2) {
          var n2 = r2.readMessage(mu, {}), i2 = n2.width, a2 = n2.height, o2 = n2.left, s2 = n2.top, u2 = n2.advance;
          e2.push({ id: n2.id, bitmap: new go({ width: i2 + 6, height: a2 + 6 }, n2.bitmap), metrics: { width: i2, height: a2, left: o2, top: s2, advance: u2 } });
        }
      }
      function mu(t2, e2, r2) {
        1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
      }
      function vu(t2) {
        for (var e2 = 0, r2 = 0, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
          var a2 = i2[n2];
          e2 += a2.w * a2.h, r2 = Math.max(r2, a2.w);
        }
        t2.sort(function(t3, e3) {
          return e3.h - t3.h;
        });
        for (var o2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }], s2 = 0, u2 = 0, l2 = 0, p3 = t2; l2 < p3.length; l2 += 1)
          for (var c3 = p3[l2], h3 = o2.length - 1; h3 >= 0; h3--) {
            var f2 = o2[h3];
            if (!(c3.w > f2.w || c3.h > f2.h)) {
              if (c3.x = f2.x, c3.y = f2.y, u2 = Math.max(u2, c3.y + c3.h), s2 = Math.max(s2, c3.x + c3.w), c3.w === f2.w && c3.h === f2.h) {
                var y3 = o2.pop();
                h3 < o2.length && (o2[h3] = y3);
              } else
                c3.h === f2.h ? (f2.x += c3.w, f2.w -= c3.w) : c3.w === f2.w ? (f2.y += c3.h, f2.h -= c3.h) : (o2.push({ x: f2.x + c3.w, y: f2.y, w: f2.w - c3.w, h: c3.h }), f2.y += c3.h, f2.h -= c3.h);
              break;
            }
          }
        return { w: s2, h: u2, fill: e2 / (s2 * u2) || 0 };
      }
      $s.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e2, r2) {
        for (r2 = r2 || this.length; this.pos < r2; ) {
          var n2 = this.readVarint(), i2 = n2 >> 3, a2 = this.pos;
          this.type = 7 & n2, t2(i2, e2, this), this.pos === a2 && this.skip(n2);
        }
        return e2;
      }, readMessage: function(t2, e2) {
        return this.readFields(t2, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = cu(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = fu(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = cu(this.buf, this.pos) + 4294967296 * cu(this.buf, this.pos + 4);
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = cu(this.buf, this.pos) + 4294967296 * fu(this.buf, this.pos + 4);
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = Js(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = Js(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e2, r2, n2 = this.buf;
        return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
          var n3, i2, a2 = r3.buf;
          if (n3 = (112 & (i2 = a2[r3.pos++])) >> 4, i2 < 128)
            return tu(t3, n3, e3);
          if (n3 |= (127 & (i2 = a2[r3.pos++])) << 3, i2 < 128)
            return tu(t3, n3, e3);
          if (n3 |= (127 & (i2 = a2[r3.pos++])) << 10, i2 < 128)
            return tu(t3, n3, e3);
          if (n3 |= (127 & (i2 = a2[r3.pos++])) << 17, i2 < 128)
            return tu(t3, n3, e3);
          if (n3 |= (127 & (i2 = a2[r3.pos++])) << 24, i2 < 128)
            return tu(t3, n3, e3);
          if (n3 |= (1 & (i2 = a2[r3.pos++])) << 31, i2 < 128)
            return tu(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t2, t2 - e2 >= 12 && Ws ? function(t3, e3, r2) {
          return Ws.decode(t3.subarray(e3, r2));
        }(this.buf, e2, t2) : function(t3, e3, r2) {
          for (var n2 = "", i2 = e3; i2 < r2; ) {
            var a2, o2, s2, u2 = t3[i2], l2 = null, p3 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
            if (i2 + p3 > r2)
              break;
            1 === p3 ? u2 < 128 && (l2 = u2) : 2 === p3 ? 128 == (192 & (a2 = t3[i2 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) <= 127 && (l2 = null) : 3 === p3 ? (o2 = t3[i2 + 2], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & o2) && ((l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null)) : 4 === p3 && (o2 = t3[i2 + 2], s2 = t3[i2 + 3], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & o2) && 128 == (192 & s2) && ((l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) <= 65535 || l2 >= 1114112) && (l2 = null)), null === l2 ? (l2 = 65533, p3 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += p3;
          }
          return n2;
        }(this.buf, e2, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e2;
      }, readPackedVarint: function(t2, e2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readVarint(e2));
        var r2 = Qs(this);
        for (t2 = t2 || []; this.pos < r2; )
          t2.push(this.readVarint(e2));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readSVarint());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readBoolean());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readFloat());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readDouble());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readFixed32());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readSFixed32());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readFixed64());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== $s.Bytes)
          return t2.push(this.readSFixed64());
        var e2 = Qs(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e2 = 7 & t2;
        if (e2 === $s.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e2 === $s.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === $s.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== $s.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t2, e2) {
        this.writeVarint(t2 << 3 | e2);
      }, realloc: function(t2) {
        for (var e2 = this.length || 16; e2 < this.pos + t2; )
          e2 *= 2;
        if (e2 !== this.length) {
          var r2 = new Uint8Array(e2);
          r2.set(this.buf), this.buf = r2, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), hu(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), hu(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), hu(this.buf, -1 & t2, this.pos), hu(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), hu(this.buf, -1 & t2, this.pos), hu(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
          var r2, n2;
          if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t4, e3, r3) {
            r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
          }(r2, 0, e2), function(t4, e3) {
            var r3 = (7 & t4) << 4;
            e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
          }(n2, e2);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t3, e3, r3) {
          for (var n2, i2, a2 = 0; a2 < e3.length; a2++) {
            if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
              if (!i2) {
                n2 > 56319 || a2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                continue;
              }
              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
            } else
              i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
            n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
          }
          return r3;
        }(this.buf, t2, this.pos);
        var r2 = this.pos - e2;
        r2 >= 128 && eu(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeFloat: function(t2) {
        this.realloc(4), Hs(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), Hs(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e2 = t2.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r2 = 0; r2 < e2; r2++)
          this.buf[this.pos++] = t2[r2];
      }, writeRawMessage: function(t2, e2) {
        this.pos++;
        var r2 = this.pos;
        t2(e2, this);
        var n2 = this.pos - r2;
        n2 >= 128 && eu(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e2, r2) {
        this.writeTag(t2, $s.Bytes), this.writeRawMessage(e2, r2);
      }, writePackedVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, ru, e2);
      }, writePackedSVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, nu, e2);
      }, writePackedBoolean: function(t2, e2) {
        e2.length && this.writeMessage(t2, ou, e2);
      }, writePackedFloat: function(t2, e2) {
        e2.length && this.writeMessage(t2, iu, e2);
      }, writePackedDouble: function(t2, e2) {
        e2.length && this.writeMessage(t2, au, e2);
      }, writePackedFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, su, e2);
      }, writePackedSFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, uu, e2);
      }, writePackedFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, lu, e2);
      }, writePackedSFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, pu, e2);
      }, writeBytesField: function(t2, e2) {
        this.writeTag(t2, $s.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t2, e2) {
        this.writeTag(t2, $s.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t2, e2) {
        this.writeTag(t2, $s.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t2, e2) {
        this.writeTag(t2, $s.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t2, e2) {
        this.writeTag(t2, $s.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t2, e2) {
        this.writeTag(t2, $s.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t2, e2) {
        this.writeTag(t2, $s.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t2, e2) {
        this.writeTag(t2, $s.Bytes), this.writeString(e2);
      }, writeFloatField: function(t2, e2) {
        this.writeTag(t2, $s.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t2, e2) {
        this.writeTag(t2, $s.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t2, e2) {
        this.writeVarintField(t2, Boolean(e2));
      } };
      var gu = function(t2, e2) {
        var r2 = e2.pixelRatio, n2 = e2.version, i2 = e2.stretchX, a2 = e2.stretchY, o2 = e2.content;
        this.paddedRect = t2, this.pixelRatio = r2, this.stretchX = i2, this.stretchY = a2, this.content = o2, this.version = n2;
      }, xu = { tl: { configurable: true }, br: { configurable: true }, tlbr: { configurable: true }, displaySize: { configurable: true } };
      xu.tl.get = function() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }, xu.br.get = function() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }, xu.tlbr.get = function() {
        return this.tl.concat(this.br);
      }, xu.displaySize.get = function() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }, Object.defineProperties(gu.prototype, xu);
      var bu = function(t2, e2) {
        var r2 = {}, n2 = {};
        this.haveRenderCallbacks = [];
        var i2 = [];
        this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
        var a2 = vu(i2), o2 = new xo({ width: a2.w || 1, height: a2.h || 1 });
        for (var s2 in t2) {
          var u2 = t2[s2], l2 = r2[s2].paddedRect;
          xo.copy(u2.data, o2, { x: 0, y: 0 }, { x: l2.x + 1, y: l2.y + 1 }, u2.data);
        }
        for (var p3 in e2) {
          var c3 = e2[p3], h3 = n2[p3].paddedRect, f2 = h3.x + 1, y3 = h3.y + 1, d2 = c3.data.width, m2 = c3.data.height;
          xo.copy(c3.data, o2, { x: 0, y: 0 }, { x: f2, y: y3 }, c3.data), xo.copy(c3.data, o2, { x: 0, y: m2 - 1 }, { x: f2, y: y3 - 1 }, { width: d2, height: 1 }), xo.copy(c3.data, o2, { x: 0, y: 0 }, { x: f2, y: y3 + m2 }, { width: d2, height: 1 }), xo.copy(c3.data, o2, { x: d2 - 1, y: 0 }, { x: f2 - 1, y: y3 }, { width: 1, height: m2 }), xo.copy(c3.data, o2, { x: 0, y: 0 }, { x: f2 + d2, y: y3 }, { width: 1, height: m2 });
        }
        this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
      };
      bu.prototype.addImages = function(t2, e2, r2) {
        for (var n2 in t2) {
          var i2 = t2[n2], a2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
          r2.push(a2), e2[n2] = new gu(a2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
        }
      }, bu.prototype.patchUpdatedImages = function(t2, e2) {
        for (var r2 in t2.dispatchRenderCallbacks(this.haveRenderCallbacks), t2.updatedImages)
          this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
      }, bu.prototype.patchUpdatedImage = function(t2, e2, r2) {
        if (t2 && e2 && t2.version !== e2.version) {
          t2.version = e2.version;
          var n2 = t2.tl;
          r2.update(e2.data, void 0, { x: n2[0], y: n2[1] });
        }
      }, On("ImagePosition", gu), On("ImageAtlas", bu);
      var wu = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, _u = function() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      };
      _u.forText = function(t2, e2) {
        var r2 = new _u();
        return r2.scale = t2 || 1, r2.fontStack = e2, r2;
      }, _u.forImage = function(t2) {
        var e2 = new _u();
        return e2.imageName = t2, e2;
      };
      var Au = function() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      };
      function Su(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2) {
        var m2, v3 = Au.fromFeature(t2, i2);
        c3 === wu.vertical && v3.verticalizePunctuation();
        var g2 = oi.processBidirectionalText, x2 = oi.processStyledBidirectionalText;
        if (g2 && 1 === v3.sections.length) {
          m2 = [];
          for (var b2 = 0, w2 = g2(v3.toString(), Mu(v3, l2, a2, e2, n2, f2, y3)); b2 < w2.length; b2 += 1) {
            var _24 = w2[b2], A3 = new Au();
            A3.text = _24, A3.sections = v3.sections;
            for (var S2 = 0; S2 < _24.length; S2++)
              A3.sectionIndex.push(0);
            m2.push(A3);
          }
        } else if (x2) {
          m2 = [];
          for (var k2 = 0, I3 = x2(v3.text, v3.sectionIndex, Mu(v3, l2, a2, e2, n2, f2, y3)); k2 < I3.length; k2 += 1) {
            var z2 = I3[k2], C2 = new Au();
            C2.text = z2[0], C2.sectionIndex = z2[1], C2.sections = v3.sections, m2.push(C2);
          }
        } else
          m2 = function(t3, e3) {
            for (var r3 = [], n3 = t3.text, i3 = 0, a3 = 0, o3 = e3; a3 < o3.length; a3 += 1) {
              var s3 = o3[a3];
              r3.push(t3.substring(i3, s3)), i3 = s3;
            }
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(v3, Mu(v3, l2, a2, e2, n2, f2, y3));
        var E2 = [], P2 = { positionedLines: E2, text: v3.toString(), top: p3[1], bottom: p3[1], left: p3[0], right: p3[0], writingMode: c3, iconsInText: false, verticalizable: false };
        return function(t3, e3, r3, n3, i3, a3, o3, s3, u3, l3, p4, c4) {
          for (var h4 = 0, f3 = -17, y4 = 0, d3 = 0, m3 = "right" === s3 ? 1 : "left" === s3 ? 0 : 0.5, v4 = 0, g3 = 0, x3 = i3; g3 < x3.length; g3 += 1) {
            var b3 = x3[g3];
            b3.trim();
            var w3 = b3.getMaxScale(), _25 = 24 * (w3 - 1), A4 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[v4] = A4;
            var S3 = A4.positionedGlyphs, k3 = 0;
            if (b3.length()) {
              for (var I4 = 0; I4 < b3.length(); I4++) {
                var z3 = b3.getSection(I4), C3 = b3.getSectionIndex(I4), E3 = b3.getCharCode(I4), P3 = 0, M2 = null, B2 = null, T2 = null, V3 = 24, F2 = !(u3 === wu.horizontal || !p4 && !Xn(E3) || p4 && (ku[E3] || (K2 = E3, Gn.Arabic(K2) || Gn["Arabic Supplement"](K2) || Gn["Arabic Extended-A"](K2) || Gn["Arabic Presentation Forms-A"](K2) || Gn["Arabic Presentation Forms-B"](K2))));
                if (z3.imageName) {
                  var D2 = n3[z3.imageName];
                  if (!D2)
                    continue;
                  T2 = z3.imageName, t3.iconsInText = t3.iconsInText || true, B2 = D2.paddedRect;
                  var L2 = D2.displaySize;
                  z3.scale = 24 * z3.scale / c4, P3 = _25 + (24 - L2[1] * z3.scale), V3 = (M2 = { width: L2[0], height: L2[1], left: 1, top: -3, advance: F2 ? L2[1] : L2[0] }).advance;
                  var O3 = F2 ? L2[0] * z3.scale - 24 * w3 : L2[1] * z3.scale - 24 * w3;
                  O3 > 0 && O3 > k3 && (k3 = O3);
                } else {
                  var R2 = r3[z3.fontStack], U2 = R2 && R2[E3];
                  if (U2 && U2.rect)
                    B2 = U2.rect, M2 = U2.metrics;
                  else {
                    var j2 = e3[z3.fontStack], q2 = j2 && j2[E3];
                    if (!q2)
                      continue;
                    M2 = q2.metrics;
                  }
                  P3 = 24 * (w3 - z3.scale);
                }
                F2 ? (t3.verticalizable = true, S3.push({ glyph: E3, imageName: T2, x: h4, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: M2, rect: B2 }), h4 += V3 * z3.scale + l3) : (S3.push({ glyph: E3, imageName: T2, x: h4, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: M2, rect: B2 }), h4 += M2.advance * z3.scale + l3);
              }
              0 !== S3.length && (y4 = Math.max(h4 - l3, y4), Tu(S3, 0, S3.length - 1, m3, k3)), h4 = 0;
              var N2 = a3 * w3 + k3;
              A4.lineOffset = Math.max(k3, _25), f3 += N2, d3 = Math.max(N2, d3), ++v4;
            } else
              f3 += a3, ++v4;
          }
          var K2, G2 = f3 - -17, Z3 = Bu(o3), X2 = Z3.horizontalAlign, J2 = Z3.verticalAlign;
          (function(t4, e4, r4, n4, i4, a4, o4, s4, u4) {
            var l4, p5 = (e4 - r4) * i4;
            l4 = a4 !== o4 ? -s4 * n4 - -17 : (-n4 * u4 + 0.5) * o4;
            for (var c5 = 0, h5 = t4; c5 < h5.length; c5 += 1)
              for (var f4 = 0, y5 = h5[c5].positionedGlyphs; f4 < y5.length; f4 += 1) {
                var d4 = y5[f4];
                d4.x += p5, d4.y += l4;
              }
          })(t3.positionedLines, m3, X2, J2, y4, d3, a3, G2, i3.length), t3.top += -J2 * G2, t3.bottom = t3.top + G2, t3.left += -X2 * y4, t3.right = t3.left + y4;
        }(P2, e2, r2, n2, m2, o2, s2, u2, c3, l2, h3, d2), !function(t3) {
          for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1)
            if (0 !== r3[e3].positionedGlyphs.length)
              return false;
          return true;
        }(E2) && P2;
      }
      Au.fromFeature = function(t2, e2) {
        for (var r2 = new Au(), n2 = 0; n2 < t2.sections.length; n2++) {
          var i2 = t2.sections[n2];
          i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
        }
        return r2;
      }, Au.prototype.length = function() {
        return this.text.length;
      }, Au.prototype.getSection = function(t2) {
        return this.sections[this.sectionIndex[t2]];
      }, Au.prototype.getSectionIndex = function(t2) {
        return this.sectionIndex[t2];
      }, Au.prototype.getCharCode = function(t2) {
        return this.text.charCodeAt(t2);
      }, Au.prototype.verticalizePunctuation = function() {
        this.text = function(t2) {
          for (var e2 = "", r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
            e2 += n2 && Jn(n2) && !Xs[t2[r2 + 1]] || i2 && Jn(i2) && !Xs[t2[r2 - 1]] || !Xs[t2[r2]] ? t2[r2] : Xs[t2[r2]];
          }
          return e2;
        }(this.text);
      }, Au.prototype.trim = function() {
        for (var t2 = 0, e2 = 0; e2 < this.text.length && ku[this.text.charCodeAt(e2)]; e2++)
          t2++;
        for (var r2 = this.text.length, n2 = this.text.length - 1; n2 >= 0 && n2 >= t2 && ku[this.text.charCodeAt(n2)]; n2--)
          r2--;
        this.text = this.text.substring(t2, r2), this.sectionIndex = this.sectionIndex.slice(t2, r2);
      }, Au.prototype.substring = function(t2, e2) {
        var r2 = new Au();
        return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
      }, Au.prototype.toString = function() {
        return this.text;
      }, Au.prototype.getMaxScale = function() {
        var t2 = this;
        return this.sectionIndex.reduce(function(e2, r2) {
          return Math.max(e2, t2.sections[r2].scale);
        }, 0);
      }, Au.prototype.addTextSection = function(t2, e2) {
        this.text += t2.text, this.sections.push(_u.forText(t2.scale, t2.fontStack || e2));
        for (var r2 = this.sections.length - 1, n2 = 0; n2 < t2.text.length; ++n2)
          this.sectionIndex.push(r2);
      }, Au.prototype.addImageSection = function(t2) {
        var e2 = t2.image ? t2.image.name : "";
        if (0 !== e2.length) {
          var r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(_u.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
        } else
          A2("Can't add FormattedSection with an empty image.");
      }, Au.prototype.getNextImageSectionCharCode = function() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      };
      var ku = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Iu = {};
      function zu(t2, e2, r2, n2, i2, a2) {
        if (e2.imageName) {
          var o2 = n2[e2.imageName];
          return o2 ? o2.displaySize[0] * e2.scale * 24 / a2 + i2 : 0;
        }
        var s2 = r2[e2.fontStack], u2 = s2 && s2[t2];
        return u2 ? u2.metrics.advance * e2.scale + i2 : 0;
      }
      function Cu(t2, e2, r2, n2) {
        var i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function Eu(t2, e2, r2) {
        var n2 = 0;
        return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
      }
      function Pu(t2, e2, r2, n2, i2, a2) {
        for (var o2 = null, s2 = Cu(e2, r2, i2, a2), u2 = 0, l2 = n2; u2 < l2.length; u2 += 1) {
          var p3 = l2[u2], c3 = Cu(e2 - p3.x, r2, i2, a2) + p3.badness;
          c3 <= s2 && (o2 = p3, s2 = c3);
        }
        return { index: t2, x: e2, priorBreak: o2, badness: s2 };
      }
      function Mu(t2, e2, r2, n2, i2, a2, o2) {
        if ("point" !== a2)
          return [];
        if (!t2)
          return [];
        for (var s2, u2 = [], l2 = function(t3, e3, r3, n3, i3, a3) {
          for (var o3 = 0, s3 = 0; s3 < t3.length(); s3++) {
            var u3 = t3.getSection(s3);
            o3 += zu(t3.getCharCode(s3), u3, n3, i3, e3, a3);
          }
          return o3 / Math.max(1, Math.ceil(o3 / r3));
        }(t2, e2, r2, n2, i2, o2), p3 = t2.text.indexOf("\u200B") >= 0, c3 = 0, h3 = 0; h3 < t2.length(); h3++) {
          var f2 = t2.getSection(h3), y3 = t2.getCharCode(h3);
          if (ku[y3] || (c3 += zu(y3, f2, n2, i2, e2, o2)), h3 < t2.length() - 1) {
            var d2 = !((s2 = y3) < 11904 || !(Gn["Bopomofo Extended"](s2) || Gn.Bopomofo(s2) || Gn["CJK Compatibility Forms"](s2) || Gn["CJK Compatibility Ideographs"](s2) || Gn["CJK Compatibility"](s2) || Gn["CJK Radicals Supplement"](s2) || Gn["CJK Strokes"](s2) || Gn["CJK Symbols and Punctuation"](s2) || Gn["CJK Unified Ideographs Extension A"](s2) || Gn["CJK Unified Ideographs"](s2) || Gn["Enclosed CJK Letters and Months"](s2) || Gn["Halfwidth and Fullwidth Forms"](s2) || Gn.Hiragana(s2) || Gn["Ideographic Description Characters"](s2) || Gn["Kangxi Radicals"](s2) || Gn["Katakana Phonetic Extensions"](s2) || Gn.Katakana(s2) || Gn["Vertical Forms"](s2) || Gn["Yi Radicals"](s2) || Gn["Yi Syllables"](s2)));
            (Iu[y3] || d2 || f2.imageName) && u2.push(Pu(h3 + 1, c3, l2, u2, Eu(y3, t2.getCharCode(h3 + 1), d2 && p3), false));
          }
        }
        return function t3(e3) {
          return e3 ? t3(e3.priorBreak).concat(e3.index) : [];
        }(Pu(t2.length(), c3, l2, u2, 0, true));
      }
      function Bu(t2) {
        var e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function Tu(t2, e2, r2, n2, i2) {
        if (n2 || i2)
          for (var a2 = t2[r2], o2 = (t2[r2].x + a2.metrics.advance * a2.scale) * n2, s2 = e2; s2 <= r2; s2++)
            t2[s2].x -= o2, t2[s2].y += i2;
      }
      function Vu(t2, e2, r2, n2, i2, a2) {
        var o2, s2 = t2.image;
        if (s2.content) {
          var u2 = s2.content, l2 = s2.pixelRatio || 1;
          o2 = [u2[0] / l2, u2[1] / l2, s2.displaySize[0] - u2[2] / l2, s2.displaySize[1] - u2[3] / l2];
        }
        var p3, c3, h3, f2, y3 = e2.left * a2, d2 = e2.right * a2;
        "width" === r2 || "both" === r2 ? (f2 = i2[0] + y3 - n2[3], c3 = i2[0] + d2 + n2[1]) : c3 = (f2 = i2[0] + (y3 + d2 - s2.displaySize[0]) / 2) + s2.displaySize[0];
        var m2 = e2.top * a2, v3 = e2.bottom * a2;
        return "height" === r2 || "both" === r2 ? (p3 = i2[1] + m2 - n2[0], h3 = i2[1] + v3 + n2[2]) : h3 = (p3 = i2[1] + (m2 + v3 - s2.displaySize[1]) / 2) + s2.displaySize[1], { image: s2, top: p3, right: c3, bottom: h3, left: f2, collisionPadding: o2 };
      }
      Iu[10] = true, Iu[32] = true, Iu[38] = true, Iu[40] = true, Iu[41] = true, Iu[43] = true, Iu[45] = true, Iu[47] = true, Iu[173] = true, Iu[183] = true, Iu[8203] = true, Iu[8208] = true, Iu[8211] = true, Iu[8231] = true;
      var Fu = function(t2) {
        function e2(e3, r2, n2, i2) {
          t2.call(this, e3, r2), this.angle = n2, void 0 !== i2 && (this.segment = i2);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.clone = function() {
          return new e2(this.x, this.y, this.angle, this.segment);
        }, e2;
      }(i);
      function Du(t2, e2) {
        var r2 = e2.expression;
        if ("constant" === r2.kind)
          return { kind: "constant", layoutSize: r2.evaluate(new si(t2 + 1)) };
        if ("source" === r2.kind)
          return { kind: "source" };
        for (var n2 = r2.zoomStops, i2 = r2.interpolationType, a2 = 0; a2 < n2.length && n2[a2] <= t2; )
          a2++;
        for (var o2 = a2 = Math.max(0, a2 - 1); o2 < n2.length && n2[o2] < t2 + 1; )
          o2++;
        o2 = Math.min(n2.length - 1, o2);
        var s2 = n2[a2], u2 = n2[o2];
        return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: u2, interpolationType: i2 } : { kind: "camera", minZoom: s2, maxZoom: u2, minSize: r2.evaluate(new si(s2)), maxSize: r2.evaluate(new si(u2)), interpolationType: i2 };
      }
      function Lu(t2, e2, r2) {
        var n2 = e2.uSize, i2 = r2.lowerSize;
        return "source" === t2.kind ? i2 / 128 : "composite" === t2.kind ? Ke(i2 / 128, r2.upperSize / 128, e2.uSizeT) : n2;
      }
      function Ou(t2, e2) {
        var r2 = 0, n2 = 0;
        if ("constant" === t2.kind)
          n2 = t2.layoutSize;
        else if ("source" !== t2.kind) {
          var i2 = t2.interpolationType, a2 = i2 ? p2(ar.interpolationFactor(i2, e2, t2.minZoom, t2.maxZoom), 0, 1) : 0;
          "camera" === t2.kind ? n2 = Ke(t2.minSize, t2.maxSize, a2) : r2 = a2;
        }
        return { uSizeT: r2, uSize: n2 };
      }
      On("Anchor", Fu);
      var Ru = Object.freeze({ __proto__: null, getSizeData: Du, evaluateSizeForFeature: Lu, evaluateSizeForZoom: Ou, SIZE_PACK_FACTOR: 128 });
      function Uu(t2, e2, r2, n2, i2) {
        if (void 0 === e2.segment)
          return true;
        for (var a2 = e2, o2 = e2.segment + 1, s2 = 0; s2 > -r2 / 2; ) {
          if (--o2 < 0)
            return false;
          s2 -= t2[o2].dist(a2), a2 = t2[o2];
        }
        s2 += t2[o2].dist(t2[o2 + 1]), o2++;
        for (var u2 = [], l2 = 0; s2 < r2 / 2; ) {
          var p3 = t2[o2], c3 = t2[o2 + 1];
          if (!c3)
            return false;
          var h3 = t2[o2 - 1].angleTo(p3) - p3.angleTo(c3);
          for (h3 = Math.abs((h3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u2.push({ distance: s2, angleDelta: h3 }), l2 += h3; s2 - u2[0].distance > n2; )
            l2 -= u2.shift().angleDelta;
          if (l2 > i2)
            return false;
          o2++, s2 += p3.dist(c3);
        }
        return true;
      }
      function ju(t2) {
        for (var e2 = 0, r2 = 0; r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function qu(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function Nu(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function Ku(t2, e2, r2, n2, i2, a2) {
        for (var o2 = qu(r2, i2, a2), s2 = Nu(r2, n2) * a2, u2 = 0, l2 = ju(t2) / 2, p3 = 0; p3 < t2.length - 1; p3++) {
          var c3 = t2[p3], h3 = t2[p3 + 1], f2 = c3.dist(h3);
          if (u2 + f2 > l2) {
            var y3 = (l2 - u2) / f2, d2 = Ke(c3.x, h3.x, y3), m2 = Ke(c3.y, h3.y, y3), v3 = new Fu(d2, m2, h3.angleTo(c3), p3);
            return v3._round(), !o2 || Uu(t2, v3, s2, o2, e2) ? v3 : void 0;
          }
          u2 += f2;
        }
      }
      function Gu(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
        var l2 = qu(n2, a2, o2), p3 = Nu(n2, i2), c3 = p3 * o2, h3 = 0 === t2[0].x || t2[0].x === u2 || 0 === t2[0].y || t2[0].y === u2;
        return e2 - c3 < e2 / 4 && (e2 = c3 + e2 / 4), function t3(e3, r3, n3, i3, a3, o3, s3, u3, l3) {
          for (var p4 = o3 / 2, c4 = ju(e3), h4 = 0, f2 = r3 - n3, y3 = [], d2 = 0; d2 < e3.length - 1; d2++) {
            for (var m2 = e3[d2], v3 = e3[d2 + 1], g2 = m2.dist(v3), x2 = v3.angleTo(m2); f2 + n3 < h4 + g2; ) {
              var b2 = ((f2 += n3) - h4) / g2, w2 = Ke(m2.x, v3.x, b2), _24 = Ke(m2.y, v3.y, b2);
              if (w2 >= 0 && w2 < l3 && _24 >= 0 && _24 < l3 && f2 - p4 >= 0 && f2 + p4 <= c4) {
                var A3 = new Fu(w2, _24, x2, d2);
                A3._round(), i3 && !Uu(e3, A3, o3, i3, a3) || y3.push(A3);
              }
            }
            h4 += g2;
          }
          return u3 || y3.length || s3 || (y3 = t3(e3, h4 / 2, n3, i3, a3, o3, s3, true, l3)), y3;
        }(t2, h3 ? e2 / 2 * s2 % e2 : (p3 / 2 + 2 * a2) * o2 * s2 % e2, e2, l2, r2, c3, h3, false, u2);
      }
      function Zu(t2, e2, r2, n2, a2) {
        for (var o2 = [], s2 = 0; s2 < t2.length; s2++)
          for (var u2 = t2[s2], l2 = void 0, p3 = 0; p3 < u2.length - 1; p3++) {
            var c3 = u2[p3], h3 = u2[p3 + 1];
            c3.x < e2 && h3.x < e2 || (c3.x < e2 ? c3 = new i(e2, c3.y + (e2 - c3.x) / (h3.x - c3.x) * (h3.y - c3.y))._round() : h3.x < e2 && (h3 = new i(e2, c3.y + (e2 - c3.x) / (h3.x - c3.x) * (h3.y - c3.y))._round()), c3.y < r2 && h3.y < r2 || (c3.y < r2 ? c3 = new i(c3.x + (r2 - c3.y) / (h3.y - c3.y) * (h3.x - c3.x), r2)._round() : h3.y < r2 && (h3 = new i(c3.x + (r2 - c3.y) / (h3.y - c3.y) * (h3.x - c3.x), r2)._round()), c3.x >= n2 && h3.x >= n2 || (c3.x >= n2 ? c3 = new i(n2, c3.y + (n2 - c3.x) / (h3.x - c3.x) * (h3.y - c3.y))._round() : h3.x >= n2 && (h3 = new i(n2, c3.y + (n2 - c3.x) / (h3.x - c3.x) * (h3.y - c3.y))._round()), c3.y >= a2 && h3.y >= a2 || (c3.y >= a2 ? c3 = new i(c3.x + (a2 - c3.y) / (h3.y - c3.y) * (h3.x - c3.x), a2)._round() : h3.y >= a2 && (h3 = new i(c3.x + (a2 - c3.y) / (h3.y - c3.y) * (h3.x - c3.x), a2)._round()), l2 && c3.equals(l2[l2.length - 1]) || o2.push(l2 = [c3]), l2.push(h3)))));
          }
        return o2;
      }
      function Xu(t2, e2, r2, n2) {
        var a2 = [], o2 = t2.image, s2 = o2.pixelRatio, u2 = o2.paddedRect.w - 2, l2 = o2.paddedRect.h - 2, p3 = t2.right - t2.left, c3 = t2.bottom - t2.top, h3 = o2.stretchX || [[0, u2]], f2 = o2.stretchY || [[0, l2]], y3 = function(t3, e3) {
          return t3 + e3[1] - e3[0];
        }, d2 = h3.reduce(y3, 0), m2 = f2.reduce(y3, 0), v3 = u2 - d2, g2 = l2 - m2, x2 = 0, b2 = d2, w2 = 0, _24 = m2, A3 = 0, S2 = v3, k2 = 0, I3 = g2;
        if (o2.content && n2) {
          var z2 = o2.content;
          x2 = Ju(h3, 0, z2[0]), w2 = Ju(f2, 0, z2[1]), b2 = Ju(h3, z2[0], z2[2]), _24 = Ju(f2, z2[1], z2[3]), A3 = z2[0] - x2, k2 = z2[1] - w2, S2 = z2[2] - z2[0] - b2, I3 = z2[3] - z2[1] - _24;
        }
        var C2 = function(n3, a3, u3, l3) {
          var h4 = Yu(n3.stretch - x2, b2, p3, t2.left), f3 = $u(n3.fixed - A3, S2, n3.stretch, d2), y4 = Yu(a3.stretch - w2, _24, c3, t2.top), v4 = $u(a3.fixed - k2, I3, a3.stretch, m2), g3 = Yu(u3.stretch - x2, b2, p3, t2.left), z3 = $u(u3.fixed - A3, S2, u3.stretch, d2), C3 = Yu(l3.stretch - w2, _24, c3, t2.top), E3 = $u(l3.fixed - k2, I3, l3.stretch, m2), P3 = new i(h4, y4), M3 = new i(g3, y4), B3 = new i(g3, C3), T3 = new i(h4, C3), V4 = new i(f3 / s2, v4 / s2), F2 = new i(z3 / s2, E3 / s2), D2 = e2 * Math.PI / 180;
          if (D2) {
            var L2 = Math.sin(D2), O3 = Math.cos(D2), R2 = [O3, -L2, L2, O3];
            P3._matMult(R2), M3._matMult(R2), T3._matMult(R2), B3._matMult(R2);
          }
          var U2 = n3.stretch + n3.fixed, j2 = a3.stretch + a3.fixed;
          return { tl: P3, tr: M3, bl: T3, br: B3, tex: { x: o2.paddedRect.x + 1 + U2, y: o2.paddedRect.y + 1 + j2, w: u3.stretch + u3.fixed - U2, h: l3.stretch + l3.fixed - j2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V4, pixelOffsetBR: F2, minFontScaleX: S2 / s2 / p3, minFontScaleY: I3 / s2 / c3, isSDF: r2 };
        };
        if (n2 && (o2.stretchX || o2.stretchY))
          for (var E2 = Hu(h3, v3, d2), P2 = Hu(f2, g2, m2), M2 = 0; M2 < E2.length - 1; M2++)
            for (var B2 = E2[M2], T2 = E2[M2 + 1], V3 = 0; V3 < P2.length - 1; V3++)
              a2.push(C2(B2, P2[V3], T2, P2[V3 + 1]));
        else
          a2.push(C2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: u2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
        return a2;
      }
      function Ju(t2, e2, r2) {
        for (var n2 = 0, i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
          var o2 = a2[i2];
          n2 += Math.max(e2, Math.min(r2, o2[1])) - Math.max(e2, Math.min(r2, o2[0]));
        }
        return n2;
      }
      function Hu(t2, e2, r2) {
        for (var n2 = [{ fixed: -1, stretch: 0 }], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
          var o2 = a2[i2], s2 = o2[0], u2 = o2[1], l2 = n2[n2.length - 1];
          n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch }), n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch + (u2 - s2) });
        }
        return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
      }
      function Yu(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function $u(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }
      var Wu = function(t2, e2, r2, n2, a2, o2, s2, u2, l2, p3) {
        if (this.boxStartIndex = t2.length, l2) {
          var c3 = o2.top, h3 = o2.bottom, f2 = o2.collisionPadding;
          f2 && (c3 -= f2[1], h3 += f2[3]);
          var y3 = h3 - c3;
          y3 > 0 && (y3 = Math.max(10, y3), this.circleDiameter = y3);
        } else {
          var d2 = o2.top * s2 - u2, m2 = o2.bottom * s2 + u2, v3 = o2.left * s2 - u2, g2 = o2.right * s2 + u2, x2 = o2.collisionPadding;
          if (x2 && (v3 -= x2[0] * s2, d2 -= x2[1] * s2, g2 += x2[2] * s2, m2 += x2[3] * s2), p3) {
            var b2 = new i(v3, d2), w2 = new i(g2, d2), _24 = new i(v3, m2), A3 = new i(g2, m2), S2 = p3 * Math.PI / 180;
            b2._rotate(S2), w2._rotate(S2), _24._rotate(S2), A3._rotate(S2), v3 = Math.min(b2.x, w2.x, _24.x, A3.x), g2 = Math.max(b2.x, w2.x, _24.x, A3.x), d2 = Math.min(b2.y, w2.y, _24.y, A3.y), m2 = Math.max(b2.y, w2.y, _24.y, A3.y);
          }
          t2.emplaceBack(e2.x, e2.y, v3, d2, g2, m2, r2, n2, a2);
        }
        this.boxEndIndex = t2.length;
      }, Qu = function(t2, e2) {
        if (void 0 === t2 && (t2 = []), void 0 === e2 && (e2 = tl), this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
          for (var r2 = (this.length >> 1) - 1; r2 >= 0; r2--)
            this._down(r2);
      };
      function tl(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function el(t2, e2, r2) {
        void 0 === e2 && (e2 = 1), void 0 === r2 && (r2 = false);
        for (var n2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, u2 = t2[0], l2 = 0; l2 < u2.length; l2++) {
          var p3 = u2[l2];
          (!l2 || p3.x < n2) && (n2 = p3.x), (!l2 || p3.y < a2) && (a2 = p3.y), (!l2 || p3.x > o2) && (o2 = p3.x), (!l2 || p3.y > s2) && (s2 = p3.y);
        }
        var c3 = Math.min(o2 - n2, s2 - a2), h3 = c3 / 2, f2 = new Qu([], rl);
        if (0 === c3)
          return new i(n2, a2);
        for (var y3 = n2; y3 < o2; y3 += c3)
          for (var d2 = a2; d2 < s2; d2 += c3)
            f2.push(new nl(y3 + h3, d2 + h3, h3, t2));
        for (var m2 = function(t3) {
          for (var e3 = 0, r3 = 0, n3 = 0, i2 = t3[0], a3 = 0, o3 = i2.length, s3 = o3 - 1; a3 < o3; s3 = a3++) {
            var u3 = i2[a3], l3 = i2[s3], p4 = u3.x * l3.y - l3.x * u3.y;
            r3 += (u3.x + l3.x) * p4, n3 += (u3.y + l3.y) * p4, e3 += 3 * p4;
          }
          return new nl(r3 / e3, n3 / e3, 0, t3);
        }(t2), v3 = f2.length; f2.length; ) {
          var g2 = f2.pop();
          (g2.d > m2.d || !m2.d) && (m2 = g2, r2 && console.log("found best %d after %d probes", Math.round(1e4 * g2.d) / 1e4, v3)), g2.max - m2.d <= e2 || (f2.push(new nl(g2.p.x - (h3 = g2.h / 2), g2.p.y - h3, h3, t2)), f2.push(new nl(g2.p.x + h3, g2.p.y - h3, h3, t2)), f2.push(new nl(g2.p.x - h3, g2.p.y + h3, h3, t2)), f2.push(new nl(g2.p.x + h3, g2.p.y + h3, h3, t2)), v3 += 4);
        }
        return r2 && (console.log("num probes: " + v3), console.log("best distance: " + m2.d)), m2.p;
      }
      function rl(t2, e2) {
        return e2.max - t2.max;
      }
      function nl(t2, e2, r2, n2) {
        this.p = new i(t2, e2), this.h = r2, this.d = function(t3, e3) {
          for (var r3 = false, n3 = 1 / 0, i2 = 0; i2 < e3.length; i2++)
            for (var a2 = e3[i2], o2 = 0, s2 = a2.length, u2 = s2 - 1; o2 < s2; u2 = o2++) {
              var l2 = a2[o2], p3 = a2[u2];
              l2.y > t3.y != p3.y > t3.y && t3.x < (p3.x - l2.x) * (t3.y - l2.y) / (p3.y - l2.y) + l2.x && (r3 = !r3), n3 = Math.min(n3, Ya(t3, l2, p3));
            }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      Qu.prototype.push = function(t2) {
        this.data.push(t2), this.length++, this._up(this.length - 1);
      }, Qu.prototype.pop = function() {
        if (0 !== this.length) {
          var t2 = this.data[0], e2 = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
      }, Qu.prototype.peek = function() {
        return this.data[0];
      }, Qu.prototype._up = function(t2) {
        for (var e2 = this.data, r2 = this.compare, n2 = e2[t2]; t2 > 0; ) {
          var i2 = t2 - 1 >> 1, a2 = e2[i2];
          if (r2(n2, a2) >= 0)
            break;
          e2[t2] = a2, t2 = i2;
        }
        e2[t2] = n2;
      }, Qu.prototype._down = function(t2) {
        for (var e2 = this.data, r2 = this.compare, n2 = this.length >> 1, i2 = e2[t2]; t2 < n2; ) {
          var a2 = 1 + (t2 << 1), o2 = e2[a2], s2 = a2 + 1;
          if (s2 < this.length && r2(e2[s2], o2) < 0 && (a2 = s2, o2 = e2[s2]), r2(o2, i2) >= 0)
            break;
          e2[t2] = o2, t2 = a2;
        }
        e2[t2] = i2;
      };
      var il = Number.POSITIVE_INFINITY;
      function al(t2, e2) {
        return e2[1] !== il ? function(t3, e3, r2) {
          var n2 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = 7 - r2;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e3;
          }
          return [n2, i2];
        }(t2, e2[0], e2[1]) : function(t3, e3) {
          var r2 = 0, n2 = 0;
          e3 < 0 && (e3 = 0);
          var i2 = e3 / Math.sqrt(2);
          switch (t3) {
            case "top-right":
            case "top-left":
              n2 = i2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = 7 - i2;
              break;
            case "bottom":
              n2 = 7 - e3;
              break;
            case "top":
              n2 = e3 - 7;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
              r2 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i2;
              break;
            case "left":
              r2 = e3;
              break;
            case "right":
              r2 = -e3;
          }
          return [r2, n2];
        }(t2, e2[0]);
      }
      function ol(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function sl(t2, e2, r2, n2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2) {
        var m2 = function(t3, e3, r3, n3, a3, o3, s3, u3) {
          for (var l3 = n3.layout.get("text-rotate").evaluate(o3, {}) * Math.PI / 180, p4 = [], c4 = 0, h4 = e3.positionedLines; c4 < h4.length; c4 += 1)
            for (var f3 = h4[c4], y4 = 0, d3 = f3.positionedGlyphs; y4 < d3.length; y4 += 1) {
              var m3 = d3[y4];
              if (m3.rect) {
                var v4 = m3.rect || {}, g3 = 4, x3 = true, b3 = 1, w2 = 0, _24 = (a3 || u3) && m3.vertical, A3 = m3.metrics.advance * m3.scale / 2;
                if (u3 && e3.verticalizable && (w2 = f3.lineOffset / 2 - (m3.imageName ? -(24 - m3.metrics.width * m3.scale) / 2 : 24 * (m3.scale - 1))), m3.imageName) {
                  var S2 = s3[m3.imageName];
                  x3 = S2.sdf, g3 = 1 / (b3 = S2.pixelRatio);
                }
                var k2 = a3 ? [m3.x + A3, m3.y] : [0, 0], I3 = a3 ? [0, 0] : [m3.x + A3 + r3[0], m3.y + r3[1] - w2], z2 = [0, 0];
                _24 && (z2 = I3, I3 = [0, 0]);
                var C2 = (m3.metrics.left - g3) * m3.scale - A3 + I3[0], E2 = (-m3.metrics.top - g3) * m3.scale + I3[1], P2 = C2 + v4.w * m3.scale / b3, M2 = E2 + v4.h * m3.scale / b3, B2 = new i(C2, E2), T2 = new i(P2, E2), V3 = new i(C2, M2), F2 = new i(P2, M2);
                if (_24) {
                  var D2 = new i(-A3, A3 - -17), L2 = -Math.PI / 2, O3 = 12 - A3, R2 = new i(22 - O3, -(m3.imageName ? O3 : 0)), U2 = new (Function.prototype.bind.apply(i, [null].concat(z2)))();
                  B2._rotateAround(L2, D2)._add(R2)._add(U2), T2._rotateAround(L2, D2)._add(R2)._add(U2), V3._rotateAround(L2, D2)._add(R2)._add(U2), F2._rotateAround(L2, D2)._add(R2)._add(U2);
                }
                if (l3) {
                  var j2 = Math.sin(l3), q2 = Math.cos(l3), N2 = [q2, -j2, j2, q2];
                  B2._matMult(N2), T2._matMult(N2), V3._matMult(N2), F2._matMult(N2);
                }
                var K2 = new i(0, 0), G2 = new i(0, 0);
                p4.push({ tl: B2, tr: T2, bl: V3, br: F2, tex: v4, writingMode: e3.writingMode, glyphOffset: k2, sectionIndex: m3.sectionIndex, isSDF: x3, pixelOffsetTL: K2, pixelOffsetBR: G2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
          return p4;
        }(0, r2, u2, a2, o2, s2, n2, t2.allowVerticalPlacement), v3 = t2.textSizeData, g2 = null;
        "source" === v3.kind ? (g2 = [128 * a2.layout.get("text-size").evaluate(s2, {})])[0] > 32640 && A2(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === v3.kind && ((g2 = [128 * y3.compositeTextSizes[0].evaluate(s2, {}, d2), 128 * y3.compositeTextSizes[1].evaluate(s2, {}, d2)])[0] > 32640 || g2[1] > 32640) && A2(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t2.addSymbols(t2.text, m2, g2, u2, o2, s2, p3, e2, l2.lineStartIndex, l2.lineLength, f2, d2);
        for (var x2 = 0, b2 = c3; x2 < b2.length; x2 += 1)
          h3[b2[x2]] = t2.text.placedSymbolArray.length - 1;
        return 4 * m2.length;
      }
      function ul(t2) {
        for (var e2 in t2)
          return t2[e2];
        return null;
      }
      function ll(t2, e2, r2, n2) {
        var i2 = t2.compareText;
        if (e2 in i2) {
          for (var a2 = i2[e2], o2 = a2.length - 1; o2 >= 0; o2--)
            if (n2.dist(a2[o2]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      var pl = bs.VectorTileFeature.types, cl = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function hl(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3, h3) {
        var f2 = s2 ? Math.min(32640, Math.round(s2[0])) : 0, y3 = s2 ? Math.min(32640, Math.round(s2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), a2, o2, (f2 << 1) + (u2 ? 1 : 0), y3, 16 * l2, 16 * p3, 256 * c3, 256 * h3);
      }
      function fl(t2, e2, r2) {
        t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
      }
      function yl(t2) {
        for (var e2 = 0, r2 = t2.sections; e2 < r2.length; e2 += 1)
          if ($n(r2[e2].text))
            return true;
        return false;
      }
      var dl = function(t2) {
        this.layoutVertexArray = new Vi(), this.indexArray = new ji(), this.programConfigurations = t2, this.segments = new sa(), this.dynamicLayoutVertexArray = new Fi(), this.opacityVertexArray = new Di(), this.placedSymbolArray = new Qi();
      };
      dl.prototype.isEmpty = function() {
        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
      }, dl.prototype.upload = function(t2, e2, r2, n2) {
        this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, js.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, qs.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, cl, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
      }, dl.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }, On("SymbolBuffers", dl);
      var ml = function(t2, e2, r2) {
        this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new sa(), this.collisionVertexArray = new Ui();
      };
      ml.prototype.upload = function(t2) {
        this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ns.members, true);
      }, ml.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
      }, On("CollisionBuffers", ml);
      var vl = function(t2) {
        this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
          return t3.id;
        }), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = oo([]), this.placementViewportMatrix = oo([]);
        var e2 = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = Du(this.zoom, e2["text-size"]), this.iconSizeData = Du(this.zoom, e2["icon-size"]);
        var r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
        this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === r2.get("symbol-placement") && (this.writingModes = r2.get("text-writing-mode").map(function(t3) {
          return wu[t3];
        })), this.stateDependentLayerIds = this.layers.filter(function(t3) {
          return t3.isStateDependent();
        }).map(function(t3) {
          return t3.id;
        }), this.sourceID = t2.sourceID;
      };
      vl.prototype.createArrays = function() {
        this.text = new dl(new Va(this.layers, this.zoom, function(t2) {
          return /^text/.test(t2);
        })), this.icon = new dl(new Va(this.layers, this.zoom, function(t2) {
          return /^icon/.test(t2);
        })), this.glyphOffsetArray = new ra(), this.lineVertexArray = new na(), this.symbolInstances = new ea();
      }, vl.prototype.calculateGlyphDependencies = function(t2, e2, r2, n2, i2) {
        for (var a2 = 0; a2 < t2.length; a2++)
          if (e2[t2.charCodeAt(a2)] = true, (r2 || n2) && i2) {
            var o2 = Xs[t2.charAt(a2)];
            o2 && (e2[o2.charCodeAt(0)] = true);
          }
      }, vl.prototype.populate = function(t2, e2, r2) {
        var n2 = this.layers[0], i2 = n2.layout, a2 = i2.get("text-font"), o2 = i2.get("text-field"), s2 = i2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof ne && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), l2 = "constant" !== s2.value.kind || !!s2.value.value || Object.keys(s2.parameters).length > 0, p3 = i2.get("symbol-sort-key");
        if (this.features = [], u2 || l2) {
          for (var c3 = e2.iconDependencies, h3 = e2.glyphDependencies, f2 = e2.availableImages, y3 = new si(this.zoom), d2 = 0, m2 = t2; d2 < m2.length; d2 += 1) {
            var v3 = m2[d2], g2 = v3.feature, x2 = v3.id, b2 = v3.index, w2 = v3.sourceLayerIndex, _24 = n2._featureFilter.needGeometry, A3 = Ua(g2, _24);
            if (n2._featureFilter.filter(y3, A3, r2)) {
              _24 || (A3.geometry = Ra(g2));
              var S2 = void 0;
              if (u2) {
                var k2 = n2.getValueAndResolveTokens("text-field", A3, r2, f2), I3 = ne.factory(k2);
                yl(I3) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ii() || this.hasRTLText && oi.isParsed()) && (S2 = Zs(I3, n2, A3));
              }
              var z2 = void 0;
              if (l2) {
                var C2 = n2.getValueAndResolveTokens("icon-image", A3, r2, f2);
                z2 = C2 instanceof ie ? C2 : ie.fromString(C2);
              }
              if (S2 || z2) {
                var E2 = this.sortFeaturesByKey ? p3.evaluate(A3, {}, r2) : void 0;
                if (this.features.push({ id: x2, text: S2, icon: z2, index: b2, sourceLayerIndex: w2, geometry: A3.geometry, properties: g2.properties, type: pl[g2.type], sortKey: E2 }), z2 && (c3[z2.name] = true), S2) {
                  var P2 = a2.evaluate(A3, {}, r2).join(","), M2 = "map" === i2.get("text-rotation-alignment") && "point" !== i2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(wu.vertical) >= 0;
                  for (var B2 = 0, T2 = S2.sections; B2 < T2.length; B2 += 1) {
                    var V3 = T2[B2];
                    if (V3.image)
                      c3[V3.image.name] = true;
                    else {
                      var F2 = Zn(S2.toString()), D2 = V3.fontStack || P2, L2 = h3[D2] = h3[D2] || {};
                      this.calculateGlyphDependencies(V3.text, L2, M2, this.allowVerticalPlacement, F2);
                    }
                  }
                }
              }
            }
          }
          "line" === i2.get("symbol-placement") && (this.features = function(t3) {
            var e3 = {}, r3 = {}, n3 = [], i3 = 0;
            function a3(e4) {
              n3.push(t3[e4]), i3++;
            }
            function o3(t4, e4, i4) {
              var a4 = r3[t4];
              return delete r3[t4], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i4[0]), a4;
            }
            function s3(t4, r4, i4) {
              var a4 = e3[r4];
              return delete e3[r4], e3[t4] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i4[0].concat(n3[a4].geometry[0]), a4;
            }
            function u3(t4, e4, r4) {
              var n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return t4 + ":" + n4.x + ":" + n4.y;
            }
            for (var l3 = 0; l3 < t3.length; l3++) {
              var p4 = t3[l3], c4 = p4.geometry, h4 = p4.text ? p4.text.toString() : null;
              if (h4) {
                var f3 = u3(h4, c4), y4 = u3(h4, c4, true);
                if (f3 in r3 && y4 in e3 && r3[f3] !== e3[y4]) {
                  var d3 = s3(f3, y4, c4), m3 = o3(f3, y4, n3[d3].geometry);
                  delete e3[f3], delete r3[y4], r3[u3(h4, n3[m3].geometry, true)] = m3, n3[d3].geometry = null;
                } else
                  f3 in r3 ? o3(f3, y4, c4) : y4 in e3 ? s3(f3, y4, c4) : (a3(l3), e3[f3] = i3 - 1, r3[y4] = i3 - 1);
              } else
                a3(l3);
            }
            return n3.filter(function(t4) {
              return t4.geometry;
            });
          }(this.features)), this.sortFeaturesByKey && this.features.sort(function(t3, e3) {
            return t3.sortKey - e3.sortKey;
          });
        }
      }, vl.prototype.update = function(t2, e2, r2) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
      }, vl.prototype.isEmpty = function() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }, vl.prototype.uploadPending = function() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }, vl.prototype.upload = function(t2) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
      }, vl.prototype.destroyDebugData = function() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }, vl.prototype.destroy = function() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }, vl.prototype.addToLineVertexArray = function(t2, e2) {
        var r2 = this.lineVertexArray.length;
        if (void 0 !== t2.segment) {
          for (var n2 = t2.dist(e2[t2.segment + 1]), i2 = t2.dist(e2[t2.segment]), a2 = {}, o2 = t2.segment + 1; o2 < e2.length; o2++)
            a2[o2] = { x: e2[o2].x, y: e2[o2].y, tileUnitDistanceFromAnchor: n2 }, o2 < e2.length - 1 && (n2 += e2[o2 + 1].dist(e2[o2]));
          for (var s2 = t2.segment || 0; s2 >= 0; s2--)
            a2[s2] = { x: e2[s2].x, y: e2[s2].y, tileUnitDistanceFromAnchor: i2 }, s2 > 0 && (i2 += e2[s2 - 1].dist(e2[s2]));
          for (var u2 = 0; u2 < e2.length; u2++) {
            var l2 = a2[u2];
            this.lineVertexArray.emplaceBack(l2.x, l2.y, l2.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
      }, vl.prototype.addSymbols = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p3, c3) {
        for (var h3 = t2.indexArray, f2 = t2.layoutVertexArray, y3 = t2.segments.prepareSegment(4 * e2.length, f2, h3, this.canOverlap ? a2.sortKey : void 0), d2 = this.glyphOffsetArray.length, m2 = y3.vertexLength, v3 = this.allowVerticalPlacement && o2 === wu.vertical ? Math.PI / 2 : 0, g2 = a2.text && a2.text.sections, x2 = 0; x2 < e2.length; x2++) {
          var b2 = e2[x2], w2 = b2.tl, _24 = b2.tr, A3 = b2.bl, S2 = b2.br, k2 = b2.tex, I3 = b2.pixelOffsetTL, z2 = b2.pixelOffsetBR, C2 = b2.minFontScaleX, E2 = b2.minFontScaleY, P2 = b2.glyphOffset, M2 = b2.isSDF, B2 = b2.sectionIndex, T2 = y3.vertexLength, V3 = P2[1];
          hl(f2, s2.x, s2.y, w2.x, V3 + w2.y, k2.x, k2.y, r2, M2, I3.x, I3.y, C2, E2), hl(f2, s2.x, s2.y, _24.x, V3 + _24.y, k2.x + k2.w, k2.y, r2, M2, z2.x, I3.y, C2, E2), hl(f2, s2.x, s2.y, A3.x, V3 + A3.y, k2.x, k2.y + k2.h, r2, M2, I3.x, z2.y, C2, E2), hl(f2, s2.x, s2.y, S2.x, V3 + S2.y, k2.x + k2.w, k2.y + k2.h, r2, M2, z2.x, z2.y, C2, E2), fl(t2.dynamicLayoutVertexArray, s2, v3), h3.emplaceBack(T2, T2 + 1, T2 + 2), h3.emplaceBack(T2 + 1, T2 + 2, T2 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P2[0]), x2 !== e2.length - 1 && B2 === e2[x2 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(f2.length, a2, a2.index, {}, c3, g2 && g2[B2]);
        }
        t2.placedSymbolArray.emplaceBack(s2.x, s2.y, d2, this.glyphOffsetArray.length - d2, m2, u2, l2, s2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], o2, 0, false, 0, p3);
      }, vl.prototype._addCollisionDebugVertex = function(t2, e2, r2, n2, i2, a2) {
        return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(a2.x), Math.round(a2.y));
      }, vl.prototype.addCollisionDebugVertices = function(t2, e2, r2, n2, a2, o2, s2) {
        var u2 = a2.segments.prepareSegment(4, a2.layoutVertexArray, a2.indexArray), l2 = u2.vertexLength, p3 = a2.layoutVertexArray, c3 = a2.collisionVertexArray, h3 = s2.anchorX, f2 = s2.anchorY;
        this._addCollisionDebugVertex(p3, c3, o2, h3, f2, new i(t2, e2)), this._addCollisionDebugVertex(p3, c3, o2, h3, f2, new i(r2, e2)), this._addCollisionDebugVertex(p3, c3, o2, h3, f2, new i(r2, n2)), this._addCollisionDebugVertex(p3, c3, o2, h3, f2, new i(t2, n2)), u2.vertexLength += 4;
        var y3 = a2.indexArray;
        y3.emplaceBack(l2, l2 + 1), y3.emplaceBack(l2 + 1, l2 + 2), y3.emplaceBack(l2 + 2, l2 + 3), y3.emplaceBack(l2 + 3, l2), u2.primitiveLength += 4;
      }, vl.prototype.addDebugCollisionBoxes = function(t2, e2, r2, n2) {
        for (var i2 = t2; i2 < e2; i2++) {
          var a2 = this.collisionBoxArray.get(i2);
          this.addCollisionDebugVertices(a2.x1, a2.y1, a2.x2, a2.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, a2.anchorPoint, r2);
        }
      }, vl.prototype.generateCollisionDebugBuffers = function() {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ml(Oi, Ks.members, Xi), this.iconCollisionBox = new ml(Oi, Ks.members, Xi);
        for (var t2 = 0; t2 < this.symbolInstances.length; t2++) {
          var e2 = this.symbolInstances.get(t2);
          this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
        }
      }, vl.prototype._deserializeCollisionBoxesForSymbol = function(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
        for (var l2 = {}, p3 = e2; p3 < r2; p3++) {
          var c3 = t2.get(p3);
          l2.textBox = { x1: c3.x1, y1: c3.y1, x2: c3.x2, y2: c3.y2, anchorPointX: c3.anchorPointX, anchorPointY: c3.anchorPointY }, l2.textFeatureIndex = c3.featureIndex;
          break;
        }
        for (var h3 = n2; h3 < i2; h3++) {
          var f2 = t2.get(h3);
          l2.verticalTextBox = { x1: f2.x1, y1: f2.y1, x2: f2.x2, y2: f2.y2, anchorPointX: f2.anchorPointX, anchorPointY: f2.anchorPointY }, l2.verticalTextFeatureIndex = f2.featureIndex;
          break;
        }
        for (var y3 = a2; y3 < o2; y3++) {
          var d2 = t2.get(y3);
          l2.iconBox = { x1: d2.x1, y1: d2.y1, x2: d2.x2, y2: d2.y2, anchorPointX: d2.anchorPointX, anchorPointY: d2.anchorPointY }, l2.iconFeatureIndex = d2.featureIndex;
          break;
        }
        for (var m2 = s2; m2 < u2; m2++) {
          var v3 = t2.get(m2);
          l2.verticalIconBox = { x1: v3.x1, y1: v3.y1, x2: v3.x2, y2: v3.y2, anchorPointX: v3.anchorPointX, anchorPointY: v3.anchorPointY }, l2.verticalIconFeatureIndex = v3.featureIndex;
          break;
        }
        return l2;
      }, vl.prototype.deserializeCollisionBoxes = function(t2) {
        this.collisionArrays = [];
        for (var e2 = 0; e2 < this.symbolInstances.length; e2++) {
          var r2 = this.symbolInstances.get(e2);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
        }
      }, vl.prototype.hasTextData = function() {
        return this.text.segments.get().length > 0;
      }, vl.prototype.hasIconData = function() {
        return this.icon.segments.get().length > 0;
      }, vl.prototype.hasDebugData = function() {
        return this.textCollisionBox && this.iconCollisionBox;
      }, vl.prototype.hasTextCollisionBoxData = function() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }, vl.prototype.hasIconCollisionBoxData = function() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }, vl.prototype.addIndicesForPlacedSymbol = function(t2, e2) {
        for (var r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs, i2 = r2.vertexStartIndex; i2 < n2; i2 += 4)
          t2.indexArray.emplaceBack(i2, i2 + 1, i2 + 2), t2.indexArray.emplaceBack(i2 + 1, i2 + 2, i2 + 3);
      }, vl.prototype.getSortedSymbolIndexes = function(t2) {
        if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
          return this.symbolInstanceIndexes;
        for (var e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], a2 = [], o2 = 0; o2 < this.symbolInstances.length; ++o2) {
          a2.push(o2);
          var s2 = this.symbolInstances.get(o2);
          n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i2.push(s2.featureIndex);
        }
        return a2.sort(function(t3, e3) {
          return n2[t3] - n2[e3] || i2[e3] - i2[t3];
        }), a2;
      }, vl.prototype.addToSortKeyRanges = function(t2, e2) {
        var r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
      }, vl.prototype.sortFeatures = function(t2) {
        var e2 = this;
        if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (var r2 = 0, n2 = this.symbolInstanceIndexes; r2 < n2.length; r2 += 1) {
            var i2 = this.symbolInstances.get(n2[r2]);
            this.featureSortOrder.push(i2.featureIndex), [i2.rightJustifiedTextSymbolIndex, i2.centerJustifiedTextSymbolIndex, i2.leftJustifiedTextSymbolIndex].forEach(function(t3, r3, n3) {
              t3 >= 0 && n3.indexOf(t3) === r3 && e2.addIndicesForPlacedSymbol(e2.text, t3);
            }), i2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i2.verticalPlacedTextSymbolIndex), i2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i2.placedIconSymbolIndex), i2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i2.verticalPlacedIconSymbolIndex);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }, On("SymbolBucket", vl, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), vl.MAX_GLYPHS = 65535, vl.addDynamicAttributes = fl;
      var gl = new wi({ "symbol-placement": new mi(Et.layout_symbol["symbol-placement"]), "symbol-spacing": new mi(Et.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new mi(Et.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new vi(Et.layout_symbol["symbol-sort-key"]), "symbol-z-order": new mi(Et.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new mi(Et.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new mi(Et.layout_symbol["icon-ignore-placement"]), "icon-optional": new mi(Et.layout_symbol["icon-optional"]), "icon-rotation-alignment": new mi(Et.layout_symbol["icon-rotation-alignment"]), "icon-size": new vi(Et.layout_symbol["icon-size"]), "icon-text-fit": new mi(Et.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new mi(Et.layout_symbol["icon-text-fit-padding"]), "icon-image": new vi(Et.layout_symbol["icon-image"]), "icon-rotate": new vi(Et.layout_symbol["icon-rotate"]), "icon-padding": new mi(Et.layout_symbol["icon-padding"]), "icon-keep-upright": new mi(Et.layout_symbol["icon-keep-upright"]), "icon-offset": new vi(Et.layout_symbol["icon-offset"]), "icon-anchor": new vi(Et.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new mi(Et.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new mi(Et.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new mi(Et.layout_symbol["text-rotation-alignment"]), "text-field": new vi(Et.layout_symbol["text-field"]), "text-font": new vi(Et.layout_symbol["text-font"]), "text-size": new vi(Et.layout_symbol["text-size"]), "text-max-width": new vi(Et.layout_symbol["text-max-width"]), "text-line-height": new mi(Et.layout_symbol["text-line-height"]), "text-letter-spacing": new vi(Et.layout_symbol["text-letter-spacing"]), "text-justify": new vi(Et.layout_symbol["text-justify"]), "text-radial-offset": new vi(Et.layout_symbol["text-radial-offset"]), "text-variable-anchor": new mi(Et.layout_symbol["text-variable-anchor"]), "text-anchor": new vi(Et.layout_symbol["text-anchor"]), "text-max-angle": new mi(Et.layout_symbol["text-max-angle"]), "text-writing-mode": new mi(Et.layout_symbol["text-writing-mode"]), "text-rotate": new vi(Et.layout_symbol["text-rotate"]), "text-padding": new mi(Et.layout_symbol["text-padding"]), "text-keep-upright": new mi(Et.layout_symbol["text-keep-upright"]), "text-transform": new vi(Et.layout_symbol["text-transform"]), "text-offset": new vi(Et.layout_symbol["text-offset"]), "text-allow-overlap": new mi(Et.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new mi(Et.layout_symbol["text-ignore-placement"]), "text-optional": new mi(Et.layout_symbol["text-optional"]) }), xl = { paint: new wi({ "icon-opacity": new vi(Et.paint_symbol["icon-opacity"]), "icon-color": new vi(Et.paint_symbol["icon-color"]), "icon-halo-color": new vi(Et.paint_symbol["icon-halo-color"]), "icon-halo-width": new vi(Et.paint_symbol["icon-halo-width"]), "icon-halo-blur": new vi(Et.paint_symbol["icon-halo-blur"]), "icon-translate": new mi(Et.paint_symbol["icon-translate"]), "icon-translate-anchor": new mi(Et.paint_symbol["icon-translate-anchor"]), "text-opacity": new vi(Et.paint_symbol["text-opacity"]), "text-color": new vi(Et.paint_symbol["text-color"], { runtimeType: jt, getOverride: function(t2) {
        return t2.textColor;
      }, hasOverride: function(t2) {
        return !!t2.textColor;
      } }), "text-halo-color": new vi(Et.paint_symbol["text-halo-color"]), "text-halo-width": new vi(Et.paint_symbol["text-halo-width"]), "text-halo-blur": new vi(Et.paint_symbol["text-halo-blur"]), "text-translate": new mi(Et.paint_symbol["text-translate"]), "text-translate-anchor": new mi(Et.paint_symbol["text-translate-anchor"]) }), layout: gl }, bl = function(t2) {
        this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Lt, this.defaultValue = t2;
      };
      bl.prototype.evaluate = function(t2) {
        if (t2.formattedSection) {
          var e2 = this.defaultValue.property.overrides;
          if (e2 && e2.hasOverride(t2.formattedSection))
            return e2.getOverride(t2.formattedSection);
        }
        return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
      }, bl.prototype.eachChild = function(t2) {
        this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
      }, bl.prototype.outputDefined = function() {
        return false;
      }, bl.prototype.serialize = function() {
        return null;
      }, On("FormatSectionOverride", bl, { omit: ["defaultValue"] });
      var wl = function(t2) {
        function e2(e3) {
          t2.call(this, e3, xl);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
          if (t2.prototype.recalculate.call(this, e3, r2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
            var n2 = this.layout.get("text-writing-mode");
            if (n2) {
              for (var i2 = [], a2 = 0, o2 = n2; a2 < o2.length; a2 += 1) {
                var s2 = o2[a2];
                i2.indexOf(s2) < 0 && i2.push(s2);
              }
              this.layout._values["text-writing-mode"] = i2;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }, e2.prototype.getValueAndResolveTokens = function(t3, e3, r2, n2) {
          var i2 = this.layout.get(t3).evaluate(e3, {}, r2, n2), a2 = this._unevaluatedLayout._values[t3];
          return a2.isDataDriven() || Gr(a2.value) || !i2 ? i2 : function(t4, e4) {
            return e4.replace(/{([^{}]+)}/g, function(e5, r3) {
              return r3 in t4 ? String(t4[r3]) : "";
            });
          }(e3.properties, i2);
        }, e2.prototype.createBucket = function(t3) {
          return new vl(t3);
        }, e2.prototype.queryRadius = function() {
          return 0;
        }, e2.prototype.queryIntersectsFeature = function() {
          return false;
        }, e2.prototype._setPaintOverrides = function() {
          for (var t3 = 0, r2 = xl.paint.overridableProperties; t3 < r2.length; t3 += 1) {
            var n2 = r2[t3];
            if (e2.hasPaintOverride(this.layout, n2)) {
              var i2, a2 = this.paint.get(n2), o2 = new bl(a2), s2 = new Kr(o2, a2.property.specification);
              i2 = "constant" === a2.value.kind || "source" === a2.value.kind ? new Xr("source", s2) : new Jr("composite", s2, a2.value.zoomStops, a2.value._interpolationType), this.paint._values[n2] = new yi(a2.property, i2, a2.parameters);
            }
          }
        }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, r2, n2) {
          return !(!this.layout || r2.isDataDriven() || n2.isDataDriven()) && e2.hasPaintOverride(this.layout, t3);
        }, e2.hasPaintOverride = function(t3, e3) {
          var r2 = t3.get("text-field"), n2 = xl.paint.properties[e3], i2 = false, a2 = function(t4) {
            for (var e4 = 0, r3 = t4; e4 < r3.length; e4 += 1)
              if (n2.overrides && n2.overrides.hasOverride(r3[e4]))
                return void (i2 = true);
          };
          if ("constant" === r2.value.kind && r2.value.value instanceof ne)
            a2(r2.value.value.sections);
          else if ("source" === r2.value.kind) {
            var o2 = function(t4) {
              i2 || (t4 instanceof le && se(t4.value) === Gt ? a2(t4.value.sections) : t4 instanceof fe ? a2(t4.sections) : t4.eachChild(o2));
            }, s2 = r2.value;
            s2._styleExpression && o2(s2._styleExpression.expression);
          }
          return i2;
        }, e2;
      }(_i), _l = { paint: new wi({ "background-color": new mi(Et.paint_background["background-color"]), "background-pattern": new xi(Et.paint_background["background-pattern"]), "background-opacity": new mi(Et.paint_background["background-opacity"]) }) }, Al = function(t2) {
        function e2(e3) {
          t2.call(this, e3, _l);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(_i), Sl = { paint: new wi({ "raster-opacity": new mi(Et.paint_raster["raster-opacity"]), "raster-hue-rotate": new mi(Et.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new mi(Et.paint_raster["raster-brightness-min"]), "raster-brightness-max": new mi(Et.paint_raster["raster-brightness-max"]), "raster-saturation": new mi(Et.paint_raster["raster-saturation"]), "raster-contrast": new mi(Et.paint_raster["raster-contrast"]), "raster-resampling": new mi(Et.paint_raster["raster-resampling"]), "raster-fade-duration": new mi(Et.paint_raster["raster-fade-duration"]) }) }, kl = function(t2) {
        function e2(e3) {
          t2.call(this, e3, Sl);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(_i), Il = function(t2) {
        function e2(e3) {
          t2.call(this, e3, {}), this.implementation = e3;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.is3D = function() {
          return "3d" === this.implementation.renderingMode;
        }, e2.prototype.hasOffscreenPass = function() {
          return void 0 !== this.implementation.prerender;
        }, e2.prototype.recalculate = function() {
        }, e2.prototype.updateTransitions = function() {
        }, e2.prototype.hasTransition = function() {
        }, e2.prototype.serialize = function() {
        }, e2.prototype.onAdd = function(t3) {
          this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
        }, e2.prototype.onRemove = function(t3) {
          this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
        }, e2;
      }(_i), zl = { circle: co, heatmap: _o, hillshade: So, fill: ps, "fill-extrusion": zs, line: Rs, symbol: wl, background: Al, raster: kl }, Cl = o.HTMLImageElement, El = o.HTMLCanvasElement, Pl = o.HTMLVideoElement, Ml = o.ImageData, Bl = o.ImageBitmap, Tl = function(t2, e2, r2, n2) {
        this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
      };
      Tl.prototype.update = function(t2, e2, r2) {
        var n2 = t2.width, i2 = t2.height, a2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), o2 = this.context, s2 = o2.gl;
        if (this.useMipmap = Boolean(e2 && e2.useMipmap), s2.bindTexture(s2.TEXTURE_2D, this.texture), o2.pixelStoreUnpackFlipY.set(false), o2.pixelStoreUnpack.set(1), o2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA && (!e2 || false !== e2.premultiply)), a2)
          this.size = [n2, i2], t2 instanceof Cl || t2 instanceof El || t2 instanceof Pl || t2 instanceof Ml || Bl && t2 instanceof Bl ? s2.texImage2D(s2.TEXTURE_2D, 0, this.format, this.format, s2.UNSIGNED_BYTE, t2) : s2.texImage2D(s2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, s2.UNSIGNED_BYTE, t2.data);
        else {
          var u2 = r2 || { x: 0, y: 0 }, l2 = u2.x, p3 = u2.y;
          t2 instanceof Cl || t2 instanceof El || t2 instanceof Pl || t2 instanceof Ml || Bl && t2 instanceof Bl ? s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p3, s2.RGBA, s2.UNSIGNED_BYTE, t2) : s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p3, n2, i2, s2.RGBA, s2.UNSIGNED_BYTE, t2.data);
        }
        this.useMipmap && this.isSizePowerOfTwo() && s2.generateMipmap(s2.TEXTURE_2D);
      }, Tl.prototype.bind = function(t2, e2, r2) {
        var n2 = this.context.gl;
        n2.bindTexture(n2.TEXTURE_2D, this.texture), r2 !== n2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = n2.LINEAR), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, r2 || t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
      }, Tl.prototype.isSizePowerOfTwo = function() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }, Tl.prototype.destroy = function() {
        this.context.gl.deleteTexture(this.texture), this.texture = null;
      };
      var Vl = function(t2) {
        var e2 = this;
        this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
          e2._triggered = false, e2._callback();
        });
      };
      Vl.prototype.trigger = function() {
        var t2 = this;
        this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(function() {
          t2._triggered = false, t2._callback();
        }, 0));
      }, Vl.prototype.remove = function() {
        delete this._channel, this._callback = function() {
        };
      };
      var Fl = function(t2, e2, r2) {
        this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v2(["receive", "process"], this), this.invoker = new Vl(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I2() ? t2 : o;
      };
      function Dl(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
      }
      Fl.prototype.send = function(t2, e2, r2, n2, i2) {
        var a2 = this;
        void 0 === i2 && (i2 = false);
        var o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        r2 && (this.callbacks[o2] = r2);
        var s2 = E(this.globalScope) ? void 0 : [];
        return this.target.postMessage({ id: o2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: qn(e2, s2) }, s2), { cancel: function() {
          r2 && delete a2.callbacks[o2], a2.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n2, sourceMapId: a2.mapId });
        } };
      }, Fl.prototype.receive = function(t2) {
        var e2 = t2.data, r2 = e2.id;
        if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
          if ("<cancel>" === e2.type) {
            delete this.tasks[r2];
            var n2 = this.cancelCallbacks[r2];
            delete this.cancelCallbacks[r2], n2 && n2();
          } else
            I2() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
      }, Fl.prototype.process = function() {
        if (this.taskQueue.length) {
          var t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
          delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t2, e2);
        }
      }, Fl.prototype.processTask = function(t2, e2) {
        var r2 = this;
        if ("<response>" === e2.type) {
          var n2 = this.callbacks[t2];
          delete this.callbacks[t2], n2 && (e2.error ? n2(Nn(e2.error)) : n2(null, Nn(e2.data)));
        } else {
          var i2 = false, a2 = E(this.globalScope) ? void 0 : [], o2 = e2.hasCallback ? function(e3, n3) {
            i2 = true, delete r2.cancelCallbacks[t2], r2.target.postMessage({ id: t2, type: "<response>", sourceMapId: r2.mapId, error: e3 ? qn(e3) : null, data: qn(n3, a2) }, a2);
          } : function(t3) {
            i2 = true;
          }, s2 = null, u2 = Nn(e2.data);
          if (this.parent[e2.type])
            s2 = this.parent[e2.type](e2.sourceMapId, u2, o2);
          else if (this.parent.getWorkerSource) {
            var l2 = e2.type.split(".");
            s2 = this.parent.getWorkerSource(e2.sourceMapId, l2[0], u2.source)[l2[1]](u2, o2);
          } else
            o2(new Error("Could not find function " + e2.type));
          !i2 && s2 && s2.cancel && (this.cancelCallbacks[t2] = s2.cancel);
        }
      }, Fl.prototype.remove = function() {
        this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
      };
      var Ll = function(t2, e2) {
        t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
      };
      Ll.prototype.setNorthEast = function(t2) {
        return this._ne = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
      }, Ll.prototype.setSouthWest = function(t2) {
        return this._sw = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
      }, Ll.prototype.extend = function(t2) {
        var e2, r2, n2 = this._sw, i2 = this._ne;
        if (t2 instanceof Ol)
          e2 = t2, r2 = t2;
        else {
          if (!(t2 instanceof Ll))
            return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Ll.convert(t2)) : this.extend(Ol.convert(t2)) : this;
          if (r2 = t2._ne, !(e2 = t2._sw) || !r2)
            return this;
        }
        return n2 || i2 ? (n2.lng = Math.min(e2.lng, n2.lng), n2.lat = Math.min(e2.lat, n2.lat), i2.lng = Math.max(r2.lng, i2.lng), i2.lat = Math.max(r2.lat, i2.lat)) : (this._sw = new Ol(e2.lng, e2.lat), this._ne = new Ol(r2.lng, r2.lat)), this;
      }, Ll.prototype.getCenter = function() {
        return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }, Ll.prototype.getSouthWest = function() {
        return this._sw;
      }, Ll.prototype.getNorthEast = function() {
        return this._ne;
      }, Ll.prototype.getNorthWest = function() {
        return new Ol(this.getWest(), this.getNorth());
      }, Ll.prototype.getSouthEast = function() {
        return new Ol(this.getEast(), this.getSouth());
      }, Ll.prototype.getWest = function() {
        return this._sw.lng;
      }, Ll.prototype.getSouth = function() {
        return this._sw.lat;
      }, Ll.prototype.getEast = function() {
        return this._ne.lng;
      }, Ll.prototype.getNorth = function() {
        return this._ne.lat;
      }, Ll.prototype.toArray = function() {
        return [this._sw.toArray(), this._ne.toArray()];
      }, Ll.prototype.toString = function() {
        return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
      }, Ll.prototype.isEmpty = function() {
        return !(this._sw && this._ne);
      }, Ll.prototype.contains = function(t2) {
        var e2 = Ol.convert(t2), r2 = e2.lng, n2 = e2.lat, i2 = this._sw.lng <= r2 && r2 <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (i2 = this._sw.lng >= r2 && r2 >= this._ne.lng), this._sw.lat <= n2 && n2 <= this._ne.lat && i2;
      }, Ll.convert = function(t2) {
        return !t2 || t2 instanceof Ll ? t2 : new Ll(t2);
      };
      var Ol = function(t2, e2) {
        if (isNaN(t2) || isNaN(e2))
          throw new Error("Invalid LngLat object: (" + t2 + ", " + e2 + ")");
        if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
          throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      };
      Ol.prototype.wrap = function() {
        return new Ol(c2(this.lng, -180, 180), this.lat);
      }, Ol.prototype.toArray = function() {
        return [this.lng, this.lat];
      }, Ol.prototype.toString = function() {
        return "LngLat(" + this.lng + ", " + this.lat + ")";
      }, Ol.prototype.distanceTo = function(t2) {
        var e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
        return 63710088e-1 * Math.acos(Math.min(i2, 1));
      }, Ol.prototype.toBounds = function(t2) {
        void 0 === t2 && (t2 = 0);
        var e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
        return new Ll(new Ol(this.lng - r2, this.lat - e2), new Ol(this.lng + r2, this.lat + e2));
      }, Ol.convert = function(t2) {
        if (t2 instanceof Ol)
          return t2;
        if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
          return new Ol(Number(t2[0]), Number(t2[1]));
        if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
          return new Ol(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      };
      var Rl = 2 * Math.PI * 63710088e-1;
      function Ul(t2) {
        return Rl * Math.cos(t2 * Math.PI / 180);
      }
      function jl(t2) {
        return (180 + t2) / 360;
      }
      function ql(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function Nl(t2, e2) {
        return t2 / Ul(e2);
      }
      function Kl(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }
      var Gl = function(t2, e2, r2) {
        void 0 === r2 && (r2 = 0), this.x = +t2, this.y = +e2, this.z = +r2;
      };
      Gl.fromLngLat = function(t2, e2) {
        void 0 === e2 && (e2 = 0);
        var r2 = Ol.convert(t2);
        return new Gl(jl(r2.lng), ql(r2.lat), Nl(e2, r2.lat));
      }, Gl.prototype.toLngLat = function() {
        return new Ol(360 * this.x - 180, Kl(this.y));
      }, Gl.prototype.toAltitude = function() {
        return this.z * Ul(Kl(this.y));
      }, Gl.prototype.meterInMercatorCoordinateUnits = function() {
        return 1 / Rl * (t2 = Kl(this.y), 1 / Math.cos(t2 * Math.PI / 180));
        var t2;
      };
      var Zl = function(t2, e2, r2) {
        this.z = t2, this.x = e2, this.y = r2, this.key = Hl(0, t2, t2, e2, r2);
      };
      Zl.prototype.equals = function(t2) {
        return this.z === t2.z && this.x === t2.x && this.y === t2.y;
      }, Zl.prototype.url = function(t2, e2) {
        var r2, n2, i2, a2, o2, s2 = (n2 = this.y, i2 = this.z, a2 = Dl(256 * (r2 = this.x), 256 * (n2 = Math.pow(2, i2) - n2 - 1), i2), o2 = Dl(256 * (r2 + 1), 256 * (n2 + 1), i2), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]), u2 = function(t3, e3, r3) {
          for (var n3, i3 = "", a3 = t3; a3 > 0; a3--)
            i3 += (e3 & (n3 = 1 << a3 - 1) ? 1 : 0) + (r3 & n3 ? 2 : 0);
          return i3;
        }(this.z, this.x, this.y);
        return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u2).replace("{bbox-epsg-3857}", s2);
      }, Zl.prototype.getTilePoint = function(t2) {
        var e2 = Math.pow(2, this.z);
        return new i(8192 * (t2.x * e2 - this.x), 8192 * (t2.y * e2 - this.y));
      }, Zl.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
      };
      var Xl = function(t2, e2) {
        this.wrap = t2, this.canonical = e2, this.key = Hl(t2, e2.z, e2.z, e2.x, e2.y);
      }, Jl = function(t2, e2, r2, n2, i2) {
        this.overscaledZ = t2, this.wrap = e2, this.canonical = new Zl(r2, +n2, +i2), this.key = Hl(e2, t2, r2, n2, i2);
      };
      function Hl(t2, e2, r2, n2, i2) {
        (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
        var a2 = 1 << r2;
        return (a2 * a2 * t2 + a2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
      }
      Jl.prototype.equals = function(t2) {
        return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
      }, Jl.prototype.scaledTo = function(t2) {
        var e2 = this.canonical.z - t2;
        return t2 > this.canonical.z ? new Jl(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Jl(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
      }, Jl.prototype.calculateScaledKey = function(t2, e2) {
        var r2 = this.canonical.z - t2;
        return t2 > this.canonical.z ? Hl(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Hl(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
      }, Jl.prototype.isChildOf = function(t2) {
        if (t2.wrap !== this.wrap)
          return false;
        var e2 = this.canonical.z - t2.canonical.z;
        return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
      }, Jl.prototype.children = function(t2) {
        if (this.overscaledZ >= t2)
          return [new Jl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        var e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
        return [new Jl(e2, this.wrap, e2, r2, n2), new Jl(e2, this.wrap, e2, r2 + 1, n2), new Jl(e2, this.wrap, e2, r2, n2 + 1), new Jl(e2, this.wrap, e2, r2 + 1, n2 + 1)];
      }, Jl.prototype.isLessThan = function(t2) {
        return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
      }, Jl.prototype.wrapped = function() {
        return new Jl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }, Jl.prototype.unwrapTo = function(t2) {
        return new Jl(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
      }, Jl.prototype.overscaleFactor = function() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }, Jl.prototype.toUnwrapped = function() {
        return new Xl(this.wrap, this.canonical);
      }, Jl.prototype.toString = function() {
        return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
      }, Jl.prototype.getTilePoint = function(t2) {
        return this.canonical.getTilePoint(new Gl(t2.x - this.wrap, t2.y));
      }, On("CanonicalTileID", Zl), On("OverscaledTileID", Jl, { omit: ["posMatrix"] });
      var Yl = function(t2, e2, r2) {
        if (this.uid = t2, e2.height !== e2.width)
          throw new RangeError("DEM tiles must be square");
        if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
          return A2('"' + r2 + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
        this.stride = e2.height;
        var n2 = this.dim = e2.height - 2;
        this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
        for (var i2 = 0; i2 < n2; i2++)
          this.data[this._idx(-1, i2)] = this.data[this._idx(0, i2)], this.data[this._idx(n2, i2)] = this.data[this._idx(n2 - 1, i2)], this.data[this._idx(i2, -1)] = this.data[this._idx(i2, 0)], this.data[this._idx(i2, n2)] = this.data[this._idx(i2, n2 - 1)];
        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)];
      };
      Yl.prototype.get = function(t2, e2) {
        var r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
        return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
      }, Yl.prototype.getUnpackVector = function() {
        return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
      }, Yl.prototype._idx = function(t2, e2) {
        if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
          throw new RangeError("out of range source coordinates for DEM data");
        return (e2 + 1) * this.stride + (t2 + 1);
      }, Yl.prototype._unpackMapbox = function(t2, e2, r2) {
        return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
      }, Yl.prototype._unpackTerrarium = function(t2, e2, r2) {
        return 256 * t2 + e2 + r2 / 256 - 32768;
      }, Yl.prototype.getPixels = function() {
        return new xo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
      }, Yl.prototype.backfillBorder = function(t2, e2, r2) {
        if (this.dim !== t2.dim)
          throw new Error("dem dimension mismatch");
        var n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, a2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
        switch (e2) {
          case -1:
            n2 = i2 - 1;
            break;
          case 1:
            i2 = n2 + 1;
        }
        switch (r2) {
          case -1:
            a2 = o2 - 1;
            break;
          case 1:
            o2 = a2 + 1;
        }
        for (var s2 = -e2 * this.dim, u2 = -r2 * this.dim, l2 = a2; l2 < o2; l2++)
          for (var p3 = n2; p3 < i2; p3++)
            this.data[this._idx(p3, l2)] = t2.data[this._idx(p3 + s2, l2 + u2)];
      }, On("DEMData", Yl);
      var $l = function(t2) {
        this._stringToNumber = {}, this._numberToString = [];
        for (var e2 = 0; e2 < t2.length; e2++) {
          var r2 = t2[e2];
          this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
        }
      };
      $l.prototype.encode = function(t2) {
        return this._stringToNumber[t2];
      }, $l.prototype.decode = function(t2) {
        return this._numberToString[t2];
      };
      var Wl = function(t2, e2, r2, n2, i2) {
        this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
      }, Ql = { geometry: { configurable: true } };
      Ql.geometry.get = function() {
        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
      }, Ql.geometry.set = function(t2) {
        this._geometry = t2;
      }, Wl.prototype.toJSON = function() {
        var t2 = { geometry: this.geometry };
        for (var e2 in this)
          "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
        return t2;
      }, Object.defineProperties(Wl.prototype, Ql);
      var tp = function() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      };
      tp.prototype.updateState = function(t2, e2, r2) {
        var n2 = String(e2);
        if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, h2(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2])
          for (var i2 in this.deletedStates[t2] = {}, this.state[t2])
            i2 !== n2 && (this.deletedStates[t2][i2] = null);
        else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2])
          for (var a2 in this.deletedStates[t2][n2] = {}, this.state[t2][n2])
            r2[a2] || (this.deletedStates[t2][n2][a2] = null);
        else
          for (var o2 in r2)
            this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][o2] && delete this.deletedStates[t2][n2][o2];
      }, tp.prototype.removeFeatureState = function(t2, e2, r2) {
        if (null !== this.deletedStates[t2]) {
          var n2 = String(e2);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
            null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
          else if (void 0 !== e2)
            if (this.stateChanges[t2] && this.stateChanges[t2][n2])
              for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                this.deletedStates[t2][n2][r2] = null;
            else
              this.deletedStates[t2][n2] = null;
          else
            this.deletedStates[t2] = null;
        }
      }, tp.prototype.getState = function(t2, e2) {
        var r2 = String(e2), n2 = h2({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
        if (null === this.deletedStates[t2])
          return {};
        if (this.deletedStates[t2]) {
          var i2 = this.deletedStates[t2][e2];
          if (null === i2)
            return {};
          for (var a2 in i2)
            delete n2[a2];
        }
        return n2;
      }, tp.prototype.initializeTileState = function(t2, e2) {
        t2.setFeatureState(this.state, e2);
      }, tp.prototype.coalesceChanges = function(t2, e2) {
        var r2 = {};
        for (var n2 in this.stateChanges) {
          this.state[n2] = this.state[n2] || {};
          var i2 = {};
          for (var a2 in this.stateChanges[n2])
            this.state[n2][a2] || (this.state[n2][a2] = {}), h2(this.state[n2][a2], this.stateChanges[n2][a2]), i2[a2] = this.state[n2][a2];
          r2[n2] = i2;
        }
        for (var o2 in this.deletedStates) {
          this.state[o2] = this.state[o2] || {};
          var s2 = {};
          if (null === this.deletedStates[o2])
            for (var u2 in this.state[o2])
              s2[u2] = {}, this.state[o2][u2] = {};
          else
            for (var l2 in this.deletedStates[o2]) {
              if (null === this.deletedStates[o2][l2])
                this.state[o2][l2] = {};
              else
                for (var p3 = 0, c3 = Object.keys(this.deletedStates[o2][l2]); p3 < c3.length; p3 += 1)
                  delete this.state[o2][l2][c3[p3]];
              s2[l2] = this.state[o2][l2];
            }
          r2[o2] = r2[o2] || {}, h2(r2[o2], s2);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
          for (var f2 in t2)
            t2[f2].setFeatureState(r2, e2);
      };
      var ep = function(t2, e2) {
        this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Tn(8192, 16, 0), this.grid3D = new Tn(8192, 16, 0), this.featureIndexArray = new aa(), this.promoteId = e2;
      };
      function rp(t2, e2, r2, n2, i2) {
        return x(t2, function(t3, a2) {
          var o2 = e2 instanceof di ? e2.get(a2) : null;
          return o2 && o2.evaluate ? o2.evaluate(r2, n2, i2) : o2;
        });
      }
      function np(t2) {
        for (var e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0, a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
          var s2 = o2[a2];
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        }
        return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
      }
      function ip(t2, e2) {
        return e2 - t2;
      }
      ep.prototype.insert = function(t2, e2, r2, n2, i2, a2) {
        var o2 = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(r2, n2, i2);
        for (var s2 = a2 ? this.grid3D : this.grid, u2 = 0; u2 < e2.length; u2++) {
          for (var l2 = e2[u2], p3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c3 = 0; c3 < l2.length; c3++) {
            var h3 = l2[c3];
            p3[0] = Math.min(p3[0], h3.x), p3[1] = Math.min(p3[1], h3.y), p3[2] = Math.max(p3[2], h3.x), p3[3] = Math.max(p3[3], h3.y);
          }
          p3[0] < 8192 && p3[1] < 8192 && p3[2] >= 0 && p3[3] >= 0 && s2.insert(o2, p3[0], p3[1], p3[2], p3[3]);
        }
      }, ep.prototype.loadVTLayers = function() {
        return this.vtLayers || (this.vtLayers = new bs.VectorTile(new Ys(this.rawTileData)).layers, this.sourceLayerCoder = new $l(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
      }, ep.prototype.query = function(t2, e2, r2, n2) {
        var a2 = this;
        this.loadVTLayers();
        for (var o2 = t2.params || {}, s2 = 8192 / t2.tileSize / t2.scale, u2 = on2(o2.filter), l2 = t2.queryGeometry, p3 = t2.queryPadding * s2, c3 = np(l2), h3 = this.grid.query(c3.minX - p3, c3.minY - p3, c3.maxX + p3, c3.maxY + p3), f2 = np(t2.cameraQueryGeometry), y3 = this.grid3D.query(f2.minX - p3, f2.minY - p3, f2.maxX + p3, f2.maxY + p3, function(e3, r3, n3, a3) {
          return function(t3, e4, r4, n4, a4) {
            for (var o3 = 0, s3 = t3; o3 < s3.length; o3 += 1) {
              var u3 = s3[o3];
              if (e4 <= u3.x && r4 <= u3.y && n4 >= u3.x && a4 >= u3.y)
                return true;
            }
            var l3 = [new i(e4, r4), new i(e4, a4), new i(n4, a4), new i(n4, r4)];
            if (t3.length > 2) {
              for (var p4 = 0, c4 = l3; p4 < c4.length; p4 += 1)
                if (Wa(t3, c4[p4]))
                  return true;
            }
            for (var h4 = 0; h4 < t3.length - 1; h4++)
              if (Qa(t3[h4], t3[h4 + 1], l3))
                return true;
            return false;
          }(t2.cameraQueryGeometry, e3 - p3, r3 - p3, n3 + p3, a3 + p3);
        }), d2 = 0, m2 = y3; d2 < m2.length; d2 += 1)
          h3.push(m2[d2]);
        h3.sort(ip);
        for (var v3, g2 = {}, x2 = function(i2) {
          var p4 = h3[i2];
          if (p4 !== v3) {
            v3 = p4;
            var c4 = a2.featureIndexArray.get(p4), f3 = null;
            a2.loadMatchingFeature(g2, c4.bucketIndex, c4.sourceLayerIndex, c4.featureIndex, u2, o2.layers, o2.availableImages, e2, r2, n2, function(e3, r3, n3) {
              return f3 || (f3 = Ra(e3)), r3.queryIntersectsFeature(l2, e3, n3, f3, a2.z, t2.transform, s2, t2.pixelPosMatrix);
            });
          }
        }, b2 = 0; b2 < h3.length; b2++)
          x2(b2);
        return g2;
      }, ep.prototype.loadMatchingFeature = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p3) {
        var c3 = this.bucketLayerIDs[e2];
        if (!a2 || function(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            if (e3.indexOf(t3[r3]) >= 0)
              return true;
          return false;
        }(a2, c3)) {
          var f2 = this.sourceLayerCoder.decode(r2), y3 = this.vtLayers[f2].feature(n2);
          if (i2.needGeometry) {
            var d2 = Ua(y3, true);
            if (!i2.filter(new si(this.tileID.overscaledZ), d2, this.tileID.canonical))
              return;
          } else if (!i2.filter(new si(this.tileID.overscaledZ), y3))
            return;
          for (var m2 = this.getId(y3, f2), v3 = 0; v3 < c3.length; v3++) {
            var g2 = c3[v3];
            if (!(a2 && a2.indexOf(g2) < 0)) {
              var x2 = s2[g2];
              if (x2) {
                var b2 = {};
                void 0 !== m2 && l2 && (b2 = l2.getState(x2.sourceLayer || "_geojsonTileLayer", m2));
                var w2 = h2({}, u2[g2]);
                w2.paint = rp(w2.paint, x2.paint, y3, b2, o2), w2.layout = rp(w2.layout, x2.layout, y3, b2, o2);
                var _24 = !p3 || p3(y3, x2, b2);
                if (_24) {
                  var A3 = new Wl(y3, this.z, this.x, this.y, m2);
                  A3.layer = w2;
                  var S2 = t2[g2];
                  void 0 === S2 && (S2 = t2[g2] = []), S2.push({ featureIndex: n2, feature: A3, intersectionZ: _24 });
                }
              }
            }
          }
        }
      }, ep.prototype.lookupSymbolFeatures = function(t2, e2, r2, n2, i2, a2, o2, s2) {
        var u2 = {};
        this.loadVTLayers();
        for (var l2 = on2(i2), p3 = 0, c3 = t2; p3 < c3.length; p3 += 1)
          this.loadMatchingFeature(u2, r2, n2, c3[p3], l2, a2, o2, s2, e2);
        return u2;
      }, ep.prototype.hasLayer = function(t2) {
        for (var e2 = 0, r2 = this.bucketLayerIDs; e2 < r2.length; e2 += 1)
          for (var n2 = 0, i2 = r2[e2]; n2 < i2.length; n2 += 1)
            if (t2 === i2[n2])
              return true;
        return false;
      }, ep.prototype.getId = function(t2, e2) {
        var r2 = t2.id;
        return this.promoteId && "boolean" == typeof (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]]) && (r2 = Number(r2)), r2;
      }, On("FeatureIndex", ep, { omit: ["rawTileData", "sourceLayerCoder"] });
      var ap = function(t2, e2) {
        this.tileID = t2, this.uid = y2(), this.uses = 0, this.tileSize = e2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
      };
      ap.prototype.registerFadeDuration = function(t2) {
        var e2 = t2 + this.timeAdded;
        e2 < O2.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
      }, ap.prototype.wasRequested = function() {
        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
      }, ap.prototype.loadVectorData = function(t2, e2, r2) {
        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
          for (var n2 in t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
            var r3 = {};
            if (!e3)
              return r3;
            for (var n3 = function() {
              var t4 = a3[i3], n4 = t4.layerIds.map(function(t5) {
                return e3.getLayer(t5);
              }).filter(Boolean);
              if (0 !== n4.length) {
                t4.layers = n4, t4.stateDependentLayerIds && (t4.stateDependentLayers = t4.stateDependentLayerIds.map(function(t5) {
                  return n4.filter(function(e4) {
                    return e4.id === t5;
                  })[0];
                }));
                for (var o3 = 0, s3 = n4; o3 < s3.length; o3 += 1)
                  r3[s3[o3].id] = t4;
              }
            }, i3 = 0, a3 = t3; i3 < a3.length; i3 += 1)
              n3();
            return r3;
          }(t2.buckets, e2.style), this.hasSymbolBuckets = false, this.buckets) {
            var i2 = this.buckets[n2];
            if (i2 instanceof vl) {
              if (this.hasSymbolBuckets = true, !r2)
                break;
              i2.justReloaded = true;
            }
          }
          if (this.hasRTLText = false, this.hasSymbolBuckets)
            for (var a2 in this.buckets) {
              var o2 = this.buckets[a2];
              if (o2 instanceof vl && o2.hasRTLText) {
                this.hasRTLText = true, oi.isLoading() || oi.isLoaded() || "deferred" !== ii() || ai();
                break;
              }
            }
          for (var s2 in this.queryPadding = 0, this.buckets) {
            var u2 = this.buckets[s2];
            this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(s2).queryRadius(u2));
          }
          t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
        } else
          this.collisionBoxArray = new $i();
      }, ap.prototype.unloadVectorData = function() {
        for (var t2 in this.buckets)
          this.buckets[t2].destroy();
        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
      }, ap.prototype.getBucket = function(t2) {
        return this.buckets[t2.id];
      }, ap.prototype.upload = function(t2) {
        for (var e2 in this.buckets) {
          var r2 = this.buckets[e2];
          r2.uploadPending() && r2.upload(t2);
        }
        var n2 = t2.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Tl(t2, this.imageAtlas.image, n2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Tl(t2, this.glyphAtlasImage, n2.ALPHA), this.glyphAtlasImage = null);
      }, ap.prototype.prepare = function(t2) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
      }, ap.prototype.queryRenderedFeatures = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: n2, cameraQueryGeometry: i2, scale: a2, tileSize: this.tileSize, pixelPosMatrix: l2, transform: s2, params: o2, queryPadding: this.queryPadding * u2 }, t2, e2, r2) : {};
      }, ap.prototype.querySourceFeatures = function(t2, e2) {
        var r2 = this.latestFeatureIndex;
        if (r2 && r2.rawTileData) {
          var n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", a2 = n2._geojsonTileLayer || n2[i2];
          if (a2)
            for (var o2 = on2(e2 && e2.filter), s2 = this.tileID.canonical, u2 = s2.z, l2 = s2.x, p3 = s2.y, c3 = { z: u2, x: l2, y: p3 }, h3 = 0; h3 < a2.length; h3++) {
              var f2 = a2.feature(h3);
              if (o2.needGeometry) {
                var y3 = Ua(f2, true);
                if (!o2.filter(new si(this.tileID.overscaledZ), y3, this.tileID.canonical))
                  continue;
              } else if (!o2.filter(new si(this.tileID.overscaledZ), f2))
                continue;
              var d2 = r2.getId(f2, i2), m2 = new Wl(f2, u2, l2, p3, d2);
              m2.tile = c3, t2.push(m2);
            }
        }
      }, ap.prototype.hasData = function() {
        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
      }, ap.prototype.patternsLoaded = function() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }, ap.prototype.setExpiryData = function(t2) {
        var e2 = this.expirationTime;
        if (t2.cacheControl) {
          var r2 = z(t2.cacheControl);
          r2["max-age"] && (this.expirationTime = Date.now() + 1e3 * r2["max-age"]);
        } else
          t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
        if (this.expirationTime) {
          var n2 = Date.now(), i2 = false;
          if (this.expirationTime > n2)
            i2 = false;
          else if (e2)
            if (this.expirationTime < e2)
              i2 = true;
            else {
              var a2 = this.expirationTime - e2;
              a2 ? this.expirationTime = n2 + Math.max(a2, 3e4) : i2 = true;
            }
          else
            i2 = true;
          i2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }, ap.prototype.getExpiryTimeout = function() {
        if (this.expirationTime)
          return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }, ap.prototype.setFeatureState = function(t2, e2) {
        if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t2).length) {
          var r2 = this.latestFeatureIndex.loadVTLayers();
          for (var n2 in this.buckets)
            if (e2.style.hasLayer(n2)) {
              var i2 = this.buckets[n2], a2 = i2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], s2 = t2[a2];
              if (o2 && s2 && 0 !== Object.keys(s2).length) {
                i2.update(s2, o2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var u2 = e2 && e2.style && e2.style.getLayer(n2);
                u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(i2)));
              }
            }
        }
      }, ap.prototype.holdingForFade = function() {
        return void 0 !== this.symbolFadeHoldUntil;
      }, ap.prototype.symbolFadeFinished = function() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < O2.now();
      }, ap.prototype.clearFadeHold = function() {
        this.symbolFadeHoldUntil = void 0;
      }, ap.prototype.setHoldDuration = function(t2) {
        this.symbolFadeHoldUntil = O2.now() + t2;
      }, ap.prototype.setDependencies = function(t2, e2) {
        for (var r2 = {}, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
          r2[i2[n2]] = true;
        this.dependencies[t2] = r2;
      }, ap.prototype.hasDependency = function(t2, e2) {
        for (var r2 = 0, n2 = t2; r2 < n2.length; r2 += 1) {
          var i2 = this.dependencies[n2[r2]];
          if (i2) {
            for (var a2 = 0, o2 = e2; a2 < o2.length; a2 += 1)
              if (i2[o2[a2]])
                return true;
          }
        }
        return false;
      };
      var op = o.performance, sp = function(t2) {
        this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, op.mark(this._marks.start);
      };
      sp.prototype.finish = function() {
        op.mark(this._marks.end);
        var t2 = op.getEntriesByName(this._marks.measure);
        return 0 === t2.length && (op.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = op.getEntriesByName(this._marks.measure), op.clearMarks(this._marks.start), op.clearMarks(this._marks.end), op.clearMeasures(this._marks.measure)), t2;
      }, t.Actor = Fl, t.AlphaImage = go, t.CanonicalTileID = Zl, t.CollisionBoxArray = $i, t.Color = te, t.DEMData = Yl, t.DataConstantProperty = mi, t.DictionaryCoder = $l, t.EXTENT = 8192, t.ErrorEvent = zt, t.EvaluationParameters = si, t.Event = It, t.Evented = Ct, t.FeatureIndex = ep, t.FillBucket = ss, t.FillExtrusionBucket = Ss, t.ImageAtlas = bu, t.ImagePosition = gu, t.LineBucket = Fs, t.LngLat = Ol, t.LngLatBounds = Ll, t.MercatorCoordinate = Gl, t.ONE_EM = 24, t.OverscaledTileID = Jl, t.Point = i, t.Point$1 = i, t.Properties = wi, t.Protobuf = Ys, t.RGBAImage = xo, t.RequestManager = G, t.RequestPerformance = sp, t.ResourceType = yt, t.SegmentVector = sa, t.SourceFeatureState = tp, t.StructArrayLayout1ui2 = Ji, t.StructArrayLayout2f1f2i16 = Ri, t.StructArrayLayout2i4 = Ci, t.StructArrayLayout3ui6 = ji, t.StructArrayLayout4i8 = Ei, t.SymbolBucket = vl, t.Texture = Tl, t.Tile = ap, t.Transitionable = pi, t.Uniform1f = ba, t.Uniform1i = xa, t.Uniform2f = wa, t.Uniform3f = _a, t.Uniform4f = Aa, t.UniformColor = Sa, t.UniformMatrix4f = Ia, t.UnwrappedTileID = Xl, t.ValidationError = Pt, t.WritingMode = wu, t.ZoomHistory = Kn, t.add = function(t2, e2, r2) {
        return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
      }, t.addDynamicAttributes = fl, t.asyncAll = function(t2, e2, r2) {
        if (!t2.length)
          return r2(null, []);
        var n2 = t2.length, i2 = new Array(t2.length), a2 = null;
        t2.forEach(function(t3, o2) {
          e2(t3, function(t4, e3) {
            t4 && (a2 = t4), i2[o2] = e3, 0 == --n2 && r2(a2, i2);
          });
        });
      }, t.bezier = u, t.bindAll = v2, t.browser = O2, t.cacheEntryPossiblyAdded = function(t2) {
        ++ht > ut && (t2.getActor().send("enforceCacheSizeLimit", st), ht = 0);
      }, t.clamp = p2, t.clearTileCache = function(t2) {
        var e2 = o.caches.delete("mapbox-tiles");
        t2 && e2.catch(t2).then(function() {
          return t2();
        });
      }, t.clipLine = Zu, t.clone = function(t2) {
        var e2 = new ao(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.clone$1 = w, t.clone$2 = function(t2) {
        var e2 = new ao(3);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
      }, t.collisionCircleLayout = Gs, t.config = R, t.create = function() {
        var t2 = new ao(16);
        return ao != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.create$1 = function() {
        var t2 = new ao(9);
        return ao != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
      }, t.create$2 = function() {
        var t2 = new ao(4);
        return ao != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
      }, t.createCommonjsModule = e, t.createExpression = Zr, t.createLayout = Ii, t.createStyleLayer = function(t2) {
        return "custom" === t2.type ? new Il(t2) : new zl[t2.type](t2);
      }, t.cross = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = r2[0], s2 = r2[1], u2 = r2[2];
        return t2[0] = i2 * u2 - a2 * s2, t2[1] = a2 * o2 - n2 * u2, t2[2] = n2 * s2 - i2 * o2, t2;
      }, t.deepEqual = function t2(e2, r2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(r2) || e2.length !== r2.length)
            return false;
          for (var n2 = 0; n2 < e2.length; n2++)
            if (!t2(e2[n2], r2[n2]))
              return false;
          return true;
        }
        if ("object" == typeof e2 && null !== e2 && null !== r2) {
          if ("object" != typeof r2)
            return false;
          if (Object.keys(e2).length !== Object.keys(r2).length)
            return false;
          for (var i2 in e2)
            if (!t2(e2[i2], r2[i2]))
              return false;
          return true;
        }
        return e2 === r2;
      }, t.dot = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
      }, t.dot$1 = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
      }, t.ease = l, t.emitValidationErrors = Bn, t.endsWith = g, t.enforceCacheSizeLimit = function(t2) {
        lt(), tt && tt.then(function(e2) {
          e2.keys().then(function(r2) {
            for (var n2 = 0; n2 < r2.length - t2; n2++)
              e2.delete(r2[n2]);
          });
        });
      }, t.evaluateSizeForFeature = Lu, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = al, t.evented = ni, t.extend = h2, t.featureFilter = on2, t.filterObject = b, t.fromRotation = function(t2, e2) {
        var r2 = Math.sin(e2), n2 = Math.cos(e2);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, t.getAnchorAlignment = Bu, t.getAnchorJustification = ol, t.getArrayBuffer = bt, t.getImage = At, t.getJSON = function(t2, e2) {
        return xt(h2(t2, { type: "json" }), e2);
      }, t.getRTLTextPluginStatus = ii, t.getReferrer = mt, t.getVideo = function(t2, e2) {
        var r2, n2, i2 = o.document.createElement("video");
        i2.muted = true, i2.onloadstart = function() {
          e2(null, i2);
        };
        for (var a2 = 0; a2 < t2.length; a2++) {
          var s2 = o.document.createElement("source");
          r2 = t2[a2], n2 = void 0, (n2 = o.document.createElement("a")).href = r2, (n2.protocol !== o.document.location.protocol || n2.host !== o.document.location.host) && (i2.crossOrigin = "Anonymous"), s2.src = t2[a2], i2.appendChild(s2);
        }
        return { cancel: function() {
        } };
      }, t.identity = oo, t.invert = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3], o2 = e2[4], s2 = e2[5], u2 = e2[6], l2 = e2[7], p3 = e2[8], c3 = e2[9], h3 = e2[10], f2 = e2[11], y3 = e2[12], d2 = e2[13], m2 = e2[14], v3 = e2[15], g2 = r2 * s2 - n2 * o2, x2 = r2 * u2 - i2 * o2, b2 = r2 * l2 - a2 * o2, w2 = n2 * u2 - i2 * s2, _24 = n2 * l2 - a2 * s2, A3 = i2 * l2 - a2 * u2, S2 = p3 * d2 - c3 * y3, k2 = p3 * m2 - h3 * y3, I3 = p3 * v3 - f2 * y3, z2 = c3 * m2 - h3 * d2, C2 = c3 * v3 - f2 * d2, E2 = h3 * v3 - f2 * m2, P2 = g2 * E2 - x2 * C2 + b2 * z2 + w2 * I3 - _24 * k2 + A3 * S2;
        return P2 ? (t2[0] = (s2 * E2 - u2 * C2 + l2 * z2) * (P2 = 1 / P2), t2[1] = (i2 * C2 - n2 * E2 - a2 * z2) * P2, t2[2] = (d2 * A3 - m2 * _24 + v3 * w2) * P2, t2[3] = (h3 * _24 - c3 * A3 - f2 * w2) * P2, t2[4] = (u2 * I3 - o2 * E2 - l2 * k2) * P2, t2[5] = (r2 * E2 - i2 * I3 + a2 * k2) * P2, t2[6] = (m2 * b2 - y3 * A3 - v3 * x2) * P2, t2[7] = (p3 * A3 - h3 * b2 + f2 * x2) * P2, t2[8] = (o2 * C2 - s2 * I3 + l2 * S2) * P2, t2[9] = (n2 * I3 - r2 * C2 - a2 * S2) * P2, t2[10] = (y3 * _24 - d2 * b2 + v3 * g2) * P2, t2[11] = (c3 * b2 - p3 * _24 - f2 * g2) * P2, t2[12] = (s2 * k2 - o2 * z2 - u2 * S2) * P2, t2[13] = (r2 * z2 - n2 * k2 + i2 * S2) * P2, t2[14] = (d2 * x2 - y3 * w2 - m2 * g2) * P2, t2[15] = (p3 * w2 - c3 * x2 + h3 * g2) * P2, t2) : null;
      }, t.isChar = Gn, t.isMapboxURL = Z2, t.keysDifference = function(t2, e2) {
        var r2 = [];
        for (var n2 in t2)
          n2 in e2 || r2.push(n2);
        return r2;
      }, t.makeRequest = xt, t.mapObject = x, t.mercatorXfromLng = jl, t.mercatorYfromLat = ql, t.mercatorZfromAltitude = Nl, t.mul = lo, t.multiply = so, t.mvt = bs, t.nextPowerOfTwo = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }, t.normalize = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = r2 * r2 + n2 * n2 + i2 * i2;
        return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = e2[0] * a2, t2[1] = e2[1] * a2, t2[2] = e2[2] * a2, t2;
      }, t.number = Ke, t.offscreenCanvasSupported = ft, t.ortho = function(t2, e2, r2, n2, i2, a2, o2) {
        var s2 = 1 / (e2 - r2), u2 = 1 / (n2 - i2), l2 = 1 / (a2 - o2);
        return t2[0] = -2 * s2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * u2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * l2, t2[11] = 0, t2[12] = (e2 + r2) * s2, t2[13] = (i2 + n2) * u2, t2[14] = (o2 + a2) * l2, t2[15] = 1, t2;
      }, t.parseGlyphPBF = function(t2) {
        return new Ys(t2).readFields(yu, []);
      }, t.pbf = Ys, t.performSymbolLayout = function(t2, e2, r2, n2, i2, a2, o2) {
        t2.createArrays(), t2.tilePixelRatio = 8192 / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
        var s2 = t2.layers[0].layout, u2 = t2.layers[0]._unevaluatedLayout._values, l2 = {};
        if ("composite" === t2.textSizeData.kind) {
          var p3 = t2.textSizeData, c3 = p3.maxZoom;
          l2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new si(p3.minZoom), o2), u2["text-size"].possiblyEvaluate(new si(c3), o2)];
        }
        if ("composite" === t2.iconSizeData.kind) {
          var h3 = t2.iconSizeData, f2 = h3.maxZoom;
          l2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new si(h3.minZoom), o2), u2["icon-size"].possiblyEvaluate(new si(f2), o2)];
        }
        l2.layoutTextSize = u2["text-size"].possiblyEvaluate(new si(t2.zoom + 1), o2), l2.layoutIconSize = u2["icon-size"].possiblyEvaluate(new si(t2.zoom + 1), o2), l2.textMaxSize = u2["text-size"].possiblyEvaluate(new si(18));
        for (var y3 = 24 * s2.get("text-line-height"), d2 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement"), m2 = s2.get("text-keep-upright"), v3 = s2.get("text-size"), g2 = function() {
          var a3 = b2[x2], u3 = s2.get("text-font").evaluate(a3, {}, o2).join(","), p4 = v3.evaluate(a3, {}, o2), c4 = l2.layoutTextSize.evaluate(a3, {}, o2), h4 = l2.layoutIconSize.evaluate(a3, {}, o2), f3 = { horizontal: {}, vertical: void 0 }, g3 = a3.text, w2 = [0, 0];
          if (g3) {
            var _24 = g3.toString(), S2 = 24 * s2.get("text-letter-spacing").evaluate(a3, {}, o2), k2 = function(t3) {
              for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1)
                if (n3 = r3[e3].charCodeAt(0), Gn.Arabic(n3) || Gn["Arabic Supplement"](n3) || Gn["Arabic Extended-A"](n3) || Gn["Arabic Presentation Forms-A"](n3) || Gn["Arabic Presentation Forms-B"](n3))
                  return false;
              var n3;
              return true;
            }(_24) ? S2 : 0, I3 = s2.get("text-anchor").evaluate(a3, {}, o2), z2 = s2.get("text-variable-anchor");
            if (!z2) {
              var C2 = s2.get("text-radial-offset").evaluate(a3, {}, o2);
              w2 = C2 ? al(I3, [24 * C2, il]) : s2.get("text-offset").evaluate(a3, {}, o2).map(function(t3) {
                return 24 * t3;
              });
            }
            var E2 = d2 ? "center" : s2.get("text-justify").evaluate(a3, {}, o2), P2 = s2.get("symbol-placement"), M2 = "point" === P2 ? 24 * s2.get("text-max-width").evaluate(a3, {}, o2) : 0, B2 = function() {
              t2.allowVerticalPlacement && Zn(_24) && (f3.vertical = Su(g3, e2, r2, i2, u3, M2, y3, I3, "left", k2, w2, wu.vertical, true, P2, c4, p4));
            };
            if (!d2 && z2) {
              for (var T2 = "auto" === E2 ? z2.map(function(t3) {
                return ol(t3);
              }) : [E2], V3 = false, F2 = 0; F2 < T2.length; F2++) {
                var D2 = T2[F2];
                if (!f3.horizontal[D2])
                  if (V3)
                    f3.horizontal[D2] = f3.horizontal[0];
                  else {
                    var L2 = Su(g3, e2, r2, i2, u3, M2, y3, "center", D2, k2, w2, wu.horizontal, false, P2, c4, p4);
                    L2 && (f3.horizontal[D2] = L2, V3 = 1 === L2.positionedLines.length);
                  }
              }
              B2();
            } else {
              "auto" === E2 && (E2 = ol(I3));
              var O3 = Su(g3, e2, r2, i2, u3, M2, y3, I3, E2, k2, w2, wu.horizontal, false, P2, c4, p4);
              O3 && (f3.horizontal[E2] = O3), B2(), Zn(_24) && d2 && m2 && (f3.vertical = Su(g3, e2, r2, i2, u3, M2, y3, I3, E2, k2, w2, wu.vertical, false, P2, c4, p4));
            }
          }
          var R2 = void 0, U2 = false;
          if (a3.icon && a3.icon.name) {
            var j2 = n2[a3.icon.name];
            j2 && (R2 = function(t3, e3, r3) {
              var n3 = Bu(r3), i3 = e3[0] - t3.displaySize[0] * n3.horizontalAlign, a4 = e3[1] - t3.displaySize[1] * n3.verticalAlign;
              return { image: t3, top: a4, bottom: a4 + t3.displaySize[1], left: i3, right: i3 + t3.displaySize[0] };
            }(i2[a3.icon.name], s2.get("icon-offset").evaluate(a3, {}, o2), s2.get("icon-anchor").evaluate(a3, {}, o2)), U2 = j2.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = j2.sdf : t2.sdfIcons !== j2.sdf && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j2.pixelRatio !== t2.pixelRatio || 0 !== s2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
          }
          var q2 = ul(f3.horizontal) || f3.vertical;
          t2.iconsInText = !!q2 && q2.iconsInText, (q2 || R2) && function(t3, e3, r3, n3, i3, a4, o3, s3, u4, l3, p5) {
            var c5 = a4.textMaxSize.evaluate(e3, {});
            void 0 === c5 && (c5 = o3);
            var h5, f4 = t3.layers[0].layout, y4 = f4.get("icon-offset").evaluate(e3, {}, p5), d3 = ul(r3.horizontal), m3 = o3 / 24, v4 = t3.tilePixelRatio * m3, g4 = t3.tilePixelRatio * c5 / 24, x3 = t3.tilePixelRatio * s3, b3 = t3.tilePixelRatio * f4.get("symbol-spacing"), w3 = f4.get("text-padding") * t3.tilePixelRatio, _25 = f4.get("icon-padding") * t3.tilePixelRatio, S3 = f4.get("text-max-angle") / 180 * Math.PI, k3 = "map" === f4.get("text-rotation-alignment") && "point" !== f4.get("symbol-placement"), I4 = "map" === f4.get("icon-rotation-alignment") && "point" !== f4.get("symbol-placement"), z3 = f4.get("symbol-placement"), C3 = b3 / 2, E3 = f4.get("icon-text-fit");
            n3 && "none" !== E3 && (t3.allowVerticalPlacement && r3.vertical && (h5 = Vu(n3, r3.vertical, E3, f4.get("icon-text-fit-padding"), y4, m3)), d3 && (n3 = Vu(n3, d3, E3, f4.get("icon-text-fit-padding"), y4, m3)));
            var P3 = function(s4, c6) {
              c6.x < 0 || c6.x >= 8192 || c6.y < 0 || c6.y >= 8192 || function(t4, e4, r4, n4, i4, a5, o4, s5, u5, l4, p6, c7, h6, f5, y5, d4, m4, v5, g5, x4, b4, w4, _26, S4, k4) {
                var I5, z4, C4, E4, P4, M4 = t4.addToLineVertexArray(e4, r4), B4 = 0, T4 = 0, V5 = 0, F4 = 0, D4 = -1, L4 = -1, O5 = {}, R4 = ha(""), U4 = 0, j4 = 0;
                if (void 0 === s5._unevaluatedLayout.getValue("text-radial-offset") ? (U4 = (I5 = s5.layout.get("text-offset").evaluate(b4, {}, S4).map(function(t5) {
                  return 24 * t5;
                }))[0], j4 = I5[1]) : (U4 = 24 * s5.layout.get("text-radial-offset").evaluate(b4, {}, S4), j4 = il), t4.allowVerticalPlacement && n4.vertical) {
                  var q4 = s5.layout.get("text-rotate").evaluate(b4, {}, S4) + 90;
                  E4 = new Wu(u5, e4, l4, p6, c7, n4.vertical, h6, f5, y5, q4), o4 && (P4 = new Wu(u5, e4, l4, p6, c7, o4, m4, v5, y5, q4));
                }
                if (i4) {
                  var N3 = s5.layout.get("icon-rotate").evaluate(b4, {}), K3 = "none" !== s5.layout.get("icon-text-fit"), G3 = Xu(i4, N3, _26, K3), Z4 = o4 ? Xu(o4, N3, _26, K3) : void 0;
                  C4 = new Wu(u5, e4, l4, p6, c7, i4, m4, v5, false, N3), B4 = 4 * G3.length;
                  var X3 = t4.iconSizeData, J3 = null;
                  "source" === X3.kind ? (J3 = [128 * s5.layout.get("icon-size").evaluate(b4, {})])[0] > 32640 && A2(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === X3.kind && ((J3 = [128 * w4.compositeIconSizes[0].evaluate(b4, {}, S4), 128 * w4.compositeIconSizes[1].evaluate(b4, {}, S4)])[0] > 32640 || J3[1] > 32640) && A2(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t4.addSymbols(t4.icon, G3, J3, x4, g5, b4, false, e4, M4.lineStartIndex, M4.lineLength, -1, S4), D4 = t4.icon.placedSymbolArray.length - 1, Z4 && (T4 = 4 * Z4.length, t4.addSymbols(t4.icon, Z4, J3, x4, g5, b4, wu.vertical, e4, M4.lineStartIndex, M4.lineLength, -1, S4), L4 = t4.icon.placedSymbolArray.length - 1);
                }
                for (var H3 in n4.horizontal) {
                  var Y3 = n4.horizontal[H3];
                  if (!z4) {
                    R4 = ha(Y3.text);
                    var $3 = s5.layout.get("text-rotate").evaluate(b4, {}, S4);
                    z4 = new Wu(u5, e4, l4, p6, c7, Y3, h6, f5, y5, $3);
                  }
                  var W3 = 1 === Y3.positionedLines.length;
                  if (V5 += sl(t4, e4, Y3, a5, s5, y5, b4, d4, M4, n4.vertical ? wu.horizontal : wu.horizontalOnly, W3 ? Object.keys(n4.horizontal) : [H3], O5, D4, w4, S4), W3)
                    break;
                }
                n4.vertical && (F4 += sl(t4, e4, n4.vertical, a5, s5, y5, b4, d4, M4, wu.vertical, ["vertical"], O5, L4, w4, S4));
                var Q2 = z4 ? z4.boxStartIndex : t4.collisionBoxArray.length, tt2 = z4 ? z4.boxEndIndex : t4.collisionBoxArray.length, et2 = E4 ? E4.boxStartIndex : t4.collisionBoxArray.length, rt2 = E4 ? E4.boxEndIndex : t4.collisionBoxArray.length, nt2 = C4 ? C4.boxStartIndex : t4.collisionBoxArray.length, it2 = C4 ? C4.boxEndIndex : t4.collisionBoxArray.length, at2 = P4 ? P4.boxStartIndex : t4.collisionBoxArray.length, ot2 = P4 ? P4.boxEndIndex : t4.collisionBoxArray.length, st2 = -1, ut2 = function(t5, e5) {
                  return t5 && t5.circleDiameter ? Math.max(t5.circleDiameter, e5) : e5;
                };
                st2 = ut2(z4, st2), st2 = ut2(E4, st2), st2 = ut2(C4, st2);
                var lt2 = (st2 = ut2(P4, st2)) > -1 ? 1 : 0;
                lt2 && (st2 *= k4 / 24), t4.glyphOffsetArray.length >= vl.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t4.addToSortKeyRanges(t4.symbolInstances.length, b4.sortKey), t4.symbolInstances.emplaceBack(e4.x, e4.y, O5.right >= 0 ? O5.right : -1, O5.center >= 0 ? O5.center : -1, O5.left >= 0 ? O5.left : -1, O5.vertical || -1, D4, L4, R4, Q2, tt2, et2, rt2, nt2, it2, at2, ot2, l4, V5, F4, B4, T4, lt2, 0, h6, U4, j4, st2);
              }(t3, c6, s4, r3, n3, i3, h5, t3.layers[0], t3.collisionBoxArray, e3.index, e3.sourceLayerIndex, t3.index, v4, w3, k3, u4, x3, _25, I4, y4, e3, a4, l3, p5, o3);
            };
            if ("line" === z3)
              for (var M3 = 0, B3 = Zu(e3.geometry, 0, 0, 8192, 8192); M3 < B3.length; M3 += 1)
                for (var T3 = B3[M3], V4 = 0, F3 = Gu(T3, b3, S3, r3.vertical || d3, n3, 24, g4, t3.overscaling, 8192); V4 < F3.length; V4 += 1) {
                  var D3 = F3[V4];
                  d3 && ll(t3, d3.text, C3, D3) || P3(T3, D3);
                }
            else if ("line-center" === z3)
              for (var L3 = 0, O4 = e3.geometry; L3 < O4.length; L3 += 1) {
                var R3 = O4[L3];
                if (R3.length > 1) {
                  var U3 = Ku(R3, S3, r3.vertical || d3, n3, 24, g4);
                  U3 && P3(R3, U3);
                }
              }
            else if ("Polygon" === e3.type)
              for (var j3 = 0, q3 = ns(e3.geometry, 0); j3 < q3.length; j3 += 1) {
                var N2 = q3[j3], K2 = el(N2, 16);
                P3(N2[0], new Fu(K2.x, K2.y, 0));
              }
            else if ("LineString" === e3.type)
              for (var G2 = 0, Z3 = e3.geometry; G2 < Z3.length; G2 += 1) {
                var X2 = Z3[G2];
                P3(X2, new Fu(X2[0].x, X2[0].y, 0));
              }
            else if ("Point" === e3.type)
              for (var J2 = 0, H2 = e3.geometry; J2 < H2.length; J2 += 1)
                for (var Y2 = 0, $2 = H2[J2]; Y2 < $2.length; Y2 += 1) {
                  var W2 = $2[Y2];
                  P3([W2], new Fu(W2.x, W2.y, 0));
                }
          }(t2, a3, f3, R2, n2, l2, c4, h4, w2, U2, o2);
        }, x2 = 0, b2 = t2.features; x2 < b2.length; x2 += 1)
          g2();
        a2 && t2.generateCollisionDebugBuffers();
      }, t.perspective = function(t2, e2, r2, n2, i2) {
        var a2, o2 = 1 / Math.tan(e2 / 2);
        return t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (a2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * a2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.pick = function(t2, e2) {
        for (var r2 = {}, n2 = 0; n2 < e2.length; n2++) {
          var i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.plugin = oi, t.polygonIntersectsPolygon = Na, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = vu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function(t2) {
        return t2({ pluginStatus: Qn, pluginURL: ti }), ni.on("pluginStateChange", t2), t2;
      }, t.renderColorRamp = wo, t.rotate = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = Math.sin(r2), u2 = Math.cos(r2);
        return t2[0] = n2 * u2 + a2 * s2, t2[1] = i2 * u2 + o2 * s2, t2[2] = n2 * -s2 + a2 * u2, t2[3] = i2 * -s2 + o2 * u2, t2;
      }, t.rotateX = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[4], o2 = e2[5], s2 = e2[6], u2 = e2[7], l2 = e2[8], p3 = e2[9], c3 = e2[10], h3 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = a2 * i2 + l2 * n2, t2[5] = o2 * i2 + p3 * n2, t2[6] = s2 * i2 + c3 * n2, t2[7] = u2 * i2 + h3 * n2, t2[8] = l2 * i2 - a2 * n2, t2[9] = p3 * i2 - o2 * n2, t2[10] = c3 * i2 - s2 * n2, t2[11] = h3 * i2 - u2 * n2, t2;
      }, t.rotateZ = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[0], o2 = e2[1], s2 = e2[2], u2 = e2[3], l2 = e2[4], p3 = e2[5], c3 = e2[6], h3 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = a2 * i2 + l2 * n2, t2[1] = o2 * i2 + p3 * n2, t2[2] = s2 * i2 + c3 * n2, t2[3] = u2 * i2 + h3 * n2, t2[4] = l2 * i2 - a2 * n2, t2[5] = p3 * i2 - o2 * n2, t2[6] = c3 * i2 - s2 * n2, t2[7] = h3 * i2 - u2 * n2, t2;
      }, t.scale = function(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], a2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * a2, t2[9] = e2[9] * a2, t2[10] = e2[10] * a2, t2[11] = e2[11] * a2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.scale$1 = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
      }, t.scale$2 = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
      }, t.setCacheLimits = function(t2, e2) {
        st = t2, ut = e2;
      }, t.setRTLTextPlugin = function(t2, e2, r2) {
        if (void 0 === r2 && (r2 = false), "deferred" === Qn || "loading" === Qn || "loaded" === Qn)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ti = O2.resolveURL(t2), Qn = "deferred", Wn = e2, ri(), r2 || ai();
      }, t.sphericalToCartesian = function(t2) {
        var e2 = t2[0], r2 = t2[1], n2 = t2[2];
        return r2 += 90, r2 *= Math.PI / 180, n2 *= Math.PI / 180, { x: e2 * Math.cos(r2) * Math.sin(n2), y: e2 * Math.sin(r2) * Math.sin(n2), z: e2 * Math.cos(n2) };
      }, t.sqrLen = function(t2) {
        var e2 = t2[0], r2 = t2[1];
        return e2 * e2 + r2 * r2;
      }, t.styleSpec = Et, t.sub = function(t2, e2, r2) {
        return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
      }, t.symbolSize = Ru, t.transformMat3 = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], a2 = e2[2];
        return t2[0] = n2 * r2[0] + i2 * r2[3] + a2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + a2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + a2 * r2[8], t2;
      }, t.transformMat4 = po, t.translate = function(t2, e2, r2) {
        var n2, i2, a2, o2, s2, u2, l2, p3, c3, h3, f2, y3, d2 = r2[0], m2 = r2[1], v3 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * d2 + e2[4] * m2 + e2[8] * v3 + e2[12], t2[13] = e2[1] * d2 + e2[5] * m2 + e2[9] * v3 + e2[13], t2[14] = e2[2] * d2 + e2[6] * m2 + e2[10] * v3 + e2[14], t2[15] = e2[3] * d2 + e2[7] * m2 + e2[11] * v3 + e2[15]) : (i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p3 = e2[7], c3 = e2[8], h3 = e2[9], f2 = e2[10], y3 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = a2, t2[3] = o2, t2[4] = s2, t2[5] = u2, t2[6] = l2, t2[7] = p3, t2[8] = c3, t2[9] = h3, t2[10] = f2, t2[11] = y3, t2[12] = n2 * d2 + s2 * m2 + c3 * v3 + e2[12], t2[13] = i2 * d2 + u2 * m2 + h3 * v3 + e2[13], t2[14] = a2 * d2 + l2 * m2 + f2 * v3 + e2[14], t2[15] = o2 * d2 + p3 * m2 + y3 * v3 + e2[15]), t2;
      }, t.triggerPluginCompletionEvent = ei, t.uniqueId = y2, t.validateCustomStyleLayer = function(t2) {
        var e2 = [], r2 = t2.id;
        return void 0 === r2 && e2.push({ message: "layers." + r2 + ': missing required property "id"' }), void 0 === t2.render && e2.push({ message: "layers." + r2 + ': missing required method "render"' }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: "layers." + r2 + ': property "renderingMode" must be either "2d" or "3d"' }), e2;
      }, t.validateLight = En, t.validateStyle = Cn, t.values = function(t2) {
        var e2 = [];
        for (var r2 in t2)
          e2.push(t2[r2]);
        return e2;
      }, t.vectorTile = bs, t.version = "1.13.3", t.warnOnce = A2, t.webpSupported = U, t.window = o, t.wrap = c2;
    });
    define(["./shared"], function(e) {
      function t(e2) {
        var r2 = typeof e2;
        if ("number" === r2 || "boolean" === r2 || "string" === r2 || null == e2)
          return JSON.stringify(e2);
        if (Array.isArray(e2)) {
          for (var i2 = "[", o2 = 0, n2 = e2; o2 < n2.length; o2 += 1)
            i2 += t(n2[o2]) + ",";
          return i2 + "]";
        }
        for (var a2 = Object.keys(e2).sort(), s2 = "{", l2 = 0; l2 < a2.length; l2++)
          s2 += JSON.stringify(a2[l2]) + ":" + t(e2[a2[l2]]) + ",";
        return s2 + "}";
      }
      function r(r2) {
        for (var i2 = "", o2 = 0, n2 = e.refProperties; o2 < n2.length; o2 += 1)
          i2 += "/" + t(r2[n2[o2]]);
        return i2;
      }
      var i = function(e2) {
        this.keyCache = {}, e2 && this.replace(e2);
      };
      i.prototype.replace = function(e2) {
        this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
      }, i.prototype.update = function(t2, i2) {
        for (var o2 = this, n2 = 0, a2 = t2; n2 < a2.length; n2 += 1) {
          var s2 = a2[n2];
          this._layerConfigs[s2.id] = s2;
          var l2 = this._layers[s2.id] = e.createStyleLayer(s2);
          l2._featureFilter = e.featureFilter(l2.filter), this.keyCache[s2.id] && delete this.keyCache[s2.id];
        }
        for (var u2 = 0, h3 = i2; u2 < h3.length; u2 += 1) {
          var c3 = h3[u2];
          delete this.keyCache[c3], delete this._layerConfigs[c3], delete this._layers[c3];
        }
        this.familiesBySource = {};
        for (var p3 = 0, f2 = function(e2, t3) {
          for (var i3 = {}, o3 = 0; o3 < e2.length; o3++) {
            var n3 = t3 && t3[e2[o3].id] || r(e2[o3]);
            t3 && (t3[e2[o3].id] = n3);
            var a3 = i3[n3];
            a3 || (a3 = i3[n3] = []), a3.push(e2[o3]);
          }
          var s3 = [];
          for (var l3 in i3)
            s3.push(i3[l3]);
          return s3;
        }(e.values(this._layerConfigs), this.keyCache); p3 < f2.length; p3 += 1) {
          var d2 = f2[p3].map(function(e2) {
            return o2._layers[e2.id];
          }), g2 = d2[0];
          if ("none" !== g2.visibility) {
            var v3 = g2.source || "", m2 = this.familiesBySource[v3];
            m2 || (m2 = this.familiesBySource[v3] = {});
            var y3 = g2.sourceLayer || "_geojsonTileLayer", x2 = m2[y3];
            x2 || (x2 = m2[y3] = []), x2.push(d2);
          }
        }
      };
      var o = function(t2) {
        var r2 = {}, i2 = [];
        for (var o2 in t2) {
          var n2 = t2[o2], a2 = r2[o2] = {};
          for (var s2 in n2) {
            var l2 = n2[+s2];
            if (l2 && 0 !== l2.bitmap.width && 0 !== l2.bitmap.height) {
              var u2 = { x: 0, y: 0, w: l2.bitmap.width + 2, h: l2.bitmap.height + 2 };
              i2.push(u2), a2[s2] = { rect: u2, metrics: l2.metrics };
            }
          }
        }
        var h3 = e.potpack(i2), c3 = new e.AlphaImage({ width: h3.w || 1, height: h3.h || 1 });
        for (var p3 in t2) {
          var f2 = t2[p3];
          for (var d2 in f2) {
            var g2 = f2[+d2];
            if (g2 && 0 !== g2.bitmap.width && 0 !== g2.bitmap.height) {
              var v3 = r2[p3][d2].rect;
              e.AlphaImage.copy(g2.bitmap, c3, { x: 0, y: 0 }, { x: v3.x + 1, y: v3.y + 1 }, g2.bitmap);
            }
          }
        }
        this.image = c3, this.positions = r2;
      };
      e.register("GlyphAtlas", o);
      var n = function(t2) {
        this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
      };
      function a(t2, r2, i2) {
        for (var o2 = new e.EvaluationParameters(r2), n2 = 0, a2 = t2; n2 < a2.length; n2 += 1)
          a2[n2].recalculate(o2, i2);
      }
      function s(t2, r2) {
        var i2 = e.getArrayBuffer(t2.request, function(t3, i3, o2, n2) {
          t3 ? r2(t3) : i3 && r2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: o2, expires: n2 });
        });
        return function() {
          i2.cancel(), r2();
        };
      }
      n.prototype.parse = function(t2, r2, i2, n2, s2) {
        var l2 = this;
        this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
        var u2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), h3 = new e.FeatureIndex(this.tileID, this.promoteId);
        h3.bucketLayerIDs = [];
        var c3, p3, f2, d2, g2 = {}, v3 = { featureIndex: h3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, m2 = r2.familiesBySource[this.source];
        for (var y3 in m2) {
          var x2 = t2.layers[y3];
          if (x2) {
            1 === x2.version && e.warnOnce('Vector tile source "' + this.source + '" layer "' + y3 + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
            for (var w2 = u2.encode(y3), S2 = [], I3 = 0; I3 < x2.length; I3++) {
              var M2 = x2.feature(I3), b2 = h3.getId(M2, y3);
              S2.push({ feature: M2, id: b2, index: I3, sourceLayerIndex: w2 });
            }
            for (var _24 = 0, k2 = m2[y3]; _24 < k2.length; _24 += 1) {
              var P2 = k2[_24], T2 = P2[0];
              T2.minzoom && this.zoom < Math.floor(T2.minzoom) || T2.maxzoom && this.zoom >= T2.maxzoom || "none" !== T2.visibility && (a(P2, this.zoom, i2), (g2[T2.id] = T2.createBucket({ index: h3.bucketLayerIDs.length, layers: P2, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: w2, sourceID: this.source })).populate(S2, v3, this.tileID.canonical), h3.bucketLayerIDs.push(P2.map(function(e2) {
                return e2.id;
              })));
            }
          }
        }
        var C2 = e.mapObject(v3.glyphDependencies, function(e2) {
          return Object.keys(e2).map(Number);
        });
        Object.keys(C2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: C2 }, function(e2, t3) {
          c3 || (c3 = e2, p3 = t3, z2.call(l2));
        }) : p3 = {};
        var D2 = Object.keys(v3.iconDependencies);
        D2.length ? n2.send("getImages", { icons: D2, source: this.source, tileID: this.tileID, type: "icons" }, function(e2, t3) {
          c3 || (c3 = e2, f2 = t3, z2.call(l2));
        }) : f2 = {};
        var L2 = Object.keys(v3.patternDependencies);
        function z2() {
          if (c3)
            return s2(c3);
          if (p3 && f2 && d2) {
            var t3 = new o(p3), r3 = new e.ImageAtlas(f2, d2);
            for (var n3 in g2) {
              var l3 = g2[n3];
              l3 instanceof e.SymbolBucket ? (a(l3.layers, this.zoom, i2), e.performSymbolLayout(l3, p3, t3.positions, f2, r3.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l3.hasPattern && (l3 instanceof e.LineBucket || l3 instanceof e.FillBucket || l3 instanceof e.FillExtrusionBucket) && (a(l3.layers, this.zoom, i2), l3.addFeatures(v3, this.tileID.canonical, r3.patternPositions));
            }
            this.status = "done", s2(null, { buckets: e.values(g2).filter(function(e2) {
              return !e2.isEmpty();
            }), featureIndex: h3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: r3, glyphMap: this.returnDependencies ? p3 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
          }
        }
        L2.length ? n2.send("getImages", { icons: L2, source: this.source, tileID: this.tileID, type: "patterns" }, function(e2, t3) {
          c3 || (c3 = e2, d2 = t3, z2.call(l2));
        }) : d2 = {}, z2.call(this);
      };
      var l = function(e2, t2, r2, i2) {
        this.actor = e2, this.layerIndex = t2, this.availableImages = r2, this.loadVectorData = i2 || s, this.loading = {}, this.loaded = {};
      };
      l.prototype.loadTile = function(t2, r2) {
        var i2 = this, o2 = t2.uid;
        this.loading || (this.loading = {});
        var a2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[o2] = new n(t2);
        s2.abort = this.loadVectorData(t2, function(t3, n2) {
          if (delete i2.loading[o2], t3 || !n2)
            return s2.status = "done", i2.loaded[o2] = s2, r2(t3);
          var l2 = n2.rawData, u2 = {};
          n2.expires && (u2.expires = n2.expires), n2.cacheControl && (u2.cacheControl = n2.cacheControl);
          var h3 = {};
          if (a2) {
            var c3 = a2.finish();
            c3 && (h3.resourceTiming = JSON.parse(JSON.stringify(c3)));
          }
          s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, i2.layerIndex, i2.availableImages, i2.actor, function(t4, i3) {
            if (t4 || !i3)
              return r2(t4);
            r2(null, e.extend({ rawTileData: l2.slice(0) }, i3, u2, h3));
          }), i2.loaded = i2.loaded || {}, i2.loaded[o2] = s2;
        });
      }, l.prototype.reloadTile = function(e2, t2) {
        var r2 = this, i2 = this.loaded, o2 = e2.uid, n2 = this;
        if (i2 && i2[o2]) {
          var a2 = i2[o2];
          a2.showCollisionBoxes = e2.showCollisionBoxes;
          var s2 = function(e3, i3) {
            var o3 = a2.reloadCallback;
            o3 && (delete a2.reloadCallback, a2.parse(a2.vectorTile, n2.layerIndex, r2.availableImages, n2.actor, o3)), t2(e3, i3);
          };
          "parsing" === a2.status ? a2.reloadCallback = s2 : "done" === a2.status && (a2.vectorTile ? a2.parse(a2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
        }
      }, l.prototype.abortTile = function(e2, t2) {
        var r2 = this.loading, i2 = e2.uid;
        r2 && r2[i2] && r2[i2].abort && (r2[i2].abort(), delete r2[i2]), t2();
      }, l.prototype.removeTile = function(e2, t2) {
        var r2 = this.loaded, i2 = e2.uid;
        r2 && r2[i2] && delete r2[i2], t2();
      };
      var u = e.window.ImageBitmap, h2 = function() {
        this.loaded = {};
      };
      function c2(e2, t2) {
        if (0 !== e2.length) {
          p2(e2[0], t2);
          for (var r2 = 1; r2 < e2.length; r2++)
            p2(e2[r2], !t2);
        }
      }
      function p2(e2, t2) {
        for (var r2 = 0, i2 = 0, o2 = 0, n2 = e2.length, a2 = n2 - 1; o2 < n2; a2 = o2++) {
          var s2 = (e2[o2][0] - e2[a2][0]) * (e2[a2][1] + e2[o2][1]), l2 = r2 + s2;
          i2 += Math.abs(r2) >= Math.abs(s2) ? r2 - l2 + s2 : s2 - l2 + r2, r2 = l2;
        }
        r2 + i2 >= 0 != !!t2 && e2.reverse();
      }
      h2.prototype.loadTile = function(t2, r2) {
        var i2 = t2.uid, o2 = t2.encoding, n2 = t2.rawImageData, a2 = u && n2 instanceof u ? this.getImageData(n2) : n2, s2 = new e.DEMData(i2, a2, o2);
        this.loaded = this.loaded || {}, this.loaded[i2] = s2, r2(null, s2);
      }, h2.prototype.getImageData = function(t2) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
        var r2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: r2.width, height: r2.height }, r2.data);
      }, h2.prototype.removeTile = function(e2) {
        var t2 = this.loaded, r2 = e2.uid;
        t2 && t2[r2] && delete t2[r2];
      };
      var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON, d = function(t2) {
        this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
      };
      d.prototype.loadGeometry = function() {
        if (1 === this._feature.type) {
          for (var t2 = [], r2 = 0, i2 = this._feature.geometry; r2 < i2.length; r2 += 1) {
            var o2 = i2[r2];
            t2.push([new e.Point$1(o2[0], o2[1])]);
          }
          return t2;
        }
        for (var n2 = [], a2 = 0, s2 = this._feature.geometry; a2 < s2.length; a2 += 1) {
          for (var l2 = [], u2 = 0, h3 = s2[a2]; u2 < h3.length; u2 += 1) {
            var c3 = h3[u2];
            l2.push(new e.Point$1(c3[0], c3[1]));
          }
          n2.push(l2);
        }
        return n2;
      }, d.prototype.toGeoJSON = function(e2, t2, r2) {
        return f.call(this, e2, t2, r2);
      };
      var g = function(t2) {
        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
      };
      g.prototype.feature = function(e2) {
        return new d(this._features[e2]);
      };
      var v2 = e.vectorTile.VectorTileFeature, m = y2;
      function y2(e2, t2) {
        this.options = t2 || {}, this.features = e2, this.length = e2.length;
      }
      function x(e2, t2) {
        this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
      }
      y2.prototype.feature = function(e2) {
        return new x(this.features[e2], this.options.extent);
      }, x.prototype.loadGeometry = function() {
        var t2 = this.rawGeometry;
        this.geometry = [];
        for (var r2 = 0; r2 < t2.length; r2++) {
          for (var i2 = t2[r2], o2 = [], n2 = 0; n2 < i2.length; n2++)
            o2.push(new e.Point$1(i2[n2][0], i2[n2][1]));
          this.geometry.push(o2);
        }
        return this.geometry;
      }, x.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, i2 = 1 / 0, o2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
          for (var a2 = e2[n2], s2 = 0; s2 < a2.length; s2++) {
            var l2 = a2[s2];
            t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), i2 = Math.min(i2, l2.y), o2 = Math.max(o2, l2.y);
          }
        return [t2, i2, r2, o2];
      }, x.prototype.toGeoJSON = v2.prototype.toGeoJSON;
      var w = I2, S = m;
      function I2(t2) {
        var r2 = new e.pbf();
        return function(e2, t3) {
          for (var r3 in e2.layers)
            t3.writeMessage(3, M, e2.layers[r3]);
        }(t2, r2), r2.finish();
      }
      function M(e2, t2) {
        var r2;
        t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
        var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r2 = 0; r2 < e2.length; r2++)
          i2.feature = e2.feature(r2), t2.writeMessage(2, b, i2);
        var o2 = i2.keys;
        for (r2 = 0; r2 < o2.length; r2++)
          t2.writeStringField(3, o2[r2]);
        var n2 = i2.values;
        for (r2 = 0; r2 < n2.length; r2++)
          t2.writeMessage(4, C, n2[r2]);
      }
      function b(e2, t2) {
        var r2 = e2.feature;
        void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, _23, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, T, r2);
      }
      function _23(e2, t2) {
        var r2 = e2.feature, i2 = e2.keys, o2 = e2.values, n2 = e2.keycache, a2 = e2.valuecache;
        for (var s2 in r2.properties) {
          var l2 = n2[s2];
          void 0 === l2 && (i2.push(s2), n2[s2] = l2 = i2.length - 1), t2.writeVarint(l2);
          var u2 = r2.properties[s2], h3 = typeof u2;
          "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (u2 = JSON.stringify(u2));
          var c3 = h3 + ":" + u2, p3 = a2[c3];
          void 0 === p3 && (o2.push(u2), a2[c3] = p3 = o2.length - 1), t2.writeVarint(p3);
        }
      }
      function k(e2, t2) {
        return (t2 << 3) + (7 & e2);
      }
      function P(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function T(e2, t2) {
        for (var r2 = e2.loadGeometry(), i2 = e2.type, o2 = 0, n2 = 0, a2 = r2.length, s2 = 0; s2 < a2; s2++) {
          var l2 = r2[s2], u2 = 1;
          1 === i2 && (u2 = l2.length), t2.writeVarint(k(1, u2));
          for (var h3 = 3 === i2 ? l2.length - 1 : l2.length, c3 = 0; c3 < h3; c3++) {
            1 === c3 && 1 !== i2 && t2.writeVarint(k(2, h3 - 1));
            var p3 = l2[c3].x - o2, f2 = l2[c3].y - n2;
            t2.writeVarint(P(p3)), t2.writeVarint(P(f2)), o2 += p3, n2 += f2;
          }
          3 === i2 && t2.writeVarint(k(7, 1));
        }
      }
      function C(e2, t2) {
        var r2 = typeof e2;
        "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
      }
      function D(e2, t2, r2, i2) {
        L(e2, r2, i2), L(t2, 2 * r2, 2 * i2), L(t2, 2 * r2 + 1, 2 * i2 + 1);
      }
      function L(e2, t2, r2) {
        var i2 = e2[t2];
        e2[t2] = e2[r2], e2[r2] = i2;
      }
      function z(e2, t2, r2, i2) {
        var o2 = e2 - r2, n2 = t2 - i2;
        return o2 * o2 + n2 * n2;
      }
      w.fromVectorTileJs = I2, w.fromGeojsonVt = function(e2, t2) {
        t2 = t2 || {};
        var r2 = {};
        for (var i2 in e2)
          r2[i2] = new m(e2[i2].features, t2), r2[i2].name = i2, r2[i2].version = t2.version, r2[i2].extent = t2.extent;
        return I2({ layers: r2 });
      }, w.GeoJSONWrapper = S;
      var O2 = function(e2) {
        return e2[0];
      }, E = function(e2) {
        return e2[1];
      }, F = function(e2, t2, r2, i2, o2) {
        void 0 === t2 && (t2 = O2), void 0 === r2 && (r2 = E), void 0 === i2 && (i2 = 64), void 0 === o2 && (o2 = Float64Array), this.nodeSize = i2, this.points = e2;
        for (var n2 = e2.length < 65536 ? Uint16Array : Uint32Array, a2 = this.ids = new n2(e2.length), s2 = this.coords = new o2(2 * e2.length), l2 = 0; l2 < e2.length; l2++)
          a2[l2] = l2, s2[2 * l2] = t2(e2[l2]), s2[2 * l2 + 1] = r2(e2[l2]);
        !function e3(t3, r3, i3, o3, n3, a3) {
          if (!(n3 - o3 <= i3)) {
            var s3 = o3 + n3 >> 1;
            !function e4(t4, r4, i4, o4, n4, a4) {
              for (; n4 > o4; ) {
                if (n4 - o4 > 600) {
                  var s4 = n4 - o4 + 1, l3 = i4 - o4 + 1, u2 = Math.log(s4), h3 = 0.5 * Math.exp(2 * u2 / 3), c3 = 0.5 * Math.sqrt(u2 * h3 * (s4 - h3) / s4) * (l3 - s4 / 2 < 0 ? -1 : 1);
                  e4(t4, r4, i4, Math.max(o4, Math.floor(i4 - l3 * h3 / s4 + c3)), Math.min(n4, Math.floor(i4 + (s4 - l3) * h3 / s4 + c3)), a4);
                }
                var p3 = r4[2 * i4 + a4], f2 = o4, d2 = n4;
                for (D(t4, r4, o4, i4), r4[2 * n4 + a4] > p3 && D(t4, r4, o4, n4); f2 < d2; ) {
                  for (D(t4, r4, f2, d2), f2++, d2--; r4[2 * f2 + a4] < p3; )
                    f2++;
                  for (; r4[2 * d2 + a4] > p3; )
                    d2--;
                }
                r4[2 * o4 + a4] === p3 ? D(t4, r4, o4, d2) : D(t4, r4, ++d2, n4), d2 <= i4 && (o4 = d2 + 1), i4 <= d2 && (n4 = d2 - 1);
              }
            }(t3, r3, s3, o3, n3, a3 % 2), e3(t3, r3, i3, o3, s3 - 1, a3 + 1), e3(t3, r3, i3, s3 + 1, n3, a3 + 1);
          }
        }(a2, s2, i2, 0, a2.length - 1, 0);
      };
      F.prototype.range = function(e2, t2, r2, i2) {
        return function(e3, t3, r3, i3, o2, n2, a2) {
          for (var s2, l2, u2 = [0, e3.length - 1, 0], h3 = []; u2.length; ) {
            var c3 = u2.pop(), p3 = u2.pop(), f2 = u2.pop();
            if (p3 - f2 <= a2)
              for (var d2 = f2; d2 <= p3; d2++)
                l2 = t3[2 * d2 + 1], (s2 = t3[2 * d2]) >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h3.push(e3[d2]);
            else {
              var g2 = Math.floor((f2 + p3) / 2);
              l2 = t3[2 * g2 + 1], (s2 = t3[2 * g2]) >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h3.push(e3[g2]);
              var v3 = (c3 + 1) % 2;
              (0 === c3 ? r3 <= s2 : i3 <= l2) && (u2.push(f2), u2.push(g2 - 1), u2.push(v3)), (0 === c3 ? o2 >= s2 : n2 >= l2) && (u2.push(g2 + 1), u2.push(p3), u2.push(v3));
            }
          }
          return h3;
        }(this.ids, this.coords, e2, t2, r2, i2, this.nodeSize);
      }, F.prototype.within = function(e2, t2, r2) {
        return function(e3, t3, r3, i2, o2, n2) {
          for (var a2 = [0, e3.length - 1, 0], s2 = [], l2 = o2 * o2; a2.length; ) {
            var u2 = a2.pop(), h3 = a2.pop(), c3 = a2.pop();
            if (h3 - c3 <= n2)
              for (var p3 = c3; p3 <= h3; p3++)
                z(t3[2 * p3], t3[2 * p3 + 1], r3, i2) <= l2 && s2.push(e3[p3]);
            else {
              var f2 = Math.floor((c3 + h3) / 2), d2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
              z(d2, g2, r3, i2) <= l2 && s2.push(e3[f2]);
              var v3 = (u2 + 1) % 2;
              (0 === u2 ? r3 - o2 <= d2 : i2 - o2 <= g2) && (a2.push(c3), a2.push(f2 - 1), a2.push(v3)), (0 === u2 ? r3 + o2 >= d2 : i2 + o2 >= g2) && (a2.push(f2 + 1), a2.push(h3), a2.push(v3));
            }
          }
          return s2;
        }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
      };
      var N = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: function(e2) {
        return e2;
      } }, J = function(e2) {
        this.options = V2(Object.create(N), e2), this.trees = new Array(this.options.maxZoom + 1);
      };
      function Z2(e2, t2, r2, i2, o2) {
        return { x: e2, y: t2, zoom: 1 / 0, id: r2, parentId: -1, numPoints: i2, properties: o2 };
      }
      function A2(e2, t2) {
        var r2 = e2.geometry.coordinates, i2 = r2[1];
        return { x: Y(r2[0]), y: j(i2), zoom: 1 / 0, index: t2, parentId: -1 };
      }
      function B(e2) {
        return { type: "Feature", id: e2.id, properties: G(e2), geometry: { type: "Point", coordinates: [(i2 = e2.x, 360 * (i2 - 0.5)), (t2 = e2.y, r2 = (180 - 360 * t2) * Math.PI / 180, 360 * Math.atan(Math.exp(r2)) / Math.PI - 90)] } };
        var t2, r2, i2;
      }
      function G(e2) {
        var t2 = e2.numPoints, r2 = t2 >= 1e4 ? Math.round(t2 / 1e3) + "k" : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
        return V2(V2({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
      }
      function Y(e2) {
        return e2 / 360 + 0.5;
      }
      function j(e2) {
        var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function V2(e2, t2) {
        for (var r2 in t2)
          e2[r2] = t2[r2];
        return e2;
      }
      function X(e2) {
        return e2.x;
      }
      function W(e2) {
        return e2.y;
      }
      function R(e2, t2, r2, i2, o2, n2) {
        var a2 = o2 - r2, s2 = n2 - i2;
        if (0 !== a2 || 0 !== s2) {
          var l2 = ((e2 - r2) * a2 + (t2 - i2) * s2) / (a2 * a2 + s2 * s2);
          l2 > 1 ? (r2 = o2, i2 = n2) : l2 > 0 && (r2 += a2 * l2, i2 += s2 * l2);
        }
        return (a2 = e2 - r2) * a2 + (s2 = t2 - i2) * s2;
      }
      function q(e2, t2, r2, i2) {
        var o2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(e3) {
          var t3 = e3.geometry, r3 = e3.type;
          if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
            U(e3, t3);
          else if ("Polygon" === r3 || "MultiLineString" === r3)
            for (var i3 = 0; i3 < t3.length; i3++)
              U(e3, t3[i3]);
          else if ("MultiPolygon" === r3)
            for (i3 = 0; i3 < t3.length; i3++)
              for (var o3 = 0; o3 < t3[i3].length; o3++)
                U(e3, t3[i3][o3]);
        }(o2), o2;
      }
      function U(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2 += 3)
          e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
      }
      function $(e2, t2, r2, i2) {
        if (t2.geometry) {
          var o2 = t2.geometry.coordinates, n2 = t2.geometry.type, a2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), s2 = [], l2 = t2.id;
          if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = i2 || 0), "Point" === n2)
            H(o2, s2);
          else if ("MultiPoint" === n2)
            for (var u2 = 0; u2 < o2.length; u2++)
              H(o2[u2], s2);
          else if ("LineString" === n2)
            K(o2, s2, a2, false);
          else if ("MultiLineString" === n2) {
            if (r2.lineMetrics) {
              for (u2 = 0; u2 < o2.length; u2++)
                K(o2[u2], s2 = [], a2, false), e2.push(q(l2, "LineString", s2, t2.properties));
              return;
            }
            Q(o2, s2, a2, false);
          } else if ("Polygon" === n2)
            Q(o2, s2, a2, true);
          else {
            if ("MultiPolygon" !== n2) {
              if ("GeometryCollection" === n2) {
                for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                  $(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, i2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (u2 = 0; u2 < o2.length; u2++) {
              var h3 = [];
              Q(o2[u2], h3, a2, true), s2.push(h3);
            }
          }
          e2.push(q(l2, n2, s2, t2.properties));
        }
      }
      function H(e2, t2) {
        t2.push(ee(e2[0])), t2.push(te(e2[1])), t2.push(0);
      }
      function K(e2, t2, r2, i2) {
        for (var o2, n2, a2 = 0, s2 = 0; s2 < e2.length; s2++) {
          var l2 = ee(e2[s2][0]), u2 = te(e2[s2][1]);
          t2.push(l2), t2.push(u2), t2.push(0), s2 > 0 && (a2 += i2 ? (o2 * u2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - o2, 2) + Math.pow(u2 - n2, 2))), o2 = l2, n2 = u2;
        }
        var h3 = t2.length - 3;
        t2[2] = 1, function e3(t3, r3, i3, o3) {
          for (var n3, a3 = o3, s3 = i3 - r3 >> 1, l3 = i3 - r3, u3 = t3[r3], h4 = t3[r3 + 1], c3 = t3[i3], p3 = t3[i3 + 1], f2 = r3 + 3; f2 < i3; f2 += 3) {
            var d2 = R(t3[f2], t3[f2 + 1], u3, h4, c3, p3);
            if (d2 > a3)
              n3 = f2, a3 = d2;
            else if (d2 === a3) {
              var g2 = Math.abs(f2 - s3);
              g2 < l3 && (n3 = f2, l3 = g2);
            }
          }
          a3 > o3 && (n3 - r3 > 3 && e3(t3, r3, n3, o3), t3[n3 + 2] = a3, i3 - n3 > 3 && e3(t3, n3, i3, o3));
        }(t2, 0, h3, r2), t2[h3 + 2] = 1, t2.size = Math.abs(a2), t2.start = 0, t2.end = t2.size;
      }
      function Q(e2, t2, r2, i2) {
        for (var o2 = 0; o2 < e2.length; o2++) {
          var n2 = [];
          K(e2[o2], n2, r2, i2), t2.push(n2);
        }
      }
      function ee(e2) {
        return e2 / 360 + 0.5;
      }
      function te(e2) {
        var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function re(e2, t2, r2, i2, o2, n2, a2, s2) {
        if (i2 /= t2, n2 >= (r2 /= t2) && a2 < i2)
          return e2;
        if (a2 < r2 || n2 >= i2)
          return null;
        for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
          var h3 = e2[u2], c3 = h3.geometry, p3 = h3.type, f2 = 0 === o2 ? h3.minX : h3.minY, d2 = 0 === o2 ? h3.maxX : h3.maxY;
          if (f2 >= r2 && d2 < i2)
            l2.push(h3);
          else if (!(d2 < r2 || f2 >= i2)) {
            var g2 = [];
            if ("Point" === p3 || "MultiPoint" === p3)
              ie(c3, g2, r2, i2, o2);
            else if ("LineString" === p3)
              oe(c3, g2, r2, i2, o2, false, s2.lineMetrics);
            else if ("MultiLineString" === p3)
              ae(c3, g2, r2, i2, o2, false);
            else if ("Polygon" === p3)
              ae(c3, g2, r2, i2, o2, true);
            else if ("MultiPolygon" === p3)
              for (var v3 = 0; v3 < c3.length; v3++) {
                var m2 = [];
                ae(c3[v3], m2, r2, i2, o2, true), m2.length && g2.push(m2);
              }
            if (g2.length) {
              if (s2.lineMetrics && "LineString" === p3) {
                for (v3 = 0; v3 < g2.length; v3++)
                  l2.push(q(h3.id, p3, g2[v3], h3.tags));
                continue;
              }
              "LineString" !== p3 && "MultiLineString" !== p3 || (1 === g2.length ? (p3 = "LineString", g2 = g2[0]) : p3 = "MultiLineString"), "Point" !== p3 && "MultiPoint" !== p3 || (p3 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(q(h3.id, p3, g2, h3.tags));
            }
          }
        }
        return l2.length ? l2 : null;
      }
      function ie(e2, t2, r2, i2, o2) {
        for (var n2 = 0; n2 < e2.length; n2 += 3) {
          var a2 = e2[n2 + o2];
          a2 >= r2 && a2 <= i2 && (t2.push(e2[n2]), t2.push(e2[n2 + 1]), t2.push(e2[n2 + 2]));
        }
      }
      function oe(e2, t2, r2, i2, o2, n2, a2) {
        for (var s2, l2, u2 = ne(e2), h3 = 0 === o2 ? le : ue, c3 = e2.start, p3 = 0; p3 < e2.length - 3; p3 += 3) {
          var f2 = e2[p3], d2 = e2[p3 + 1], g2 = e2[p3 + 2], v3 = e2[p3 + 3], m2 = e2[p3 + 4], y3 = 0 === o2 ? f2 : d2, x2 = 0 === o2 ? v3 : m2, w2 = false;
          a2 && (s2 = Math.sqrt(Math.pow(f2 - v3, 2) + Math.pow(d2 - m2, 2))), y3 < r2 ? x2 > r2 && (l2 = h3(u2, f2, d2, v3, m2, r2), a2 && (u2.start = c3 + s2 * l2)) : y3 > i2 ? x2 < i2 && (l2 = h3(u2, f2, d2, v3, m2, i2), a2 && (u2.start = c3 + s2 * l2)) : se(u2, f2, d2, g2), x2 < r2 && y3 >= r2 && (l2 = h3(u2, f2, d2, v3, m2, r2), w2 = true), x2 > i2 && y3 <= i2 && (l2 = h3(u2, f2, d2, v3, m2, i2), w2 = true), !n2 && w2 && (a2 && (u2.end = c3 + s2 * l2), t2.push(u2), u2 = ne(e2)), a2 && (c3 += s2);
        }
        var S2 = e2.length - 3;
        f2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (y3 = 0 === o2 ? f2 : d2) >= r2 && y3 <= i2 && se(u2, f2, d2, g2), S2 = u2.length - 3, n2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && se(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
      }
      function ne(e2) {
        var t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function ae(e2, t2, r2, i2, o2, n2) {
        for (var a2 = 0; a2 < e2.length; a2++)
          oe(e2[a2], t2, r2, i2, o2, n2, false);
      }
      function se(e2, t2, r2, i2) {
        e2.push(t2), e2.push(r2), e2.push(i2);
      }
      function le(e2, t2, r2, i2, o2, n2) {
        var a2 = (n2 - t2) / (i2 - t2);
        return e2.push(n2), e2.push(r2 + (o2 - r2) * a2), e2.push(1), a2;
      }
      function ue(e2, t2, r2, i2, o2, n2) {
        var a2 = (n2 - r2) / (o2 - r2);
        return e2.push(t2 + (i2 - t2) * a2), e2.push(n2), e2.push(1), a2;
      }
      function he(e2, t2) {
        for (var r2 = [], i2 = 0; i2 < e2.length; i2++) {
          var o2, n2 = e2[i2], a2 = n2.type;
          if ("Point" === a2 || "MultiPoint" === a2 || "LineString" === a2)
            o2 = ce(n2.geometry, t2);
          else if ("MultiLineString" === a2 || "Polygon" === a2) {
            o2 = [];
            for (var s2 = 0; s2 < n2.geometry.length; s2++)
              o2.push(ce(n2.geometry[s2], t2));
          } else if ("MultiPolygon" === a2)
            for (o2 = [], s2 = 0; s2 < n2.geometry.length; s2++) {
              for (var l2 = [], u2 = 0; u2 < n2.geometry[s2].length; u2++)
                l2.push(ce(n2.geometry[s2][u2], t2));
              o2.push(l2);
            }
          r2.push(q(n2.id, a2, o2, n2.tags));
        }
        return r2;
      }
      function ce(e2, t2) {
        var r2 = [];
        r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
        for (var i2 = 0; i2 < e2.length; i2 += 3)
          r2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
        return r2;
      }
      function pe(e2, t2) {
        if (e2.transformed)
          return e2;
        var r2, i2, o2, n2 = 1 << e2.z, a2 = e2.x, s2 = e2.y;
        for (r2 = 0; r2 < e2.features.length; r2++) {
          var l2 = e2.features[r2], u2 = l2.geometry, h3 = l2.type;
          if (l2.geometry = [], 1 === h3)
            for (i2 = 0; i2 < u2.length; i2 += 2)
              l2.geometry.push(fe(u2[i2], u2[i2 + 1], t2, n2, a2, s2));
          else
            for (i2 = 0; i2 < u2.length; i2++) {
              var c3 = [];
              for (o2 = 0; o2 < u2[i2].length; o2 += 2)
                c3.push(fe(u2[i2][o2], u2[i2][o2 + 1], t2, n2, a2, s2));
              l2.geometry.push(c3);
            }
        }
        return e2.transformed = true, e2;
      }
      function fe(e2, t2, r2, i2, o2, n2) {
        return [Math.round(r2 * (e2 * i2 - o2)), Math.round(r2 * (t2 * i2 - n2))];
      }
      function de(e2, t2, r2, i2, o2) {
        for (var n2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), a2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s2 = 0; s2 < e2.length; s2++) {
          a2.numFeatures++, ge(a2, e2[s2], n2, o2);
          var l2 = e2[s2].minX, u2 = e2[s2].minY, h3 = e2[s2].maxX, c3 = e2[s2].maxY;
          l2 < a2.minX && (a2.minX = l2), u2 < a2.minY && (a2.minY = u2), h3 > a2.maxX && (a2.maxX = h3), c3 > a2.maxY && (a2.maxY = c3);
        }
        return a2;
      }
      function ge(e2, t2, r2, i2) {
        var o2 = t2.geometry, n2 = t2.type, a2 = [];
        if ("Point" === n2 || "MultiPoint" === n2)
          for (var s2 = 0; s2 < o2.length; s2 += 3)
            a2.push(o2[s2]), a2.push(o2[s2 + 1]), e2.numPoints++, e2.numSimplified++;
        else if ("LineString" === n2)
          ve(a2, o2, e2, r2, false, false);
        else if ("MultiLineString" === n2 || "Polygon" === n2)
          for (s2 = 0; s2 < o2.length; s2++)
            ve(a2, o2[s2], e2, r2, "Polygon" === n2, 0 === s2);
        else if ("MultiPolygon" === n2)
          for (var l2 = 0; l2 < o2.length; l2++) {
            var u2 = o2[l2];
            for (s2 = 0; s2 < u2.length; s2++)
              ve(a2, u2[s2], e2, r2, true, 0 === s2);
          }
        if (a2.length) {
          var h3 = t2.tags || null;
          if ("LineString" === n2 && i2.lineMetrics) {
            for (var c3 in h3 = {}, t2.tags)
              h3[c3] = t2.tags[c3];
            h3.mapbox_clip_start = o2.start / o2.size, h3.mapbox_clip_end = o2.end / o2.size;
          }
          var p3 = { geometry: a2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: h3 };
          null !== t2.id && (p3.id = t2.id), e2.features.push(p3);
        }
      }
      function ve(e2, t2, r2, i2, o2, n2) {
        var a2 = i2 * i2;
        if (i2 > 0 && t2.size < (o2 ? a2 : i2))
          r2.numPoints += t2.length / 3;
        else {
          for (var s2 = [], l2 = 0; l2 < t2.length; l2 += 3)
            (0 === i2 || t2[l2 + 2] > a2) && (r2.numSimplified++, s2.push(t2[l2]), s2.push(t2[l2 + 1])), r2.numPoints++;
          o2 && function(e3, t3) {
            for (var r3 = 0, i3 = 0, o3 = e3.length, n3 = o3 - 2; i3 < o3; n3 = i3, i3 += 2)
              r3 += (e3[i3] - e3[n3]) * (e3[i3 + 1] + e3[n3 + 1]);
            if (r3 > 0 === t3)
              for (i3 = 0, o3 = e3.length; i3 < o3 / 2; i3 += 2) {
                var a3 = e3[i3], s3 = e3[i3 + 1];
                e3[i3] = e3[o3 - 2 - i3], e3[i3 + 1] = e3[o3 - 1 - i3], e3[o3 - 2 - i3] = a3, e3[o3 - 1 - i3] = s3;
              }
          }(s2, n2), e2.push(s2);
        }
      }
      function me(e2, t2) {
        var r2 = (t2 = this.options = function(e3, t3) {
          for (var r3 in t3)
            e3[r3] = t3[r3];
          return e3;
        }(Object.create(this.options), t2)).debug;
        if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (t2.promoteId && t2.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var i2 = function(e3, t3) {
          var r3 = [];
          if ("FeatureCollection" === e3.type)
            for (var i3 = 0; i3 < e3.features.length; i3++)
              $(r3, e3.features[i3], t3, i3);
          else
            $(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
          return r3;
        }(e2, t2);
        this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i2 = function(e3, t3) {
          var r3 = t3.buffer / t3.extent, i3 = e3, o2 = re(e3, 1, -1 - r3, r3, 0, -1, 2, t3), n2 = re(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
          return (o2 || n2) && (i3 = re(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], o2 && (i3 = he(o2, 1).concat(i3)), n2 && (i3 = i3.concat(he(n2, -1)))), i3;
        }(i2, t2)).length && this.splitTile(i2, 0, 0, 0), r2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function ye(e2, t2, r2) {
        return 32 * ((1 << e2) * r2 + t2) + e2;
      }
      function xe(e2, t2) {
        var r2 = e2.tileID.canonical;
        if (!this._geoJSONIndex)
          return t2(null, null);
        var i2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
        if (!i2)
          return t2(null, null);
        var o2 = new g(i2.features), n2 = w(o2);
        0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: o2, rawData: n2.buffer });
      }
      J.prototype.load = function(e2) {
        var t2 = this.options, r2 = t2.log, i2 = t2.minZoom, o2 = t2.maxZoom, n2 = t2.nodeSize;
        r2 && console.time("total time");
        var a2 = "prepare " + e2.length + " points";
        r2 && console.time(a2), this.points = e2;
        for (var s2 = [], l2 = 0; l2 < e2.length; l2++)
          e2[l2].geometry && s2.push(A2(e2[l2], l2));
        this.trees[o2 + 1] = new F(s2, X, W, n2, Float32Array), r2 && console.timeEnd(a2);
        for (var u2 = o2; u2 >= i2; u2--) {
          var h3 = +Date.now();
          s2 = this._cluster(s2, u2), this.trees[u2] = new F(s2, X, W, n2, Float32Array), r2 && console.log("z%d: %d clusters in %dms", u2, s2.length, +Date.now() - h3);
        }
        return r2 && console.timeEnd("total time"), this;
      }, J.prototype.getClusters = function(e2, t2) {
        var r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180, i2 = Math.max(-90, Math.min(90, e2[1])), o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180, n2 = Math.max(-90, Math.min(90, e2[3]));
        if (e2[2] - e2[0] >= 360)
          r2 = -180, o2 = 180;
        else if (r2 > o2) {
          var a2 = this.getClusters([r2, i2, 180, n2], t2), s2 = this.getClusters([-180, i2, o2, n2], t2);
          return a2.concat(s2);
        }
        for (var l2 = this.trees[this._limitZoom(t2)], u2 = [], h3 = 0, c3 = l2.range(Y(r2), j(n2), Y(o2), j(i2)); h3 < c3.length; h3 += 1) {
          var p3 = l2.points[c3[h3]];
          u2.push(p3.numPoints ? B(p3) : this.points[p3.index]);
        }
        return u2;
      }, J.prototype.getChildren = function(e2) {
        var t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[r2];
        if (!o2)
          throw new Error(i2);
        var n2 = o2.points[t2];
        if (!n2)
          throw new Error(i2);
        for (var a2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), s2 = [], l2 = 0, u2 = o2.within(n2.x, n2.y, a2); l2 < u2.length; l2 += 1) {
          var h3 = o2.points[u2[l2]];
          h3.parentId === e2 && s2.push(h3.numPoints ? B(h3) : this.points[h3.index]);
        }
        if (0 === s2.length)
          throw new Error(i2);
        return s2;
      }, J.prototype.getLeaves = function(e2, t2, r2) {
        var i2 = [];
        return this._appendLeaves(i2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), i2;
      }, J.prototype.getTile = function(e2, t2, r2) {
        var i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), n2 = this.options, a2 = n2.radius / n2.extent, s2 = (r2 - a2) / o2, l2 = (r2 + 1 + a2) / o2, u2 = { features: [] };
        return this._addTileFeatures(i2.range((t2 - a2) / o2, s2, (t2 + 1 + a2) / o2, l2), i2.points, t2, r2, o2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / o2, s2, 1, l2), i2.points, o2, r2, o2, u2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, s2, a2 / o2, l2), i2.points, -1, r2, o2, u2), u2.features.length ? u2 : null;
      }, J.prototype.getClusterExpansionZoom = function(e2) {
        for (var t2 = this._getOriginZoom(e2) - 1; t2 <= this.options.maxZoom; ) {
          var r2 = this.getChildren(e2);
          if (t2++, 1 !== r2.length)
            break;
          e2 = r2[0].properties.cluster_id;
        }
        return t2;
      }, J.prototype._appendLeaves = function(e2, t2, r2, i2, o2) {
        for (var n2 = 0, a2 = this.getChildren(t2); n2 < a2.length; n2 += 1) {
          var s2 = a2[n2], l2 = s2.properties;
          if (l2 && l2.cluster ? o2 + l2.point_count <= i2 ? o2 += l2.point_count : o2 = this._appendLeaves(e2, l2.cluster_id, r2, i2, o2) : o2 < i2 ? o2++ : e2.push(s2), e2.length === r2)
            break;
        }
        return o2;
      }, J.prototype._addTileFeatures = function(e2, t2, r2, i2, o2, n2) {
        for (var a2 = 0, s2 = e2; a2 < s2.length; a2 += 1) {
          var l2 = t2[s2[a2]], u2 = l2.numPoints, h3 = { type: 1, geometry: [[Math.round(this.options.extent * (l2.x * o2 - r2)), Math.round(this.options.extent * (l2.y * o2 - i2))]], tags: u2 ? G(l2) : this.points[l2.index].properties }, c3 = void 0;
          u2 ? c3 = l2.id : this.options.generateId ? c3 = l2.index : this.points[l2.index].id && (c3 = this.points[l2.index].id), void 0 !== c3 && (h3.id = c3), n2.features.push(h3);
        }
      }, J.prototype._limitZoom = function(e2) {
        return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
      }, J.prototype._cluster = function(e2, t2) {
        for (var r2 = [], i2 = this.options, o2 = i2.reduce, n2 = i2.minPoints, a2 = i2.radius / (i2.extent * Math.pow(2, t2)), s2 = 0; s2 < e2.length; s2++) {
          var l2 = e2[s2];
          if (!(l2.zoom <= t2)) {
            l2.zoom = t2;
            for (var u2 = this.trees[t2 + 1], h3 = u2.within(l2.x, l2.y, a2), c3 = l2.numPoints || 1, p3 = c3, f2 = 0, d2 = h3; f2 < d2.length; f2 += 1) {
              var g2 = u2.points[d2[f2]];
              g2.zoom > t2 && (p3 += g2.numPoints || 1);
            }
            if (p3 >= n2) {
              for (var v3 = l2.x * c3, m2 = l2.y * c3, y3 = o2 && c3 > 1 ? this._map(l2, true) : null, x2 = (s2 << 5) + (t2 + 1) + this.points.length, w2 = 0, S2 = h3; w2 < S2.length; w2 += 1) {
                var I3 = u2.points[S2[w2]];
                if (!(I3.zoom <= t2)) {
                  I3.zoom = t2;
                  var M2 = I3.numPoints || 1;
                  v3 += I3.x * M2, m2 += I3.y * M2, I3.parentId = x2, o2 && (y3 || (y3 = this._map(l2, true)), o2(y3, this._map(I3)));
                }
              }
              l2.parentId = x2, r2.push(Z2(v3 / p3, m2 / p3, x2, p3, y3));
            } else if (r2.push(l2), p3 > 1)
              for (var b2 = 0, _24 = h3; b2 < _24.length; b2 += 1) {
                var k2 = u2.points[_24[b2]];
                k2.zoom <= t2 || (k2.zoom = t2, r2.push(k2));
              }
          }
        }
        return r2;
      }, J.prototype._getOriginId = function(e2) {
        return e2 - this.points.length >> 5;
      }, J.prototype._getOriginZoom = function(e2) {
        return (e2 - this.points.length) % 32;
      }, J.prototype._map = function(e2, t2) {
        if (e2.numPoints)
          return t2 ? V2({}, e2.properties) : e2.properties;
        var r2 = this.points[e2.index].properties, i2 = this.options.map(r2);
        return t2 && i2 === r2 ? V2({}, i2) : i2;
      }, me.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, me.prototype.splitTile = function(e2, t2, r2, i2, o2, n2, a2) {
        for (var s2 = [e2, t2, r2, i2], l2 = this.options, u2 = l2.debug; s2.length; ) {
          i2 = s2.pop(), r2 = s2.pop(), t2 = s2.pop(), e2 = s2.pop();
          var h3 = 1 << t2, c3 = ye(t2, r2, i2), p3 = this.tiles[c3];
          if (!p3 && (u2 > 1 && console.time("creation"), p3 = this.tiles[c3] = de(e2, t2, r2, i2, l2), this.tileCoords.push({ z: t2, x: r2, y: i2 }), u2)) {
            u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, i2, p3.numFeatures, p3.numPoints, p3.numSimplified), console.timeEnd("creation"));
            var f2 = "z" + t2;
            this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
          }
          if (p3.source = e2, o2) {
            if (t2 === l2.maxZoom || t2 === o2)
              continue;
            var d2 = 1 << o2 - t2;
            if (r2 !== Math.floor(n2 / d2) || i2 !== Math.floor(a2 / d2))
              continue;
          } else if (t2 === l2.indexMaxZoom || p3.numPoints <= l2.indexMaxPoints)
            continue;
          if (p3.source = null, 0 !== e2.length) {
            u2 > 1 && console.time("clipping");
            var g2, v3, m2, y3, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, I3 = 0.5 - S2, M2 = 0.5 + S2, b2 = 1 + S2;
            g2 = v3 = m2 = y3 = null, x2 = re(e2, h3, r2 - S2, r2 + M2, 0, p3.minX, p3.maxX, l2), w2 = re(e2, h3, r2 + I3, r2 + b2, 0, p3.minX, p3.maxX, l2), e2 = null, x2 && (g2 = re(x2, h3, i2 - S2, i2 + M2, 1, p3.minY, p3.maxY, l2), v3 = re(x2, h3, i2 + I3, i2 + b2, 1, p3.minY, p3.maxY, l2), x2 = null), w2 && (m2 = re(w2, h3, i2 - S2, i2 + M2, 1, p3.minY, p3.maxY, l2), y3 = re(w2, h3, i2 + I3, i2 + b2, 1, p3.minY, p3.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), s2.push(g2 || [], t2 + 1, 2 * r2, 2 * i2), s2.push(v3 || [], t2 + 1, 2 * r2, 2 * i2 + 1), s2.push(m2 || [], t2 + 1, 2 * r2 + 1, 2 * i2), s2.push(y3 || [], t2 + 1, 2 * r2 + 1, 2 * i2 + 1);
          }
        }
      }, me.prototype.getTile = function(e2, t2, r2) {
        var i2 = this.options, o2 = i2.extent, n2 = i2.debug;
        if (e2 < 0 || e2 > 24)
          return null;
        var a2 = 1 << e2, s2 = ye(e2, t2 = (t2 % a2 + a2) % a2, r2);
        if (this.tiles[s2])
          return pe(this.tiles[s2], o2);
        n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
        for (var l2, u2 = e2, h3 = t2, c3 = r2; !l2 && u2 > 0; )
          u2--, h3 = Math.floor(h3 / 2), c3 = Math.floor(c3 / 2), l2 = this.tiles[ye(u2, h3, c3)];
        return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h3, c3), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h3, c3, e2, t2, r2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[s2] ? pe(this.tiles[s2], o2) : null) : null;
      };
      var we = function(t2) {
        function r2(e2, r3, i2, o2) {
          t2.call(this, e2, r3, i2, xe), o2 && (this.loadGeoJSON = o2);
        }
        return t2 && (r2.__proto__ = t2), (r2.prototype = Object.create(t2 && t2.prototype)).constructor = r2, r2.prototype.loadData = function(e2, t3) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: true }), this._pendingCallback = t3, this._pendingLoadDataParams = e2, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
        }, r2.prototype._loadData = function() {
          var t3 = this;
          if (this._pendingCallback && this._pendingLoadDataParams) {
            var r3 = this._pendingCallback, i2 = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            var o2 = !!(i2 && i2.request && i2.request.collectResourceTiming) && new e.RequestPerformance(i2.request);
            this.loadGeoJSON(i2, function(n2, a2) {
              if (n2 || !a2)
                return r3(n2);
              if ("object" != typeof a2)
                return r3(new Error("Input data given to '" + i2.source + "' is not a valid GeoJSON object."));
              !function e2(t4, r4) {
                var i3, o3 = t4 && t4.type;
                if ("FeatureCollection" === o3)
                  for (i3 = 0; i3 < t4.features.length; i3++)
                    e2(t4.features[i3], r4);
                else if ("GeometryCollection" === o3)
                  for (i3 = 0; i3 < t4.geometries.length; i3++)
                    e2(t4.geometries[i3], r4);
                else if ("Feature" === o3)
                  e2(t4.geometry, r4);
                else if ("Polygon" === o3)
                  c2(t4.coordinates, r4);
                else if ("MultiPolygon" === o3)
                  for (i3 = 0; i3 < t4.coordinates.length; i3++)
                    c2(t4.coordinates[i3], r4);
                return t4;
              }(a2, true);
              try {
                if (i2.filter) {
                  var s2 = e.createExpression(i2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === s2.result)
                    throw new Error(s2.value.map(function(e2) {
                      return e2.key + ": " + e2.message;
                    }).join(", "));
                  var l2 = a2.features.filter(function(e2) {
                    return s2.value.evaluate({ zoom: 0 }, e2);
                  });
                  a2 = { type: "FeatureCollection", features: l2 };
                }
                t3._geoJSONIndex = i2.cluster ? new J(function(t4) {
                  var r4 = t4.superclusterOptions, i3 = t4.clusterProperties;
                  if (!i3 || !r4)
                    return r4;
                  for (var o3 = {}, n3 = {}, a3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, l3 = Object.keys(i3), u3 = 0, h4 = l3; u3 < h4.length; u3 += 1) {
                    var c3 = h4[u3], p3 = i3[c3], f2 = p3[0], d2 = e.createExpression(p3[1]), g2 = e.createExpression("string" == typeof f2 ? [f2, ["accumulated"], ["get", c3]] : f2);
                    o3[c3] = d2.value, n3[c3] = g2.value;
                  }
                  return r4.map = function(e2) {
                    s3.properties = e2;
                    for (var t5 = {}, r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                      var n4 = i4[r5];
                      t5[n4] = o3[n4].evaluate(a3, s3);
                    }
                    return t5;
                  }, r4.reduce = function(e2, t5) {
                    s3.properties = t5;
                    for (var r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                      var o4 = i4[r5];
                      a3.accumulated = e2[o4], e2[o4] = n3[o4].evaluate(a3, s3);
                    }
                  }, r4;
                }(i2)).load(a2.features) : function(e2, t4) {
                  return new me(e2, t4);
                }(a2, i2.geojsonVtOptions);
              } catch (n3) {
                return r3(n3);
              }
              t3.loaded = {};
              var u2 = {};
              if (o2) {
                var h3 = o2.finish();
                h3 && (u2.resourceTiming = {}, u2.resourceTiming[i2.source] = JSON.parse(JSON.stringify(h3)));
              }
              r3(null, u2);
            });
          }
        }, r2.prototype.coalesce = function() {
          "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());
        }, r2.prototype.reloadTile = function(e2, r3) {
          var i2 = this.loaded;
          return i2 && i2[e2.uid] ? t2.prototype.reloadTile.call(this, e2, r3) : this.loadTile(e2, r3);
        }, r2.prototype.loadGeoJSON = function(t3, r3) {
          if (t3.request)
            e.getJSON(t3.request, r3);
          else {
            if ("string" != typeof t3.data)
              return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
            try {
              return r3(null, JSON.parse(t3.data));
            } catch (e2) {
              return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
            }
          }
        }, r2.prototype.removeSource = function(e2, t3) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
        }, r2.prototype.getClusterExpansionZoom = function(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }, r2.prototype.getClusterChildren = function(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }, r2.prototype.getClusterLeaves = function(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          } catch (e3) {
            t3(e3);
          }
        }, r2;
      }(l), Se = function(t2) {
        var r2 = this;
        this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: we }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(e2, t3) {
          if (r2.workerSourceTypes[e2])
            throw new Error('Worker source with name "' + e2 + '" already registered.');
          r2.workerSourceTypes[e2] = t3;
        }, this.self.registerRTLTextPlugin = function(t3) {
          if (e.plugin.isParsed())
            throw new Error("RTL text plugin already registered.");
          e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
        };
      };
      return Se.prototype.setReferrer = function(e2, t2) {
        this.referrer = t2;
      }, Se.prototype.setImages = function(e2, t2, r2) {
        for (var i2 in this.availableImages[e2] = t2, this.workerSources[e2]) {
          var o2 = this.workerSources[e2][i2];
          for (var n2 in o2)
            o2[n2].availableImages = t2;
        }
        r2();
      }, Se.prototype.setLayers = function(e2, t2, r2) {
        this.getLayerIndex(e2).replace(t2), r2();
      }, Se.prototype.updateLayers = function(e2, t2, r2) {
        this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
      }, Se.prototype.loadTile = function(e2, t2, r2) {
        this.getWorkerSource(e2, t2.type, t2.source).loadTile(t2, r2);
      }, Se.prototype.loadDEMTile = function(e2, t2, r2) {
        this.getDEMWorkerSource(e2, t2.source).loadTile(t2, r2);
      }, Se.prototype.reloadTile = function(e2, t2, r2) {
        this.getWorkerSource(e2, t2.type, t2.source).reloadTile(t2, r2);
      }, Se.prototype.abortTile = function(e2, t2, r2) {
        this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
      }, Se.prototype.removeTile = function(e2, t2, r2) {
        this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
      }, Se.prototype.removeDEMTile = function(e2, t2) {
        this.getDEMWorkerSource(e2, t2.source).removeTile(t2);
      }, Se.prototype.removeSource = function(e2, t2, r2) {
        if (this.workerSources[e2] && this.workerSources[e2][t2.type] && this.workerSources[e2][t2.type][t2.source]) {
          var i2 = this.workerSources[e2][t2.type][t2.source];
          delete this.workerSources[e2][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, r2) : r2();
        }
      }, Se.prototype.loadWorkerSource = function(e2, t2, r2) {
        try {
          this.self.importScripts(t2.url), r2();
        } catch (e3) {
          r2(e3.toString());
        }
      }, Se.prototype.syncRTLPluginState = function(t2, r2, i2) {
        try {
          e.plugin.setState(r2);
          var o2 = e.plugin.getPluginURL();
          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o2) {
            this.self.importScripts(o2);
            var n2 = e.plugin.isParsed();
            i2(n2 ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o2), n2);
          }
        } catch (e2) {
          i2(e2.toString());
        }
      }, Se.prototype.getAvailableImages = function(e2) {
        var t2 = this.availableImages[e2];
        return t2 || (t2 = []), t2;
      }, Se.prototype.getLayerIndex = function(e2) {
        var t2 = this.layerIndexes[e2];
        return t2 || (t2 = this.layerIndexes[e2] = new i()), t2;
      }, Se.prototype.getWorkerSource = function(e2, t2, r2) {
        var i2 = this;
        return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), this.workerSources[e2][t2][r2] || (this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2]({ send: function(t3, r3, o2) {
          i2.actor.send(t3, r3, o2, e2);
        } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t2][r2];
      }, Se.prototype.getDEMWorkerSource = function(e2, t2) {
        return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new h2()), this.demWorkerSources[e2][t2];
      }, Se.prototype.enforceCacheSizeLimit = function(t2, r2) {
        e.enforceCacheSizeLimit(r2);
      }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;
    });
    define(["./shared"], function(t) {
      var e = t.createCommonjsModule(function(t2) {
        function e2(t3) {
          return !i2(t3);
        }
        function i2(t3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var t4, e3, i4 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i4);
            try {
              e3 = new Worker(o3), t4 = true;
            } catch (e4) {
              t4 = false;
            }
            return e3 && e3.terminate(), URL.revokeObjectURL(o3), t4;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var t4 = document.createElement("canvas");
            t4.width = t4.height = 1;
            var e3 = t4.getContext("2d");
            if (!e3)
              return false;
            var i4 = e3.getImageData(0, 0, 1, 1);
            return i4 && i4.width === t4.width;
          }() ? (void 0 === o2[i3 = t3 && t3.failIfMajorPerformanceCaveat] && (o2[i3] = function(t4) {
            var i4 = function(t5) {
              var i5 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
              return o4.failIfMajorPerformanceCaveat = t5, i5.probablySupportsContext ? i5.probablySupportsContext("webgl", o4) || i5.probablySupportsContext("experimental-webgl", o4) : i5.supportsContext ? i5.supportsContext("webgl", o4) || i5.supportsContext("experimental-webgl", o4) : i5.getContext("webgl", o4) || i5.getContext("experimental-webgl", o4);
            }(t4);
            if (!i4)
              return false;
            var o3 = i4.createShader(i4.VERTEX_SHADER);
            return !(!o3 || i4.isContextLost()) && (i4.shaderSource(o3, "void main() {}"), i4.compileShader(o3), true === i4.getShaderParameter(o3, i4.COMPILE_STATUS));
          }(i3)), o2[i3] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var i3;
        }
        t2.exports ? t2.exports = e2 : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e2, window.mapboxgl.notSupportedReason = i2);
        var o2 = {};
        e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      }), i = { create: function(e2, i2, o2) {
        var r2 = t.window.document.createElement(e2);
        return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
      }, createNS: function(e2, i2) {
        return t.window.document.createElementNS(e2, i2);
      } }, o = t.window.document && t.window.document.documentElement.style;
      function r(t2) {
        if (!o)
          return t2[0];
        for (var e2 = 0; e2 < t2.length; e2++)
          if (t2[e2] in o)
            return t2[e2];
        return t2[0];
      }
      var a, n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
      i.disableDrag = function() {
        o && n && (a = o[n], o[n] = "none");
      }, i.enableDrag = function() {
        o && n && (o[n] = a);
      };
      var s = r(["transform", "WebkitTransform"]);
      i.setTransform = function(t2, e2) {
        t2.style[s] = e2;
      };
      var l = false;
      try {
        var c2 = Object.defineProperty({}, "passive", { get: function() {
          l = true;
        } });
        t.window.addEventListener("test", c2, c2), t.window.removeEventListener("test", c2, c2);
      } catch (t2) {
        l = false;
      }
      i.addEventListener = function(t2, e2, i2, o2) {
        void 0 === o2 && (o2 = {}), t2.addEventListener(e2, i2, "passive" in o2 && l ? o2 : o2.capture);
      }, i.removeEventListener = function(t2, e2, i2, o2) {
        void 0 === o2 && (o2 = {}), t2.removeEventListener(e2, i2, "passive" in o2 && l ? o2 : o2.capture);
      };
      var u = function(e2) {
        e2.preventDefault(), e2.stopPropagation(), t.window.removeEventListener("click", u, true);
      };
      function h2(t2) {
        var e2 = t2.userImage;
        return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
      }
      i.suppressClick = function() {
        t.window.addEventListener("click", u, true), t.window.setTimeout(function() {
          t.window.removeEventListener("click", u, true);
        }, 0);
      }, i.mousePos = function(e2, i2) {
        var o2 = e2.getBoundingClientRect();
        return new t.Point(i2.clientX - o2.left - e2.clientLeft, i2.clientY - o2.top - e2.clientTop);
      }, i.touchPos = function(e2, i2) {
        for (var o2 = e2.getBoundingClientRect(), r2 = [], a2 = 0; a2 < i2.length; a2++)
          r2.push(new t.Point(i2[a2].clientX - o2.left - e2.clientLeft, i2[a2].clientY - o2.top - e2.clientTop));
        return r2;
      }, i.mouseButton = function(e2) {
        return void 0 !== t.window.InstallTrigger && 2 === e2.button && e2.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
      }, i.remove = function(t2) {
        t2.parentNode && t2.parentNode.removeChild(t2);
      };
      var p2 = function(e2) {
        function i2() {
          e2.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.isLoaded = function() {
          return this.loaded;
        }, i2.prototype.setLoaded = function(t2) {
          if (this.loaded !== t2 && (this.loaded = t2, t2)) {
            for (var e3 = 0, i3 = this.requestors; e3 < i3.length; e3 += 1) {
              var o2 = i3[e3];
              this._notify(o2.ids, o2.callback);
            }
            this.requestors = [];
          }
        }, i2.prototype.getImage = function(t2) {
          return this.images[t2];
        }, i2.prototype.addImage = function(t2, e3) {
          this._validate(t2, e3) && (this.images[t2] = e3);
        }, i2.prototype._validate = function(e3, i3) {
          var o2 = true;
          return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchX" value'))), o2 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchY" value'))), o2 = false), this._validateContent(i3.content, i3) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "content" value'))), o2 = false), o2;
        }, i2.prototype._validateStretch = function(t2, e3) {
          if (!t2)
            return true;
          for (var i3 = 0, o2 = 0, r2 = t2; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2];
            if (a2[0] < i3 || a2[1] < a2[0] || e3 < a2[1])
              return false;
            i3 = a2[1];
          }
          return true;
        }, i2.prototype._validateContent = function(t2, e3) {
          return !(t2 && (4 !== t2.length || t2[0] < 0 || e3.data.width < t2[0] || t2[1] < 0 || e3.data.height < t2[1] || t2[2] < 0 || e3.data.width < t2[2] || t2[3] < 0 || e3.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
        }, i2.prototype.updateImage = function(t2, e3) {
          e3.version = this.images[t2].version + 1, this.images[t2] = e3, this.updatedImages[t2] = true;
        }, i2.prototype.removeImage = function(t2) {
          var e3 = this.images[t2];
          delete this.images[t2], delete this.patterns[t2], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
        }, i2.prototype.listImages = function() {
          return Object.keys(this.images);
        }, i2.prototype.getImages = function(t2, e3) {
          var i3 = true;
          if (!this.isLoaded())
            for (var o2 = 0, r2 = t2; o2 < r2.length; o2 += 1)
              this.images[r2[o2]] || (i3 = false);
          this.isLoaded() || i3 ? this._notify(t2, e3) : this.requestors.push({ ids: t2, callback: e3 });
        }, i2.prototype._notify = function(e3, i3) {
          for (var o2 = {}, r2 = 0, a2 = e3; r2 < a2.length; r2 += 1) {
            var n2 = a2[r2];
            this.images[n2] || this.fire(new t.Event("styleimagemissing", { id: n2 }));
            var s2 = this.images[n2];
            s2 ? o2[n2] = { data: s2.data.clone(), pixelRatio: s2.pixelRatio, sdf: s2.sdf, version: s2.version, stretchX: s2.stretchX, stretchY: s2.stretchY, content: s2.content, hasRenderCallback: Boolean(s2.userImage && s2.userImage.render) } : t.warnOnce('Image "' + n2 + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
          }
          i3(null, o2);
        }, i2.prototype.getPixelSize = function() {
          var t2 = this.atlasImage;
          return { width: t2.width, height: t2.height };
        }, i2.prototype.getPattern = function(e3) {
          var i3 = this.patterns[e3], o2 = this.getImage(e3);
          if (!o2)
            return null;
          if (i3 && i3.position.version === o2.version)
            return i3.position;
          if (i3)
            i3.position.version = o2.version;
          else {
            var r2 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(r2, o2);
            this.patterns[e3] = { bin: r2, position: a2 };
          }
          return this._updatePatternAtlas(), this.patterns[e3].position;
        }, i2.prototype.bind = function(e3) {
          var i3 = e3.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.Texture(e3, this.atlasImage, i3.RGBA), this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
        }, i2.prototype._updatePatternAtlas = function() {
          var e3 = [];
          for (var i3 in this.patterns)
            e3.push(this.patterns[i3].bin);
          var o2 = t.potpack(e3), r2 = o2.w, a2 = o2.h, n2 = this.atlasImage;
          for (var s2 in n2.resize({ width: r2 || 1, height: a2 || 1 }), this.patterns) {
            var l2 = this.patterns[s2].bin, c3 = l2.x + 1, u2 = l2.y + 1, h3 = this.images[s2].data, p3 = h3.width, d2 = h3.height;
            t.RGBAImage.copy(h3, n2, { x: 0, y: 0 }, { x: c3, y: u2 }, { width: p3, height: d2 }), t.RGBAImage.copy(h3, n2, { x: 0, y: d2 - 1 }, { x: c3, y: u2 - 1 }, { width: p3, height: 1 }), t.RGBAImage.copy(h3, n2, { x: 0, y: 0 }, { x: c3, y: u2 + d2 }, { width: p3, height: 1 }), t.RGBAImage.copy(h3, n2, { x: p3 - 1, y: 0 }, { x: c3 - 1, y: u2 }, { width: 1, height: d2 }), t.RGBAImage.copy(h3, n2, { x: 0, y: 0 }, { x: c3 + p3, y: u2 }, { width: 1, height: d2 });
          }
          this.dirty = true;
        }, i2.prototype.beginFrame = function() {
          this.callbackDispatchedThisFrame = {};
        }, i2.prototype.dispatchRenderCallbacks = function(t2) {
          for (var e3 = 0, i3 = t2; e3 < i3.length; e3 += 1) {
            var o2 = i3[e3];
            if (!this.callbackDispatchedThisFrame[o2]) {
              this.callbackDispatchedThisFrame[o2] = true;
              var r2 = this.images[o2];
              h2(r2) && this.updateImage(o2, r2);
            }
          }
        }, i2;
      }(t.Evented), d = m, _23 = m, f = 1e20;
      function m(t2, e2, i2, o2, r2, a2) {
        this.fontSize = t2 || 24, this.buffer = void 0 === e2 ? 3 : e2, this.cutoff = o2 || 0.25, this.fontFamily = r2 || "sans-serif", this.fontWeight = a2 || "normal", this.radius = i2 || 8;
        var n2 = this.size = this.fontSize + 2 * this.buffer;
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n2, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.d = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Int16Array(n2), this.middle = Math.round(n2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function g(t2, e2, i2, o2, r2, a2, n2) {
        for (var s2 = 0; s2 < e2; s2++) {
          for (var l2 = 0; l2 < i2; l2++)
            o2[l2] = t2[l2 * e2 + s2];
          for (v2(o2, r2, a2, n2, i2), l2 = 0; l2 < i2; l2++)
            t2[l2 * e2 + s2] = r2[l2];
        }
        for (l2 = 0; l2 < i2; l2++) {
          for (s2 = 0; s2 < e2; s2++)
            o2[s2] = t2[l2 * e2 + s2];
          for (v2(o2, r2, a2, n2, e2), s2 = 0; s2 < e2; s2++)
            t2[l2 * e2 + s2] = Math.sqrt(r2[s2]);
        }
      }
      function v2(t2, e2, i2, o2, r2) {
        i2[0] = 0, o2[0] = -f, o2[1] = +f;
        for (var a2 = 1, n2 = 0; a2 < r2; a2++) {
          for (var s2 = (t2[a2] + a2 * a2 - (t2[i2[n2]] + i2[n2] * i2[n2])) / (2 * a2 - 2 * i2[n2]); s2 <= o2[n2]; )
            n2--, s2 = (t2[a2] + a2 * a2 - (t2[i2[n2]] + i2[n2] * i2[n2])) / (2 * a2 - 2 * i2[n2]);
          i2[++n2] = a2, o2[n2] = s2, o2[n2 + 1] = +f;
        }
        for (a2 = 0, n2 = 0; a2 < r2; a2++) {
          for (; o2[n2 + 1] < a2; )
            n2++;
          e2[a2] = (a2 - i2[n2]) * (a2 - i2[n2]) + t2[i2[n2]];
        }
      }
      m.prototype.draw = function(t2) {
        this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t2, this.buffer, this.middle);
        for (var e2 = this.ctx.getImageData(0, 0, this.size, this.size), i2 = new Uint8ClampedArray(this.size * this.size), o2 = 0; o2 < this.size * this.size; o2++) {
          var r2 = e2.data[4 * o2 + 3] / 255;
          this.gridOuter[o2] = 1 === r2 ? 0 : 0 === r2 ? f : Math.pow(Math.max(0, 0.5 - r2), 2), this.gridInner[o2] = 1 === r2 ? f : 0 === r2 ? 0 : Math.pow(Math.max(0, r2 - 0.5), 2);
        }
        for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o2 = 0; o2 < this.size * this.size; o2++)
          i2[o2] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o2] - this.gridInner[o2]) / this.radius + this.cutoff))));
        return i2;
      }, d.default = _23;
      var y2 = function(t2, e2) {
        this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
      };
      y2.prototype.setURL = function(t2) {
        this.url = t2;
      }, y2.prototype.getGlyphs = function(e2, i2) {
        var o2 = this, r2 = [];
        for (var a2 in e2)
          for (var n2 = 0, s2 = e2[a2]; n2 < s2.length; n2 += 1)
            r2.push({ stack: a2, id: s2[n2] });
        t.asyncAll(r2, function(t2, e3) {
          var i3 = t2.stack, r3 = t2.id, a3 = o2.entries[i3];
          a3 || (a3 = o2.entries[i3] = { glyphs: {}, requests: {}, ranges: {} });
          var n3 = a3.glyphs[r3];
          if (void 0 === n3) {
            if (n3 = o2._tinySDF(a3, i3, r3))
              return a3.glyphs[r3] = n3, void e3(null, { stack: i3, id: r3, glyph: n3 });
            var s3 = Math.floor(r3 / 256);
            if (256 * s3 > 65535)
              e3(new Error("glyphs > 65535 not supported"));
            else if (a3.ranges[s3])
              e3(null, { stack: i3, id: r3, glyph: n3 });
            else {
              var l2 = a3.requests[s3];
              l2 || (l2 = a3.requests[s3] = [], y2.loadGlyphRange(i3, s3, o2.url, o2.requestManager, function(t3, e4) {
                if (e4) {
                  for (var i4 in e4)
                    o2._doesCharSupportLocalGlyph(+i4) || (a3.glyphs[+i4] = e4[+i4]);
                  a3.ranges[s3] = true;
                }
                for (var r4 = 0, n4 = l2; r4 < n4.length; r4 += 1)
                  (0, n4[r4])(t3, e4);
                delete a3.requests[s3];
              })), l2.push(function(t3, o3) {
                t3 ? e3(t3) : o3 && e3(null, { stack: i3, id: r3, glyph: o3[r3] || null });
              });
            }
          } else
            e3(null, { stack: i3, id: r3, glyph: n3 });
        }, function(t2, e3) {
          if (t2)
            i2(t2);
          else if (e3) {
            for (var o3 = {}, r3 = 0, a3 = e3; r3 < a3.length; r3 += 1) {
              var n3 = a3[r3], s3 = n3.stack, l2 = n3.id, c3 = n3.glyph;
              (o3[s3] || (o3[s3] = {}))[l2] = c3 && { id: c3.id, bitmap: c3.bitmap.clone(), metrics: c3.metrics };
            }
            i2(null, o3);
          }
        });
      }, y2.prototype._doesCharSupportLocalGlyph = function(e2) {
        return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e2) || t.isChar["Hangul Syllables"](e2) || t.isChar.Hiragana(e2) || t.isChar.Katakana(e2));
      }, y2.prototype._tinySDF = function(e2, i2, o2) {
        var r2 = this.localIdeographFontFamily;
        if (r2 && this._doesCharSupportLocalGlyph(o2)) {
          var a2 = e2.tinySDF;
          if (!a2) {
            var n2 = "400";
            /bold/i.test(i2) ? n2 = "900" : /medium/i.test(i2) ? n2 = "500" : /light/i.test(i2) && (n2 = "200"), a2 = e2.tinySDF = new y2.TinySDF(24, 3, 8, 0.25, r2, n2);
          }
          return { id: o2, bitmap: new t.AlphaImage({ width: 30, height: 30 }, a2.draw(String.fromCharCode(o2))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
        }
      }, y2.loadGlyphRange = function(e2, i2, o2, r2, a2) {
        var n2 = 256 * i2, s2 = n2 + 255, l2 = r2.transformRequest(r2.normalizeGlyphsURL(o2).replace("{fontstack}", e2).replace("{range}", n2 + "-" + s2), t.ResourceType.Glyphs);
        t.getArrayBuffer(l2, function(e3, i3) {
          if (e3)
            a2(e3);
          else if (i3) {
            for (var o3 = {}, r3 = 0, n3 = t.parseGlyphPBF(i3); r3 < n3.length; r3 += 1) {
              var s3 = n3[r3];
              o3[s3.id] = s3;
            }
            a2(null, o3);
          }
        });
      }, y2.TinySDF = d;
      var x = function() {
        this.specification = t.styleSpec.light.position;
      };
      x.prototype.possiblyEvaluate = function(e2, i2) {
        return t.sphericalToCartesian(e2.expression.evaluate(i2));
      }, x.prototype.interpolate = function(e2, i2, o2) {
        return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2) };
      };
      var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x(), color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function(e2) {
        function i2(i3) {
          e2.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i3), this._transitioning = this._transitionable.untransitioned();
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getLight = function() {
          return this._transitionable.serialize();
        }, i2.prototype.setLight = function(e3, i3) {
          if (void 0 === i3 && (i3 = {}), !this._validate(t.validateLight, e3, i3))
            for (var o2 in e3) {
              var r2 = e3[o2];
              t.endsWith(o2, "-transition") ? this._transitionable.setTransition(o2.slice(0, -"-transition".length), r2) : this._transitionable.setValue(o2, r2);
            }
        }, i2.prototype.updateTransitions = function(t2) {
          this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
        }, i2.prototype.hasTransition = function() {
          return this._transitioning.hasTransition();
        }, i2.prototype.recalculate = function(t2) {
          this.properties = this._transitioning.possiblyEvaluate(t2);
        }, i2.prototype._validate = function(e3, i3, o2) {
          return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t.styleSpec })));
        }, i2;
      }(t.Evented), T = function(t2, e2) {
        this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
      };
      T.prototype.getDash = function(t2, e2) {
        var i2 = t2.join(",") + String(e2);
        return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
      }, T.prototype.getDashRanges = function(t2, e2, i2) {
        var o2 = [], r2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, a2 = t2[0] * i2, n2 = true;
        o2.push({ left: r2, right: a2, isDash: n2, zeroLength: 0 === t2[0] });
        for (var s2 = t2[0], l2 = 1; l2 < t2.length; l2++) {
          var c3 = t2[l2];
          o2.push({ left: r2 = s2 * i2, right: a2 = (s2 += c3) * i2, isDash: n2 = !n2, zeroLength: 0 === c3 });
        }
        return o2;
      }, T.prototype.addRoundDash = function(t2, e2, i2) {
        for (var o2 = e2 / 2, r2 = -i2; r2 <= i2; r2++)
          for (var a2 = this.width * (this.nextRow + i2 + r2), n2 = 0, s2 = t2[n2], l2 = 0; l2 < this.width; l2++) {
            l2 / s2.right > 1 && (s2 = t2[++n2]);
            var c3 = Math.abs(l2 - s2.left), u2 = Math.abs(l2 - s2.right), h3 = Math.min(c3, u2), p3 = void 0, d2 = r2 / i2 * (o2 + 1);
            if (s2.isDash) {
              var _24 = o2 - Math.abs(d2);
              p3 = Math.sqrt(h3 * h3 + _24 * _24);
            } else
              p3 = o2 - Math.sqrt(h3 * h3 + d2 * d2);
            this.data[a2 + l2] = Math.max(0, Math.min(255, p3 + 128));
          }
      }, T.prototype.addRegularDash = function(t2) {
        for (var e2 = t2.length - 1; e2 >= 0; --e2) {
          var i2 = t2[e2], o2 = t2[e2 + 1];
          i2.zeroLength ? t2.splice(e2, 1) : o2 && o2.isDash === i2.isDash && (o2.left = i2.left, t2.splice(e2, 1));
        }
        var r2 = t2[0], a2 = t2[t2.length - 1];
        r2.isDash === a2.isDash && (r2.left = a2.left - this.width, a2.right = r2.right + this.width);
        for (var n2 = this.width * this.nextRow, s2 = 0, l2 = t2[s2], c3 = 0; c3 < this.width; c3++) {
          c3 / l2.right > 1 && (l2 = t2[++s2]);
          var u2 = Math.abs(c3 - l2.left), h3 = Math.abs(c3 - l2.right), p3 = Math.min(u2, h3);
          this.data[n2 + c3] = Math.max(0, Math.min(255, (l2.isDash ? p3 : -p3) + 128));
        }
      }, T.prototype.addDash = function(e2, i2) {
        var o2 = i2 ? 7 : 0, r2 = 2 * o2 + 1;
        if (this.nextRow + r2 > this.height)
          return t.warnOnce("LineAtlas out of space"), null;
        for (var a2 = 0, n2 = 0; n2 < e2.length; n2++)
          a2 += e2[n2];
        if (0 !== a2) {
          var s2 = this.width / a2, l2 = this.getDashRanges(e2, this.width, s2);
          i2 ? this.addRoundDash(l2, s2, o2) : this.addRegularDash(l2);
        }
        var c3 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: a2 };
        return this.nextRow += r2, this.dirty = true, c3;
      }, T.prototype.bind = function(t2) {
        var e2 = t2.gl;
        this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
      };
      var E = function e2(i2, o2) {
        this.workerPool = i2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
        for (var r2 = this.workerPool.acquire(this.id), a2 = 0; a2 < r2.length; a2++) {
          var n2 = new e2.Actor(r2[a2], o2, this.id);
          n2.name = "Worker " + a2, this.actors.push(n2);
        }
      };
      function I2(e2, i2, o2) {
        var r2 = function(r3, a2) {
          if (r3)
            return o2(r3);
          if (a2) {
            var n2 = t.pick(t.extend(a2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            a2.vector_layers && (n2.vectorLayers = a2.vector_layers, n2.vectorLayerIds = n2.vectorLayers.map(function(t2) {
              return t2.id;
            })), n2.tiles = i2.canonicalizeTileset(n2, e2.url), o2(null, n2);
          }
        };
        return e2.url ? t.getJSON(i2.transformRequest(i2.normalizeSourceURL(e2.url), t.ResourceType.Source), r2) : t.browser.frame(function() {
          return r2(null, e2);
        });
      }
      E.prototype.broadcast = function(e2, i2, o2) {
        t.asyncAll(this.actors, function(t2, o3) {
          t2.send(e2, i2, o3);
        }, o2 = o2 || function() {
        });
      }, E.prototype.getActor = function() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }, E.prototype.remove = function() {
        this.actors.forEach(function(t2) {
          t2.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }, E.Actor = t.Actor;
      var P = function(e2, i2, o2) {
        this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
      };
      P.prototype.validateBounds = function(t2) {
        return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
      }, P.prototype.contains = function(e2) {
        var i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), n2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
        return e2.x >= o2 && e2.x < a2 && e2.y >= r2 && e2.y < n2;
      };
      var S = function(e2) {
        function i2(i3, o2, r2, a2) {
          if (e2.call(this), this.id = i3, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(o2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, o2), this._collectResourceTiming = o2.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(a2);
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
          var e3 = this;
          this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I2(this._options, this.map._requestManager, function(i3, o2) {
            e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles, e3.map._requestManager._customAccessToken), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken, e3.map._requestManager._customAccessToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, i2.prototype.loaded = function() {
          return this._loaded;
        }, i2.prototype.hasTile = function(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }, i2.prototype.onAdd = function(t2) {
          this.map = t2, this.load();
        }, i2.prototype.setSourceProperty = function(t2) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
        }, i2.prototype.setTiles = function(t2) {
          var e3 = this;
          return this.setSourceProperty(function() {
            e3._options.tiles = t2;
          }), this;
        }, i2.prototype.setUrl = function(t2) {
          var e3 = this;
          return this.setSourceProperty(function() {
            e3.url = t2, e3._options.url = t2;
          }), this;
        }, i2.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, i2.prototype.serialize = function() {
          return t.extend({}, this._options);
        }, i2.prototype.loadTile = function(e3, i3) {
          var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function a2(o3, r3) {
            return delete e3.request, e3.aborted ? i3(null) : o3 && 404 !== o3.status ? i3(o3) : (r3 && r3.resourceTiming && (e3.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && e3.setExpiryData(r3), e3.loadVectorData(r3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i3(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
          }
          r2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i3 : e3.request = e3.actor.send("reloadTile", r2, a2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", r2, a2.bind(this)));
        }, i2.prototype.abortTile = function(t2) {
          t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
        }, i2.prototype.unloadTile = function(t2) {
          t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
        }, i2.prototype.hasTransition = function() {
          return false;
        }, i2;
      }(t.Evented), C = function(e2) {
        function i2(i3, o2, r2, a2) {
          e2.call(this), this.id = i3, this.dispatcher = r2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, o2), t.extend(this, t.pick(o2, ["url", "scheme", "tileSize"]));
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
          var e3 = this;
          this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I2(this._options, this.map._requestManager, function(i3, o2) {
            e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, i2.prototype.loaded = function() {
          return this._loaded;
        }, i2.prototype.onAdd = function(t2) {
          this.map = t2, this.load();
        }, i2.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, i2.prototype.serialize = function() {
          return t.extend({}, this._options);
        }, i2.prototype.hasTile = function(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }, i2.prototype.loadTile = function(e3, i3) {
          var o2 = this, r2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          e3.request = t.getImage(this.map._requestManager.transformRequest(r2, t.ResourceType.Tile), function(r3, a2) {
            if (delete e3.request, e3.aborted)
              e3.state = "unloaded", i3(null);
            else if (r3)
              e3.state = "errored", i3(r3);
            else if (a2) {
              o2.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
              var n2 = o2.map.painter.context, s2 = n2.gl;
              e3.texture = o2.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new t.Texture(n2, a2, s2.RGBA, { useMipmap: true }), e3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), n2.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, n2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n2.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(o2.dispatcher), i3(null);
            }
          });
        }, i2.prototype.abortTile = function(t2, e3) {
          t2.request && (t2.request.cancel(), delete t2.request), e3();
        }, i2.prototype.unloadTile = function(t2, e3) {
          t2.texture && this.map.painter.saveTileTexture(t2.texture), e3();
        }, i2.prototype.hasTransition = function() {
          return false;
        }, i2;
      }(t.Evented), z = function(e2) {
        function i2(i3, o2, r2, a2) {
          e2.call(this, i3, o2, r2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, o2), this.encoding = o2.encoding || "mapbox";
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.serialize = function() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }, i2.prototype.loadTile = function(e3, i3) {
          var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          function r2(t2, o3) {
            t2 && (e3.state = "errored", i3(t2)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.state = "loaded", i3(null));
          }
          e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, a2) {
            if (delete e3.request, e3.aborted)
              e3.state = "unloaded", i3(null);
            else if (o3)
              e3.state = "errored", i3(o3);
            else if (a2) {
              this.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
              var n2 = t.window.ImageBitmap && a2 instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a2 : t.browser.getImageData(a2, 1), s2 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: n2, encoding: this.encoding };
              e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", s2, r2.bind(this)));
            }
          }.bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
        }, i2.prototype._getNeighboringTiles = function(e3) {
          var i3 = e3.canonical, o2 = Math.pow(2, i3.z), r2 = (i3.x - 1 + o2) % o2, a2 = 0 === i3.x ? e3.wrap - 1 : e3.wrap, n2 = (i3.x + 1 + o2) % o2, s2 = i3.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
          return l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y + 1).key] = { backfilled: false }), l2;
        }, i2.prototype.unloadTile = function(t2) {
          t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
        }, i2;
      }(C), D = function(e2) {
        function i2(i3, o2, r2, a2) {
          e2.call(this), this.id = i3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._loaded = false, this.actor = r2.getActor(), this.setEventedParent(a2), this._data = o2.data, this._options = t.extend({}, o2), this._collectResourceTiming = o2.collectResourceTiming, this._resourceTiming = [], void 0 !== o2.maxzoom && (this.maxzoom = o2.maxzoom), o2.type && (this.type = o2.type), o2.attribution && (this.attribution = o2.attribution), this.promoteId = o2.promoteId;
          var n2 = t.EXTENT / this.tileSize;
          this.workerOptions = t.extend({ source: this.id, cluster: o2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== o2.buffer ? o2.buffer : 128) * n2, tolerance: (void 0 !== o2.tolerance ? o2.tolerance : 0.375) * n2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: o2.lineMetrics || false, generateId: o2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== o2.clusterMaxZoom ? Math.min(o2.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, o2.clusterMinPoints || 2), extent: t.EXTENT, radius: (o2.clusterRadius || 50) * n2, log: false, generateId: o2.generateId || false }, clusterProperties: o2.clusterProperties, filter: o2.filter }, o2.workerOptions);
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
          var e3 = this;
          this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(i3) {
            if (i3)
              e3.fire(new t.ErrorEvent(i3));
            else {
              var o2 = { dataType: "source", sourceDataType: "metadata" };
              e3._collectResourceTiming && e3._resourceTiming && e3._resourceTiming.length > 0 && (o2.resourceTiming = e3._resourceTiming, e3._resourceTiming = []), e3.fire(new t.Event("data", o2));
            }
          });
        }, i2.prototype.onAdd = function(t2) {
          this.map = t2, this.load();
        }, i2.prototype.setData = function(e3) {
          var i3 = this;
          return this._data = e3, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(e4) {
            if (e4)
              i3.fire(new t.ErrorEvent(e4));
            else {
              var o2 = { dataType: "source", sourceDataType: "content" };
              i3._collectResourceTiming && i3._resourceTiming && i3._resourceTiming.length > 0 && (o2.resourceTiming = i3._resourceTiming, i3._resourceTiming = []), i3.fire(new t.Event("data", o2));
            }
          }), this;
        }, i2.prototype.getClusterExpansionZoom = function(t2, e3) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e3), this;
        }, i2.prototype.getClusterChildren = function(t2, e3) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e3), this;
        }, i2.prototype.getClusterLeaves = function(t2, e3, i3, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e3, offset: i3 }, o2), this;
        }, i2.prototype._updateWorkerData = function(e3) {
          var i3 = this;
          this._loaded = false;
          var o2 = t.extend({}, this.workerOptions), r2 = this._data;
          "string" == typeof r2 ? (o2.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r2), t.ResourceType.Source), o2.request.collectResourceTiming = this._collectResourceTiming) : o2.data = JSON.stringify(r2), this.actor.send(this.type + ".loadData", o2, function(t2, r3) {
            i3._removed || r3 && r3.abandoned || (i3._loaded = true, r3 && r3.resourceTiming && r3.resourceTiming[i3.id] && (i3._resourceTiming = r3.resourceTiming[i3.id].slice(0)), i3.actor.send(i3.type + ".coalesce", { source: o2.source }, null), e3(t2));
          });
        }, i2.prototype.loaded = function() {
          return this._loaded;
        }, i2.prototype.loadTile = function(e3, i3) {
          var o2 = this, r2 = e3.actor ? "reloadTile" : "loadTile";
          e3.actor = this.actor, e3.request = this.actor.send(r2, { type: this.type, uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(t2, a2) {
            return delete e3.request, e3.unloadVectorData(), e3.aborted ? i3(null) : t2 ? i3(t2) : (e3.loadVectorData(a2, o2.map.painter, "reloadTile" === r2), i3(null));
          });
        }, i2.prototype.abortTile = function(t2) {
          t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
        }, i2.prototype.unloadTile = function(t2) {
          t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
        }, i2.prototype.onRemove = function() {
          this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
        }, i2.prototype.serialize = function() {
          return t.extend({}, this._options, { type: this.type, data: this._data });
        }, i2.prototype.hasTransition = function() {
          return false;
        }, i2;
      }(t.Evented), A2 = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), M = function(e2) {
        function i2(t2, i3, o2, r2) {
          e2.call(this), this.id = t2, this.dispatcher = o2, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = i3;
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function(e3, i3) {
          var o2 = this;
          this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function(r2, a2) {
            o2._loaded = true, r2 ? o2.fire(new t.ErrorEvent(r2)) : a2 && (o2.image = a2, e3 && (o2.coordinates = e3), i3 && i3(), o2._finishLoading());
          });
        }, i2.prototype.loaded = function() {
          return this._loaded;
        }, i2.prototype.updateImage = function(t2) {
          var e3 = this;
          return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, function() {
            e3.texture = null;
          }), this) : this;
        }, i2.prototype._finishLoading = function() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }, i2.prototype.onAdd = function(t2) {
          this.map = t2, this.load();
        }, i2.prototype.setCoordinates = function(e3) {
          var i3 = this;
          this.coordinates = e3;
          var o2 = e3.map(t.MercatorCoordinate.fromLngLat);
          this.tileID = function(e4) {
            for (var i4 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, a2 = -1 / 0, n2 = 0, s2 = e4; n2 < s2.length; n2 += 1) {
              var l2 = s2[n2];
              i4 = Math.min(i4, l2.x), o3 = Math.min(o3, l2.y), r3 = Math.max(r3, l2.x), a2 = Math.max(a2, l2.y);
            }
            var c3 = Math.max(r3 - i4, a2 - o3), u2 = Math.max(0, Math.floor(-Math.log(c3) / Math.LN2)), h3 = Math.pow(2, u2);
            return new t.CanonicalTileID(u2, Math.floor((i4 + r3) / 2 * h3), Math.floor((o3 + a2) / 2 * h3));
          }(o2), this.minzoom = this.maxzoom = this.tileID.z;
          var r2 = o2.map(function(t2) {
            return i3.tileID.getTilePoint(t2)._round();
          });
          return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r2[0].x, r2[0].y, 0, 0), this._boundsArray.emplaceBack(r2[1].x, r2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r2[3].x, r2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r2[2].x, r2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }, i2.prototype.prepare = function() {
          if (0 !== Object.keys(this.tiles).length && this.image) {
            var e3 = this.map.painter.context, i3 = e3.gl;
            for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
              var r2 = this.tiles[o2];
              "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
            }
          }
        }, i2.prototype.loadTile = function(t2, e3) {
          this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e3(null)) : (t2.state = "errored", e3(null));
        }, i2.prototype.serialize = function() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }, i2.prototype.hasTransition = function() {
          return false;
        }, i2;
      }(t.Evented), L = function(e2) {
        function i2(t2, i3, o2, r2) {
          e2.call(this, t2, i3, o2, r2), this.roundZoom = true, this.type = "video", this.options = i3;
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
          var e3 = this;
          this._loaded = false;
          var i3 = this.options;
          this.urls = [];
          for (var o2 = 0, r2 = i3.urls; o2 < r2.length; o2 += 1)
            this.urls.push(this.map._requestManager.transformRequest(r2[o2], t.ResourceType.Source).url);
          t.getVideo(this.urls, function(i4, o3) {
            e3._loaded = true, i4 ? e3.fire(new t.ErrorEvent(i4)) : o3 && (e3.video = o3, e3.video.loop = true, e3.video.setAttribute("playsinline", ""), e3.video.addEventListener("playing", function() {
              e3.map.triggerRepaint();
            }), e3.map && e3.video.play(), e3._finishLoading());
          });
        }, i2.prototype.pause = function() {
          this.video && this.video.pause();
        }, i2.prototype.play = function() {
          this.video && this.video.play();
        }, i2.prototype.seek = function(e3) {
          if (this.video) {
            var i3 = this.video.seekable;
            e3 < i3.start(0) || e3 > i3.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i3.start(0) + " and " + i3.end(0) + "-second mark."))) : this.video.currentTime = e3;
          }
        }, i2.prototype.getVideo = function() {
          return this.video;
        }, i2.prototype.onAdd = function(t2) {
          this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }, i2.prototype.prepare = function() {
          if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {
            var e3 = this.map.painter.context, i3 = e3.gl;
            for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
              var r2 = this.tiles[o2];
              "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
            }
          }
        }, i2.prototype.serialize = function() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }, i2.prototype.hasTransition = function() {
          return this.video && !this.video.paused;
        }, i2;
      }(M), R = function(e2) {
        function i2(i3, o2, r2, a2) {
          e2.call(this, i3, o2, r2, a2), o2.coordinates ? Array.isArray(o2.coordinates) && 4 === o2.coordinates.length && !o2.coordinates.some(function(t2) {
            return !Array.isArray(t2) || 2 !== t2.length || t2.some(function(t3) {
              return "number" != typeof t3;
            });
          }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "coordinates"'))), o2.animate && "boolean" != typeof o2.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'optional "animate" property must be a boolean value'))), o2.canvas ? "string" == typeof o2.canvas || o2.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "canvas"'))), this.options = o2, this.animate = void 0 === o2.animate || o2.animate;
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }, i2.prototype.getCanvas = function() {
          return this.canvas;
        }, i2.prototype.onAdd = function(t2) {
          this.map = t2, this.load(), this.canvas && this.animate && this.play();
        }, i2.prototype.onRemove = function() {
          this.pause();
        }, i2.prototype.prepare = function() {
          var e3 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {
            var i3 = this.map.painter.context, o2 = i3.gl;
            for (var r2 in this.boundsBuffer || (this.boundsBuffer = i3.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.Texture(i3, this.canvas, o2.RGBA, { premultiply: true }), this.tiles) {
              var a2 = this.tiles[r2];
              "loaded" !== a2.state && (a2.state = "loaded", a2.texture = this.texture);
            }
          }
        }, i2.prototype.serialize = function() {
          return { type: "canvas", coordinates: this.coordinates };
        }, i2.prototype.hasTransition = function() {
          return this._playing;
        }, i2.prototype._hasInvalidDimensions = function() {
          for (var t2 = 0, e3 = [this.canvas.width, this.canvas.height]; t2 < e3.length; t2 += 1) {
            var i3 = e3[t2];
            if (isNaN(i3) || i3 <= 0)
              return true;
          }
          return false;
        }, i2;
      }(M), k = { vector: S, raster: C, "raster-dem": z, geojson: D, video: L, image: M, canvas: R };
      function B(e2, i2) {
        var o2 = t.identity([]);
        return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i2.toUnwrapped()));
      }
      function O2(t2, e2, i2, o2, r2, a2) {
        var n2 = function(t3, e3, i3) {
          if (t3)
            for (var o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
              var a3 = e3[r3[o3]];
              if (a3 && a3.source === i3 && "fill-extrusion" === a3.type)
                return true;
            }
          else
            for (var n3 in e3) {
              var s3 = e3[n3];
              if (s3.source === i3 && "fill-extrusion" === s3.type)
                return true;
            }
          return false;
        }(r2 && r2.layers, e2, t2.id), s2 = a2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, s2, n2);
        l2.sort(F);
        for (var c3 = [], u2 = 0, h3 = l2; u2 < h3.length; u2 += 1) {
          var p3 = h3[u2];
          c3.push({ wrappedTileID: p3.tileID.wrapped().key, queryResults: p3.tile.queryRenderedFeatures(e2, i2, t2._state, p3.queryGeometry, p3.cameraQueryGeometry, p3.scale, r2, a2, s2, B(t2.transform, p3.tileID)) });
        }
        var d2 = function(t3) {
          for (var e3 = {}, i3 = {}, o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
            var a3 = r3[o3], n3 = a3.queryResults, s3 = a3.wrappedTileID, l3 = i3[s3] = i3[s3] || {};
            for (var c4 in n3)
              for (var u3 = n3[c4], h4 = l3[c4] = l3[c4] || {}, p4 = e3[c4] = e3[c4] || [], d3 = 0, _25 = u3; d3 < _25.length; d3 += 1) {
                var f2 = _25[d3];
                h4[f2.featureIndex] || (h4[f2.featureIndex] = true, p4.push(f2));
              }
          }
          return e3;
        }(c3);
        for (var _24 in d2)
          d2[_24].forEach(function(e3) {
            var i3 = e3.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
            i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
          });
        return d2;
      }
      function F(t2, e2) {
        var i2 = t2.tileID, o2 = e2.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      var U = function(t2, e2) {
        this.max = t2, this.onRemove = e2, this.reset();
      };
      U.prototype.reset = function() {
        for (var t2 in this.data)
          for (var e2 = 0, i2 = this.data[t2]; e2 < i2.length; e2 += 1) {
            var o2 = i2[e2];
            o2.timeout && clearTimeout(o2.timeout), this.onRemove(o2.value);
          }
        return this.data = {}, this.order = [], this;
      }, U.prototype.add = function(t2, e2, i2) {
        var o2 = this, r2 = t2.wrapped().key;
        void 0 === this.data[r2] && (this.data[r2] = []);
        var a2 = { value: e2, timeout: void 0 };
        if (void 0 !== i2 && (a2.timeout = setTimeout(function() {
          o2.remove(t2, a2);
        }, i2)), this.data[r2].push(a2), this.order.push(r2), this.order.length > this.max) {
          var n2 = this._getAndRemoveByKey(this.order[0]);
          n2 && this.onRemove(n2);
        }
        return this;
      }, U.prototype.has = function(t2) {
        return t2.wrapped().key in this.data;
      }, U.prototype.getAndRemove = function(t2) {
        return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
      }, U.prototype._getAndRemoveByKey = function(t2) {
        var e2 = this.data[t2].shift();
        return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
      }, U.prototype.getByKey = function(t2) {
        var e2 = this.data[t2];
        return e2 ? e2[0].value : null;
      }, U.prototype.get = function(t2) {
        return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
      }, U.prototype.remove = function(t2, e2) {
        if (!this.has(t2))
          return this;
        var i2 = t2.wrapped().key, o2 = void 0 === e2 ? 0 : this.data[i2].indexOf(e2), r2 = this.data[i2][o2];
        return this.data[i2].splice(o2, 1), r2.timeout && clearTimeout(r2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(r2.value), this.order.splice(this.order.indexOf(i2), 1), this;
      }, U.prototype.setMaxSize = function(t2) {
        for (this.max = t2; this.order.length > this.max; ) {
          var e2 = this._getAndRemoveByKey(this.order[0]);
          e2 && this.onRemove(e2);
        }
        return this;
      }, U.prototype.filter = function(t2) {
        var e2 = [];
        for (var i2 in this.data)
          for (var o2 = 0, r2 = this.data[i2]; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2];
            t2(a2.value) || e2.push(a2);
          }
        for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
          var l2 = s2[n2];
          this.remove(l2.value.tileID, l2);
        }
      };
      var N = function(t2, e2, i2) {
        this.context = t2;
        var o2 = t2.gl;
        this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
      };
      N.prototype.bind = function() {
        this.context.bindElementBuffer.set(this.buffer);
      }, N.prototype.updateData = function(t2) {
        var e2 = this.context.gl;
        this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
      }, N.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var Z2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, q = function(t2, e2, i2, o2) {
        this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
        var r2 = t2.gl;
        this.buffer = r2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
      };
      q.prototype.bind = function() {
        this.context.bindVertexBuffer.set(this.buffer);
      }, q.prototype.updateData = function(t2) {
        var e2 = this.context.gl;
        this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
      }, q.prototype.enableAttributes = function(t2, e2) {
        for (var i2 = 0; i2 < this.attributes.length; i2++) {
          var o2 = e2.attributes[this.attributes[i2].name];
          void 0 !== o2 && t2.enableVertexAttribArray(o2);
        }
      }, q.prototype.setVertexAttribPointers = function(t2, e2, i2) {
        for (var o2 = 0; o2 < this.attributes.length; o2++) {
          var r2 = this.attributes[o2], a2 = e2.attributes[r2.name];
          void 0 !== a2 && t2.vertexAttribPointer(a2, r2.components, t2[Z2[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
        }
      }, q.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var j = function(t2) {
        this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
      };
      j.prototype.get = function() {
        return this.current;
      }, j.prototype.set = function(t2) {
      }, j.prototype.getDefault = function() {
        return this.default;
      }, j.prototype.setDefault = function() {
        this.set(this.default);
      };
      var V2 = function(e2) {
        function i2() {
          e2.apply(this, arguments);
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getDefault = function() {
          return t.Color.transparent;
        }, i2.prototype.set = function(t2) {
          var e3 = this.current;
          (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }, i2;
      }(j), G = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return 1;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), W = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return 0;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), X = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return [true, true, true, true];
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
        }, e2;
      }(j), H = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return true;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), K = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return 255;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), Y = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3.func !== e3.func || t3.ref !== e3.ref || t3.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
        }, e2;
      }(j), J = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          var t3 = this.gl;
          return [t3.KEEP, t3.KEEP, t3.KEEP];
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
        }, e2;
      }(j), Q = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            t3 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), $ = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return [0, 1];
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
        }, e2;
      }(j), tt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            t3 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), et = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return this.gl.LESS;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), it = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            t3 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), ot = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          var t3 = this.gl;
          return [t3.ONE, t3.ZERO];
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
        }, e2;
      }(j), rt = function(e2) {
        function i2() {
          e2.apply(this, arguments);
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getDefault = function() {
          return t.Color.transparent;
        }, i2.prototype.set = function(t2) {
          var e3 = this.current;
          (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }, i2;
      }(j), at = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return this.gl.FUNC_ADD;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), nt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            t3 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), st = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return this.gl.BACK;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), lt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return this.gl.CCW;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), ct = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), ut = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return this.gl.TEXTURE0;
        }, e2.prototype.set = function(t3) {
          (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), ht = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          var t3 = this.gl;
          return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
        }, e2.prototype.set = function(t3) {
          var e3 = this.current;
          (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
        }, e2;
      }(j), pt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.bindFramebuffer(e3.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), dt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.bindRenderbuffer(e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), _t = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.bindTexture(e3.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), ft = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.bindBuffer(e3.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), mt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          var e3 = this.gl;
          e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
        }, e2;
      }(j), gt = function(t2) {
        function e2(e3) {
          t2.call(this, e3), this.vao = e3.extVertexArrayObject;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2.prototype.set = function(t3) {
          this.vao && (t3 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t3), this.current = t3, this.dirty = false);
        }, e2;
      }(j), vt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return 4;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), yt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), xt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return false;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            var e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(j), bt = function(t2) {
        function e2(e3, i2) {
          t2.call(this, e3), this.context = e3, this.parent = i2;
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
          return null;
        }, e2;
      }(j), wt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.setDirty = function() {
          this.dirty = true;
        }, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var e3 = this.gl;
            e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(bt), Tt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
          if (t3 !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var e3 = this.gl;
            e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }, e2;
      }(bt), Et = function(t2, e2, i2, o2) {
        this.context = t2, this.width = e2, this.height = i2;
        var r2 = this.framebuffer = t2.gl.createFramebuffer();
        this.colorAttachment = new wt(t2, r2), o2 && (this.depthAttachment = new Tt(t2, r2));
      };
      Et.prototype.destroy = function() {
        var t2 = this.context.gl, e2 = this.colorAttachment.get();
        if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
          var i2 = this.depthAttachment.get();
          i2 && t2.deleteRenderbuffer(i2);
        }
        t2.deleteFramebuffer(this.framebuffer);
      };
      var It = function(t2, e2, i2) {
        this.func = t2, this.mask = e2, this.range = i2;
      };
      It.ReadOnly = false, It.ReadWrite = true, It.disabled = new It(519, It.ReadOnly, [0, 1]);
      var Pt = function(t2, e2, i2, o2, r2, a2) {
        this.test = t2, this.ref = e2, this.mask = i2, this.fail = o2, this.depthFail = r2, this.pass = a2;
      };
      Pt.disabled = new Pt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
      var St = function(t2, e2, i2) {
        this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
      };
      St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [false, false, false, false]), St.unblended = new St(St.Replace, t.Color.transparent, [true, true, true, true]), St.alphaBlended = new St([1, 771], t.Color.transparent, [true, true, true, true]);
      var Ct = function(t2, e2, i2) {
        this.enable = t2, this.mode = e2, this.frontFace = i2;
      };
      Ct.disabled = new Ct(false, 1029, 2305), Ct.backCCW = new Ct(true, 1029, 2305);
      var zt = function(t2) {
        this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V2(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
      };
      zt.prototype.setDefault = function() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }, zt.prototype.setDirty = function() {
        this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
      }, zt.prototype.createIndexBuffer = function(t2, e2) {
        return new N(this, t2, e2);
      }, zt.prototype.createVertexBuffer = function(t2, e2, i2) {
        return new q(this, t2, e2, i2);
      }, zt.prototype.createRenderbuffer = function(t2, e2, i2) {
        var o2 = this.gl, r2 = o2.createRenderbuffer();
        return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), r2;
      }, zt.prototype.createFramebuffer = function(t2, e2, i2) {
        return new Et(this, t2, e2, i2);
      }, zt.prototype.clear = function(t2) {
        var e2 = t2.color, i2 = t2.depth, o2 = this.gl, r2 = 0;
        e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== i2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i2), this.depthMask.set(true)), o2.clear(r2);
      }, zt.prototype.setCullFace = function(t2) {
        false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
      }, zt.prototype.setDepthMode = function(t2) {
        t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
      }, zt.prototype.setStencilMode = function(t2) {
        t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
      }, zt.prototype.setColorMode = function(e2) {
        t.deepEqual(e2.blendFunction, St.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
      }, zt.prototype.unbindVAO = function() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      };
      var Dt = function(e2) {
        function i2(i3, o2, r2) {
          var a2 = this;
          e2.call(this), this.id = i3, this.dispatcher = r2, this.on("data", function(t2) {
            "source" === t2.dataType && "metadata" === t2.sourceDataType && (a2._sourceLoaded = true), a2._sourceLoaded && !a2._paused && "source" === t2.dataType && "content" === t2.sourceDataType && (a2.reload(), a2.transform && a2.update(a2.transform));
          }), this.on("error", function() {
            a2._sourceErrored = true;
          }), this._source = function(e3, i4, o3, r3) {
            var a3 = new k[i4.type](e3, i4, o3, r3);
            if (a3.id !== e3)
              throw new Error("Expected Source id to be " + e3 + " instead of " + a3.id);
            return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a3), a3;
          }(i3, o2, r2, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.onAdd = function(t2) {
          this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
        }, i2.prototype.onRemove = function(t2) {
          this._source && this._source.onRemove && this._source.onRemove(t2);
        }, i2.prototype.loaded = function() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (var t2 in this._tiles) {
            var e3 = this._tiles[t2];
            if ("loaded" !== e3.state && "errored" !== e3.state)
              return false;
          }
          return true;
        }, i2.prototype.getSource = function() {
          return this._source;
        }, i2.prototype.pause = function() {
          this._paused = true;
        }, i2.prototype.resume = function() {
          if (this._paused) {
            var t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
          }
        }, i2.prototype._loadTile = function(t2, e3) {
          return this._source.loadTile(t2, e3);
        }, i2.prototype._unloadTile = function(t2) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t2, function() {
            });
        }, i2.prototype._abortTile = function(t2) {
          if (this._source.abortTile)
            return this._source.abortTile(t2, function() {
            });
        }, i2.prototype.serialize = function() {
          return this._source.serialize();
        }, i2.prototype.prepare = function(t2) {
          for (var e3 in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            var i3 = this._tiles[e3];
            i3.upload(t2), i3.prepare(this.map.style.imageManager);
          }
        }, i2.prototype.getIds = function() {
          return t.values(this._tiles).map(function(t2) {
            return t2.tileID;
          }).sort(At).map(function(t2) {
            return t2.key;
          });
        }, i2.prototype.getRenderableIds = function(e3) {
          var i3 = this, o2 = [];
          for (var r2 in this._tiles)
            this._isIdRenderable(r2, e3) && o2.push(this._tiles[r2]);
          return e3 ? o2.sort(function(e4, o3) {
            var r3 = e4.tileID, a2 = o3.tileID, n2 = new t.Point(r3.canonical.x, r3.canonical.y)._rotate(i3.transform.angle), s2 = new t.Point(a2.canonical.x, a2.canonical.y)._rotate(i3.transform.angle);
            return r3.overscaledZ - a2.overscaledZ || s2.y - n2.y || s2.x - n2.x;
          }).map(function(t2) {
            return t2.tileID.key;
          }) : o2.map(function(t2) {
            return t2.tileID;
          }).sort(At).map(function(t2) {
            return t2.key;
          });
        }, i2.prototype.hasRenderableParent = function(t2) {
          var e3 = this.findLoadedParent(t2, 0);
          return !!e3 && this._isIdRenderable(e3.tileID.key);
        }, i2.prototype._isIdRenderable = function(t2, e3) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e3 || !this._tiles[t2].holdingForFade());
        }, i2.prototype.reload = function() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else
            for (var t2 in this._cache.reset(), this._tiles)
              "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
        }, i2.prototype._reloadTile = function(t2, e3) {
          var i3 = this._tiles[t2];
          i3 && ("loading" !== i3.state && (i3.state = e3), this._loadTile(i3, this._tileLoaded.bind(this, i3, t2, e3)));
        }, i2.prototype._tileLoaded = function(e3, i3, o2, r2) {
          if (r2)
            return e3.state = "errored", void (404 !== r2.status ? this._source.fire(new t.ErrorEvent(r2, { tile: e3 })) : this.update(this.transform));
          e3.timeAdded = t.browser.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
        }, i2.prototype._backfillDEM = function(t2) {
          for (var e3 = this.getRenderableIds(), i3 = 0; i3 < e3.length; i3++) {
            var o2 = e3[i3];
            if (t2.neighboringTiles && t2.neighboringTiles[o2]) {
              var r2 = this.getTileByID(o2);
              a2(t2, r2), a2(r2, t2);
            }
          }
          function a2(t3, e4) {
            t3.needsHillshadePrepare = true;
            var i4 = e4.tileID.canonical.x - t3.tileID.canonical.x, o3 = e4.tileID.canonical.y - t3.tileID.canonical.y, r3 = Math.pow(2, t3.tileID.canonical.z), a3 = e4.tileID.key;
            0 === i4 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + r3) ? i4 += r3 : 1 === Math.abs(i4 - r3) && (i4 -= r3)), e4.dem && t3.dem && (t3.dem.backfillBorder(e4.dem, i4, o3), t3.neighboringTiles && t3.neighboringTiles[a3] && (t3.neighboringTiles[a3].backfilled = true)));
          }
        }, i2.prototype.getTile = function(t2) {
          return this.getTileByID(t2.key);
        }, i2.prototype.getTileByID = function(t2) {
          return this._tiles[t2];
        }, i2.prototype._retainLoadedChildren = function(t2, e3, i3, o2) {
          for (var r2 in this._tiles) {
            var a2 = this._tiles[r2];
            if (!(o2[r2] || !a2.hasData() || a2.tileID.overscaledZ <= e3 || a2.tileID.overscaledZ > i3)) {
              for (var n2 = a2.tileID; a2 && a2.tileID.overscaledZ > e3 + 1; ) {
                var s2 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
                (a2 = this._tiles[s2.key]) && a2.hasData() && (n2 = s2);
              }
              for (var l2 = n2; l2.overscaledZ > e3; )
                if (t2[(l2 = l2.scaledTo(l2.overscaledZ - 1)).key]) {
                  o2[n2.key] = n2;
                  break;
                }
            }
          }
        }, i2.prototype.findLoadedParent = function(t2, e3) {
          if (t2.key in this._loadedParentTiles) {
            var i3 = this._loadedParentTiles[t2.key];
            return i3 && i3.tileID.overscaledZ >= e3 ? i3 : null;
          }
          for (var o2 = t2.overscaledZ - 1; o2 >= e3; o2--) {
            var r2 = t2.scaledTo(o2), a2 = this._getLoadedTile(r2);
            if (a2)
              return a2;
          }
        }, i2.prototype._getLoadedTile = function(t2) {
          var e3 = this._tiles[t2.key];
          return e3 && e3.hasData() ? e3 : this._cache.getByKey(t2.wrapped().key);
        }, i2.prototype.updateCacheSize = function(t2) {
          var e3 = Math.ceil(t2.width / this._source.tileSize) + 1, i3 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e3 * i3 * 5), r2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
          this._cache.setMaxSize(r2);
        }, i2.prototype.handleWrapJump = function(t2) {
          var e3 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e3) {
            var i3 = {};
            for (var o2 in this._tiles) {
              var r2 = this._tiles[o2];
              r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + e3), i3[r2.tileID.key] = r2;
            }
            for (var a2 in this._tiles = i3, this._timers)
              clearTimeout(this._timers[a2]), delete this._timers[a2];
            for (var n2 in this._tiles)
              this._setTileReloadTimer(n2, this._tiles[n2]);
          }
        }, i2.prototype.update = function(e3) {
          var o2 = this;
          if (this.transform = e3, this._sourceLoaded && !this._paused) {
            var r2;
            this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(e4) {
              return new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y);
            }) : (r2 = e3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (r2 = r2.filter(function(t2) {
              return o2._source.hasTile(t2);
            }))) : r2 = [];
            var a2 = e3.coveringZoomLevel(this._source), n2 = Math.max(a2 - i2.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + i2.maxUnderzooming, this._source.minzoom), l2 = this._updateRetainedTiles(r2, a2);
            if (Mt(this._source.type)) {
              for (var c3 = {}, u2 = {}, h3 = 0, p3 = Object.keys(l2); h3 < p3.length; h3 += 1) {
                var d2 = p3[h3], _24 = l2[d2], f2 = this._tiles[d2];
                if (f2 && !(f2.fadeEndTime && f2.fadeEndTime <= t.browser.now())) {
                  var m2 = this.findLoadedParent(_24, n2);
                  m2 && (this._addTile(m2.tileID), c3[m2.tileID.key] = m2.tileID), u2[d2] = _24;
                }
              }
              for (var g2 in this._retainLoadedChildren(u2, a2, s2, l2), c3)
                l2[g2] || (this._coveredTiles[g2] = true, l2[g2] = c3[g2]);
            }
            for (var v3 in l2)
              this._tiles[v3].clearFadeHold();
            for (var y3 = 0, x2 = t.keysDifference(this._tiles, l2); y3 < x2.length; y3 += 1) {
              var b2 = x2[y3], w2 = this._tiles[b2];
              w2.hasSymbolBuckets && !w2.holdingForFade() ? w2.setHoldDuration(this.map._fadeDuration) : w2.hasSymbolBuckets && !w2.symbolFadeFinished() || this._removeTile(b2);
            }
            this._updateLoadedParentTileCache();
          }
        }, i2.prototype.releaseSymbolFadeTiles = function() {
          for (var t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(t2);
        }, i2.prototype._updateRetainedTiles = function(t2, e3) {
          for (var o2 = {}, r2 = {}, a2 = Math.max(e3 - i2.maxOverzooming, this._source.minzoom), n2 = Math.max(e3 + i2.maxUnderzooming, this._source.minzoom), s2 = {}, l2 = 0, c3 = t2; l2 < c3.length; l2 += 1) {
            var u2 = c3[l2], h3 = this._addTile(u2);
            o2[u2.key] = u2, h3.hasData() || e3 < this._source.maxzoom && (s2[u2.key] = u2);
          }
          this._retainLoadedChildren(s2, e3, n2, o2);
          for (var p3 = 0, d2 = t2; p3 < d2.length; p3 += 1) {
            var _24 = d2[p3], f2 = this._tiles[_24.key];
            if (!f2.hasData()) {
              if (e3 + 1 > this._source.maxzoom) {
                var m2 = _24.children(this._source.maxzoom)[0], g2 = this.getTile(m2);
                if (g2 && g2.hasData()) {
                  o2[m2.key] = m2;
                  continue;
                }
              } else {
                var v3 = _24.children(this._source.maxzoom);
                if (o2[v3[0].key] && o2[v3[1].key] && o2[v3[2].key] && o2[v3[3].key])
                  continue;
              }
              for (var y3 = f2.wasRequested(), x2 = _24.overscaledZ - 1; x2 >= a2; --x2) {
                var b2 = _24.scaledTo(x2);
                if (r2[b2.key])
                  break;
                if (r2[b2.key] = true, !(f2 = this.getTile(b2)) && y3 && (f2 = this._addTile(b2)), f2 && (o2[b2.key] = b2, y3 = f2.wasRequested(), f2.hasData()))
                  break;
              }
            }
          }
          return o2;
        }, i2.prototype._updateLoadedParentTileCache = function() {
          for (var t2 in this._loadedParentTiles = {}, this._tiles) {
            for (var e3 = [], i3 = void 0, o2 = this._tiles[t2].tileID; o2.overscaledZ > 0; ) {
              if (o2.key in this._loadedParentTiles) {
                i3 = this._loadedParentTiles[o2.key];
                break;
              }
              e3.push(o2.key);
              var r2 = o2.scaledTo(o2.overscaledZ - 1);
              if (i3 = this._getLoadedTile(r2))
                break;
              o2 = r2;
            }
            for (var a2 = 0, n2 = e3; a2 < n2.length; a2 += 1)
              this._loadedParentTiles[n2[a2]] = i3;
          }
        }, i2.prototype._addTile = function(e3) {
          var i3 = this._tiles[e3.key];
          if (i3)
            return i3;
          (i3 = this._cache.getAndRemove(e3)) && (this._setTileReloadTimer(e3.key, i3), i3.tileID = e3, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i3)));
          var o2 = Boolean(i3);
          return o2 || (i3 = new t.Tile(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e3.key, i3.state))), i3 ? (i3.uses++, this._tiles[e3.key] = i3, o2 || this._source.fire(new t.Event("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3) : null;
        }, i2.prototype._setTileReloadTimer = function(t2, e3) {
          var i3 = this;
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          var o2 = e3.getExpiryTimeout();
          o2 && (this._timers[t2] = setTimeout(function() {
            i3._reloadTile(t2, "expired"), delete i3._timers[t2];
          }, o2));
        }, i2.prototype._removeTile = function(t2) {
          var e3 = this._tiles[t2];
          e3 && (e3.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
        }, i2.prototype.clearTiles = function() {
          for (var t2 in this._shouldReloadOnResume = false, this._paused = false, this._tiles)
            this._removeTile(t2);
          this._cache.reset();
        }, i2.prototype.tilesIn = function(e3, i3, o2) {
          var r2 = this, a2 = [], n2 = this.transform;
          if (!n2)
            return a2;
          for (var s2 = o2 ? n2.getCameraQueryGeometry(e3) : e3, l2 = e3.map(function(t2) {
            return n2.pointCoordinate(t2);
          }), c3 = s2.map(function(t2) {
            return n2.pointCoordinate(t2);
          }), u2 = this.getIds(), h3 = 1 / 0, p3 = 1 / 0, d2 = -1 / 0, _24 = -1 / 0, f2 = 0, m2 = c3; f2 < m2.length; f2 += 1) {
            var g2 = m2[f2];
            h3 = Math.min(h3, g2.x), p3 = Math.min(p3, g2.y), d2 = Math.max(d2, g2.x), _24 = Math.max(_24, g2.y);
          }
          for (var v3 = function(e4) {
            var o3 = r2._tiles[u2[e4]];
            if (!o3.holdingForFade()) {
              var s3 = o3.tileID, f3 = Math.pow(2, n2.zoom - o3.tileID.overscaledZ), m3 = i3 * o3.queryPadding * t.EXTENT / o3.tileSize / f3, g3 = [s3.getTilePoint(new t.MercatorCoordinate(h3, p3)), s3.getTilePoint(new t.MercatorCoordinate(d2, _24))];
              if (g3[0].x - m3 < t.EXTENT && g3[0].y - m3 < t.EXTENT && g3[1].x + m3 >= 0 && g3[1].y + m3 >= 0) {
                var v4 = l2.map(function(t2) {
                  return s3.getTilePoint(t2);
                }), y4 = c3.map(function(t2) {
                  return s3.getTilePoint(t2);
                });
                a2.push({ tile: o3, tileID: s3, queryGeometry: v4, cameraQueryGeometry: y4, scale: f3 });
              }
            }
          }, y3 = 0; y3 < u2.length; y3++)
            v3(y3);
          return a2;
        }, i2.prototype.getVisibleCoordinates = function(t2) {
          for (var e3 = this, i3 = this.getRenderableIds(t2).map(function(t3) {
            return e3._tiles[t3].tileID;
          }), o2 = 0, r2 = i3; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2];
            a2.posMatrix = this.transform.calculatePosMatrix(a2.toUnwrapped());
          }
          return i3;
        }, i2.prototype.hasTransition = function() {
          if (this._source.hasTransition())
            return true;
          if (Mt(this._source.type))
            for (var e3 in this._tiles) {
              var i3 = this._tiles[e3];
              if (void 0 !== i3.fadeEndTime && i3.fadeEndTime >= t.browser.now())
                return true;
            }
          return false;
        }, i2.prototype.setFeatureState = function(t2, e3, i3) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e3, i3);
        }, i2.prototype.removeFeatureState = function(t2, e3, i3) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e3, i3);
        }, i2.prototype.getFeatureState = function(t2, e3) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e3);
        }, i2.prototype.setDependencies = function(t2, e3, i3) {
          var o2 = this._tiles[t2];
          o2 && o2.setDependencies(e3, i3);
        }, i2.prototype.reloadTilesForDependencies = function(t2, e3) {
          for (var i3 in this._tiles)
            this._tiles[i3].hasDependency(t2, e3) && this._reloadTile(i3, "reloading");
          this._cache.filter(function(i4) {
            return !i4.hasDependency(t2, e3);
          });
        }, i2;
      }(t.Evented);
      function At(t2, e2) {
        var i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t2.overscaledZ - e2.overscaledZ || o2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
      }
      function Mt(t2) {
        return "raster" === t2 || "image" === t2 || "video" === t2;
      }
      function Lt() {
        return new t.window.Worker(Kr.workerUrl);
      }
      Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;
      var Rt = "mapboxgl_preloaded_worker_pool", kt = function() {
        this.active = {};
      };
      kt.prototype.acquire = function(t2) {
        if (!this.workers)
          for (this.workers = []; this.workers.length < kt.workerCount; )
            this.workers.push(new Lt());
        return this.active[t2] = true, this.workers.slice();
      }, kt.prototype.release = function(t2) {
        delete this.active[t2], 0 === this.numActive() && (this.workers.forEach(function(t3) {
          t3.terminate();
        }), this.workers = null);
      }, kt.prototype.isPreloaded = function() {
        return !!this.active[Rt];
      }, kt.prototype.numActive = function() {
        return Object.keys(this.active).length;
      };
      var Bt, Ot = Math.floor(t.browser.hardwareConcurrency / 2);
      function Ft() {
        return Bt || (Bt = new kt()), Bt;
      }
      function Ut(e2, i2) {
        var o2 = {};
        for (var r2 in e2)
          "ref" !== r2 && (o2[r2] = e2[r2]);
        return t.refProperties.forEach(function(t2) {
          t2 in i2 && (o2[t2] = i2[t2]);
        }), o2;
      }
      function Nt(t2) {
        t2 = t2.slice();
        for (var e2 = /* @__PURE__ */ Object.create(null), i2 = 0; i2 < t2.length; i2++)
          e2[t2[i2].id] = t2[i2];
        for (var o2 = 0; o2 < t2.length; o2++)
          "ref" in t2[o2] && (t2[o2] = Ut(t2[o2], e2[t2[o2].ref]));
        return t2;
      }
      kt.workerCount = Math.max(Math.min(Ot, 6), 1);
      var Zt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function qt(t2, e2, i2) {
        i2.push({ command: Zt.addSource, args: [t2, e2[t2]] });
      }
      function jt(t2, e2, i2) {
        e2.push({ command: Zt.removeSource, args: [t2] }), i2[t2] = true;
      }
      function Vt(t2, e2, i2, o2) {
        jt(t2, i2, o2), qt(t2, e2, i2);
      }
      function Gt(e2, i2, o2) {
        var r2;
        for (r2 in e2[o2])
          if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
            return false;
        for (r2 in i2[o2])
          if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
            return false;
        return true;
      }
      function Wt(e2, i2, o2, r2, a2, n2) {
        var s2;
        for (s2 in i2 = i2 || {}, e2 = e2 || {})
          e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
        for (s2 in i2)
          i2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
      }
      function Xt(t2) {
        return t2.id;
      }
      function Ht(t2, e2) {
        return t2[e2.id] = e2, t2;
      }
      var Kt = function(t2, e2) {
        this.reset(t2, e2);
      };
      Kt.prototype.reset = function(t2, e2) {
        this.points = t2 || [], this._distances = [0];
        for (var i2 = 1; i2 < this.points.length; i2++)
          this._distances[i2] = this._distances[i2 - 1] + this.points[i2].dist(this.points[i2 - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }, Kt.prototype.lerp = function(e2) {
        if (1 === this.points.length)
          return this.points[0];
        e2 = t.clamp(e2, 0, 1);
        for (var i2 = 1, o2 = this._distances[i2], r2 = e2 * this.paddedLength + this.padding; o2 < r2 && i2 < this._distances.length; )
          o2 = this._distances[++i2];
        var a2 = i2 - 1, n2 = this._distances[a2], s2 = o2 - n2, l2 = s2 > 0 ? (r2 - n2) / s2 : 0;
        return this.points[a2].mult(1 - l2).add(this.points[i2].mult(l2));
      };
      var Yt = function(t2, e2, i2) {
        var o2 = this.boxCells = [], r2 = this.circleCells = [];
        this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
        for (var a2 = 0; a2 < this.xCellCount * this.yCellCount; a2++)
          o2.push([]), r2.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
      };
      function Jt(e2, i2, o2, r2, a2) {
        var n2 = t.create();
        return i2 ? (t.scale(n2, n2, [1 / a2, 1 / a2, 1]), o2 || t.rotateZ(n2, n2, r2.angle)) : t.multiply(n2, r2.labelPlaneMatrix, e2), n2;
      }
      function Qt(e2, i2, o2, r2, a2) {
        if (i2) {
          var n2 = t.clone(e2);
          return t.scale(n2, n2, [a2, a2, 1]), o2 || t.rotateZ(n2, n2, -r2.angle), n2;
        }
        return r2.glCoordMatrix;
      }
      function $t(e2, i2) {
        var o2 = [e2.x, e2.y, 0, 1];
        ue(o2, o2, i2);
        var r2 = o2[3];
        return { point: new t.Point(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2 };
      }
      function te(t2, e2) {
        return 0.5 + t2 / e2 * 0.5;
      }
      function ee(t2, e2) {
        var i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
        return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
      }
      function ie(e2, i2, o2, r2, a2, n2, s2, l2) {
        var c3 = r2 ? e2.textSizeData : e2.iconSizeData, u2 = t.evaluateSizeForZoom(c3, o2.transform.zoom), h3 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], p3 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
        p3.clear();
        for (var d2 = e2.lineVertexArray, _24 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height, m2 = false, g2 = 0; g2 < _24.length; g2++) {
          var v3 = _24.get(g2);
          if (v3.hidden || v3.writingMode === t.WritingMode.vertical && !m2)
            ce(v3.numGlyphs, p3);
          else {
            m2 = false;
            var y3 = [v3.anchorX, v3.anchorY, 0, 1];
            if (t.transformMat4(y3, y3, i2), ee(y3, h3)) {
              var x2 = te(o2.transform.cameraToCenterDistance, y3[3]), b2 = t.evaluateSizeForFeature(c3, u2, v3), w2 = s2 ? b2 / x2 : b2 * x2, T2 = new t.Point(v3.anchorX, v3.anchorY), E2 = $t(T2, a2).point, I3 = {}, P2 = ae(v3, w2, false, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p3, E2, T2, I3, f2);
              m2 = P2.useVertical, (P2.notEnoughRoom || m2 || P2.needsFlipping && ae(v3, w2, true, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p3, E2, T2, I3, f2).notEnoughRoom) && ce(v3.numGlyphs, p3);
            } else
              ce(v3.numGlyphs, p3);
          }
        }
        r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(p3) : e2.icon.dynamicLayoutVertexBuffer.updateData(p3);
      }
      function oe(t2, e2, i2, o2, r2, a2, n2, s2, l2, c3, u2) {
        var h3 = s2.glyphStartIndex + s2.numGlyphs, p3 = s2.lineStartIndex, d2 = s2.lineStartIndex + s2.lineLength, _24 = e2.getoffsetX(s2.glyphStartIndex), f2 = e2.getoffsetX(h3 - 1), m2 = se(t2 * _24, i2, o2, r2, a2, n2, s2.segment, p3, d2, l2, c3, u2);
        if (!m2)
          return null;
        var g2 = se(t2 * f2, i2, o2, r2, a2, n2, s2.segment, p3, d2, l2, c3, u2);
        return g2 ? { first: m2, last: g2 } : null;
      }
      function re(e2, i2, o2, r2) {
        return e2 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r2 ? { useVertical: true } : (e2 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
      }
      function ae(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3, d2, _24) {
        var f2, m2 = i2 / 24, g2 = e2.lineOffsetX * m2, v3 = e2.lineOffsetY * m2;
        if (e2.numGlyphs > 1) {
          var y3 = e2.glyphStartIndex + e2.numGlyphs, x2 = e2.lineStartIndex, b2 = e2.lineStartIndex + e2.lineLength, w2 = oe(m2, l2, g2, v3, o2, h3, p3, e2, c3, n2, d2);
          if (!w2)
            return { notEnoughRoom: true };
          var T2 = $t(w2.first.point, s2).point, E2 = $t(w2.last.point, s2).point;
          if (r2 && !o2) {
            var I3 = re(e2.writingMode, T2, E2, _24);
            if (I3)
              return I3;
          }
          f2 = [w2.first];
          for (var P2 = e2.glyphStartIndex + 1; P2 < y3 - 1; P2++)
            f2.push(se(m2 * l2.getoffsetX(P2), g2, v3, o2, h3, p3, e2.segment, x2, b2, c3, n2, d2));
          f2.push(w2.last);
        } else {
          if (r2 && !o2) {
            var S2 = $t(p3, a2).point, C2 = e2.lineStartIndex + e2.segment + 1, z2 = new t.Point(c3.getx(C2), c3.gety(C2)), D2 = $t(z2, a2), A3 = D2.signedDistanceFromCamera > 0 ? D2.point : ne(p3, z2, S2, 1, a2), M2 = re(e2.writingMode, S2, A3, _24);
            if (M2)
              return M2;
          }
          var L2 = se(m2 * l2.getoffsetX(e2.glyphStartIndex), g2, v3, o2, h3, p3, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c3, n2, d2);
          if (!L2)
            return { notEnoughRoom: true };
          f2 = [L2];
        }
        for (var R2 = 0, k2 = f2; R2 < k2.length; R2 += 1) {
          var B2 = k2[R2];
          t.addDynamicAttributes(u2, B2.point, B2.angle);
        }
        return {};
      }
      function ne(t2, e2, i2, o2, r2) {
        var a2 = $t(t2.add(t2.sub(e2)._unit()), r2).point, n2 = i2.sub(a2);
        return i2.add(n2._mult(o2 / n2.mag()));
      }
      function se(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3) {
        var d2 = r2 ? e2 - i2 : e2 + i2, _24 = d2 > 0 ? 1 : -1, f2 = 0;
        r2 && (_24 *= -1, f2 = Math.PI), _24 < 0 && (f2 += Math.PI);
        for (var m2 = _24 > 0 ? l2 + s2 : l2 + s2 + 1, g2 = a2, v3 = a2, y3 = 0, x2 = 0, b2 = Math.abs(d2), w2 = []; y3 + x2 <= b2; ) {
          if ((m2 += _24) < l2 || m2 >= c3)
            return null;
          if (v3 = g2, w2.push(g2), void 0 === (g2 = p3[m2])) {
            var T2 = new t.Point(u2.getx(m2), u2.gety(m2)), E2 = $t(T2, h3);
            if (E2.signedDistanceFromCamera > 0)
              g2 = p3[m2] = E2.point;
            else {
              var I3 = m2 - _24;
              g2 = ne(0 === y3 ? n2 : new t.Point(u2.getx(I3), u2.gety(I3)), T2, v3, b2 - y3 + 1, h3);
            }
          }
          y3 += x2, x2 = v3.dist(g2);
        }
        var P2 = (b2 - y3) / x2, S2 = g2.sub(v3), C2 = S2.mult(P2)._add(v3);
        C2._add(S2._unit()._perp()._mult(o2 * _24));
        var z2 = f2 + Math.atan2(g2.y - v3.y, g2.x - v3.x);
        return w2.push(C2), { point: C2, angle: z2, path: w2 };
      }
      Yt.prototype.keysLength = function() {
        return this.boxKeys.length + this.circleKeys.length;
      }, Yt.prototype.insert = function(t2, e2, i2, o2, r2) {
        this._forEachCell(e2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
      }, Yt.prototype.insertCircle = function(t2, e2, i2, o2) {
        this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
      }, Yt.prototype._insertBoxCell = function(t2, e2, i2, o2, r2, a2) {
        this.boxCells[r2].push(a2);
      }, Yt.prototype._insertCircleCell = function(t2, e2, i2, o2, r2, a2) {
        this.circleCells[r2].push(a2);
      }, Yt.prototype._query = function(t2, e2, i2, o2, r2, a2) {
        if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
          return !r2 && [];
        var n2 = [];
        if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
          if (r2)
            return true;
          for (var s2 = 0; s2 < this.boxKeys.length; s2++)
            n2.push({ key: this.boxKeys[s2], x1: this.bboxes[4 * s2], y1: this.bboxes[4 * s2 + 1], x2: this.bboxes[4 * s2 + 2], y2: this.bboxes[4 * s2 + 3] });
          for (var l2 = 0; l2 < this.circleKeys.length; l2++) {
            var c3 = this.circles[3 * l2], u2 = this.circles[3 * l2 + 1], h3 = this.circles[3 * l2 + 2];
            n2.push({ key: this.circleKeys[l2], x1: c3 - h3, y1: u2 - h3, x2: c3 + h3, y2: u2 + h3 });
          }
          return a2 ? n2.filter(a2) : n2;
        }
        return this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, a2), r2 ? n2.length > 0 : n2;
      }, Yt.prototype._queryCircle = function(t2, e2, i2, o2, r2) {
        var a2 = t2 - i2, n2 = t2 + i2, s2 = e2 - i2, l2 = e2 + i2;
        if (n2 < 0 || a2 > this.width || l2 < 0 || s2 > this.height)
          return !o2 && [];
        var c3 = [];
        return this._forEachCell(a2, s2, n2, l2, this._queryCellCircle, c3, { hitTest: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c3.length > 0 : c3;
      }, Yt.prototype.query = function(t2, e2, i2, o2, r2) {
        return this._query(t2, e2, i2, o2, false, r2);
      }, Yt.prototype.hitTest = function(t2, e2, i2, o2, r2) {
        return this._query(t2, e2, i2, o2, true, r2);
      }, Yt.prototype.hitTestCircle = function(t2, e2, i2, o2) {
        return this._queryCircle(t2, e2, i2, true, o2);
      }, Yt.prototype._queryCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
        var l2 = n2.seenUids, c3 = this.boxCells[r2];
        if (null !== c3)
          for (var u2 = this.bboxes, h3 = 0, p3 = c3; h3 < p3.length; h3 += 1) {
            var d2 = p3[h3];
            if (!l2.box[d2]) {
              l2.box[d2] = true;
              var _24 = 4 * d2;
              if (t2 <= u2[_24 + 2] && e2 <= u2[_24 + 3] && i2 >= u2[_24 + 0] && o2 >= u2[_24 + 1] && (!s2 || s2(this.boxKeys[d2]))) {
                if (n2.hitTest)
                  return a2.push(true), true;
                a2.push({ key: this.boxKeys[d2], x1: u2[_24], y1: u2[_24 + 1], x2: u2[_24 + 2], y2: u2[_24 + 3] });
              }
            }
          }
        var f2 = this.circleCells[r2];
        if (null !== f2)
          for (var m2 = this.circles, g2 = 0, v3 = f2; g2 < v3.length; g2 += 1) {
            var y3 = v3[g2];
            if (!l2.circle[y3]) {
              l2.circle[y3] = true;
              var x2 = 3 * y3;
              if (this._circleAndRectCollide(m2[x2], m2[x2 + 1], m2[x2 + 2], t2, e2, i2, o2) && (!s2 || s2(this.circleKeys[y3]))) {
                if (n2.hitTest)
                  return a2.push(true), true;
                var b2 = m2[x2], w2 = m2[x2 + 1], T2 = m2[x2 + 2];
                a2.push({ key: this.circleKeys[y3], x1: b2 - T2, y1: w2 - T2, x2: b2 + T2, y2: w2 + T2 });
              }
            }
          }
      }, Yt.prototype._queryCellCircle = function(t2, e2, i2, o2, r2, a2, n2, s2) {
        var l2 = n2.circle, c3 = n2.seenUids, u2 = this.boxCells[r2];
        if (null !== u2)
          for (var h3 = this.bboxes, p3 = 0, d2 = u2; p3 < d2.length; p3 += 1) {
            var _24 = d2[p3];
            if (!c3.box[_24]) {
              c3.box[_24] = true;
              var f2 = 4 * _24;
              if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, h3[f2 + 0], h3[f2 + 1], h3[f2 + 2], h3[f2 + 3]) && (!s2 || s2(this.boxKeys[_24])))
                return a2.push(true), true;
            }
          }
        var m2 = this.circleCells[r2];
        if (null !== m2)
          for (var g2 = this.circles, v3 = 0, y3 = m2; v3 < y3.length; v3 += 1) {
            var x2 = y3[v3];
            if (!c3.circle[x2]) {
              c3.circle[x2] = true;
              var b2 = 3 * x2;
              if (this._circlesCollide(g2[b2], g2[b2 + 1], g2[b2 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[x2])))
                return a2.push(true), true;
            }
          }
      }, Yt.prototype._forEachCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
        for (var l2 = this._convertToXCellCoord(t2), c3 = this._convertToYCellCoord(e2), u2 = this._convertToXCellCoord(i2), h3 = this._convertToYCellCoord(o2), p3 = l2; p3 <= u2; p3++)
          for (var d2 = c3; d2 <= h3; d2++)
            if (r2.call(this, t2, e2, i2, o2, this.xCellCount * d2 + p3, a2, n2, s2))
              return;
      }, Yt.prototype._convertToXCellCoord = function(t2) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
      }, Yt.prototype._convertToYCellCoord = function(t2) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
      }, Yt.prototype._circlesCollide = function(t2, e2, i2, o2, r2, a2) {
        var n2 = o2 - t2, s2 = r2 - e2, l2 = i2 + a2;
        return l2 * l2 > n2 * n2 + s2 * s2;
      }, Yt.prototype._circleAndRectCollide = function(t2, e2, i2, o2, r2, a2, n2) {
        var s2 = (a2 - o2) / 2, l2 = Math.abs(t2 - (o2 + s2));
        if (l2 > s2 + i2)
          return false;
        var c3 = (n2 - r2) / 2, u2 = Math.abs(e2 - (r2 + c3));
        if (u2 > c3 + i2)
          return false;
        if (l2 <= s2 || u2 <= c3)
          return true;
        var h3 = l2 - s2, p3 = u2 - c3;
        return h3 * h3 + p3 * p3 <= i2 * i2;
      };
      var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function ce(t2, e2) {
        for (var i2 = 0; i2 < t2; i2++) {
          var o2 = e2.length;
          e2.resize(o2 + 4), e2.float32.set(le, 3 * o2);
        }
      }
      function ue(t2, e2, i2) {
        var o2 = e2[0], r2 = e2[1];
        return t2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], t2;
      }
      var he = function(t2, e2, i2) {
        void 0 === e2 && (e2 = new Yt(t2.width + 200, t2.height + 200, 25)), void 0 === i2 && (i2 = new Yt(t2.width + 200, t2.height + 200, 25)), this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + 100, this.screenBottomBoundary = t2.height + 100, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200;
      };
      function pe(e2, i2, o2) {
        return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
      }
      he.prototype.placeCollisionBox = function(t2, e2, i2, o2, r2) {
        var a2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY), n2 = i2 * a2.perspectiveRatio, s2 = t2.x1 * n2 + a2.point.x, l2 = t2.y1 * n2 + a2.point.y, c3 = t2.x2 * n2 + a2.point.x, u2 = t2.y2 * n2 + a2.point.y;
        return !this.isInsideGrid(s2, l2, c3, u2) || !e2 && this.grid.hitTest(s2, l2, c3, u2, r2) ? { box: [], offscreen: false } : { box: [s2, l2, c3, u2], offscreen: this.isOffscreen(s2, l2, c3, u2) };
      }, he.prototype.placeCollisionCircles = function(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3, d2) {
        var _24 = [], f2 = new t.Point(i2.anchorX, i2.anchorY), m2 = $t(f2, n2), g2 = te(this.transform.cameraToCenterDistance, m2.signedDistanceFromCamera), v3 = (u2 ? a2 / g2 : a2 * g2) / t.ONE_EM, y3 = $t(f2, s2).point, x2 = oe(v3, r2, i2.lineOffsetX * v3, i2.lineOffsetY * v3, false, y3, f2, i2, o2, s2, {}), b2 = false, w2 = false, T2 = true;
        if (x2) {
          for (var E2 = 0.5 * p3 * g2 + d2, I3 = new t.Point(-100, -100), P2 = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S2 = new Kt(), C2 = x2.first, z2 = x2.last, D2 = [], A3 = C2.path.length - 1; A3 >= 1; A3--)
            D2.push(C2.path[A3]);
          for (var M2 = 1; M2 < z2.path.length; M2++)
            D2.push(z2.path[M2]);
          var L2 = 2.5 * E2;
          if (l2) {
            var R2 = D2.map(function(t2) {
              return $t(t2, l2);
            });
            D2 = R2.some(function(t2) {
              return t2.signedDistanceFromCamera <= 0;
            }) ? [] : R2.map(function(t2) {
              return t2.point;
            });
          }
          var k2 = [];
          if (D2.length > 0) {
            for (var B2 = D2[0].clone(), O3 = D2[0].clone(), F2 = 1; F2 < D2.length; F2++)
              B2.x = Math.min(B2.x, D2[F2].x), B2.y = Math.min(B2.y, D2[F2].y), O3.x = Math.max(O3.x, D2[F2].x), O3.y = Math.max(O3.y, D2[F2].y);
            k2 = B2.x >= I3.x && O3.x <= P2.x && B2.y >= I3.y && O3.y <= P2.y ? [D2] : O3.x < I3.x || B2.x > P2.x || O3.y < I3.y || B2.y > P2.y ? [] : t.clipLine([D2], I3.x, I3.y, P2.x, P2.y);
          }
          for (var U2 = 0, N2 = k2; U2 < N2.length; U2 += 1) {
            var Z3;
            S2.reset(N2[U2], 0.25 * E2), Z3 = S2.length <= 0.5 * E2 ? 1 : Math.ceil(S2.paddedLength / L2) + 1;
            for (var q2 = 0; q2 < Z3; q2++) {
              var j2 = q2 / Math.max(Z3 - 1, 1), V3 = S2.lerp(j2), G2 = V3.x + 100, W2 = V3.y + 100;
              _24.push(G2, W2, E2, 0);
              var X2 = G2 - E2, H2 = W2 - E2, K2 = G2 + E2, Y2 = W2 + E2;
              if (T2 = T2 && this.isOffscreen(X2, H2, K2, Y2), w2 = w2 || this.isInsideGrid(X2, H2, K2, Y2), !e2 && this.grid.hitTestCircle(G2, W2, E2, h3) && (b2 = true, !c3))
                return { circles: [], offscreen: false, collisionDetected: b2 };
            }
          }
        }
        return { circles: !c3 && b2 || !w2 ? [] : _24, offscreen: T2, collisionDetected: b2 };
      }, he.prototype.queryRenderedSymbols = function(e2) {
        if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
          return {};
        for (var i2 = [], o2 = 1 / 0, r2 = 1 / 0, a2 = -1 / 0, n2 = -1 / 0, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
          var c3 = l2[s2], u2 = new t.Point(c3.x + 100, c3.y + 100);
          o2 = Math.min(o2, u2.x), r2 = Math.min(r2, u2.y), a2 = Math.max(a2, u2.x), n2 = Math.max(n2, u2.y), i2.push(u2);
        }
        for (var h3 = {}, p3 = {}, d2 = 0, _24 = this.grid.query(o2, r2, a2, n2).concat(this.ignoredGrid.query(o2, r2, a2, n2)); d2 < _24.length; d2 += 1) {
          var f2 = _24[d2], m2 = f2.key;
          if (void 0 === h3[m2.bucketInstanceId] && (h3[m2.bucketInstanceId] = {}), !h3[m2.bucketInstanceId][m2.featureIndex]) {
            var g2 = [new t.Point(f2.x1, f2.y1), new t.Point(f2.x2, f2.y1), new t.Point(f2.x2, f2.y2), new t.Point(f2.x1, f2.y2)];
            t.polygonIntersectsPolygon(i2, g2) && (h3[m2.bucketInstanceId][m2.featureIndex] = true, void 0 === p3[m2.bucketInstanceId] && (p3[m2.bucketInstanceId] = []), p3[m2.bucketInstanceId].push(m2.featureIndex));
          }
        }
        return p3;
      }, he.prototype.insertCollisionBox = function(t2, e2, i2, o2, r2) {
        (e2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, t2[0], t2[1], t2[2], t2[3]);
      }, he.prototype.insertCollisionCircles = function(t2, e2, i2, o2, r2) {
        for (var a2 = e2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, s2 = 0; s2 < t2.length; s2 += 4)
          a2.insertCircle(n2, t2[s2], t2[s2 + 1], t2[s2 + 2]);
      }, he.prototype.projectAndGetPerspectiveRatio = function(e2, i2, o2) {
        var r2 = [i2, o2, 0, 1];
        return ue(r2, r2, e2), { point: new t.Point((r2[0] / r2[3] + 1) / 2 * this.transform.width + 100, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
      }, he.prototype.isOffscreen = function(t2, e2, i2, o2) {
        return i2 < 100 || t2 >= this.screenRightBoundary || o2 < 100 || e2 > this.screenBottomBoundary;
      }, he.prototype.isInsideGrid = function(t2, e2, i2, o2) {
        return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
      }, he.prototype.getViewportMatrix = function() {
        var e2 = t.identity([]);
        return t.translate(e2, e2, [-100, -100, 0]), e2;
      };
      var de = function(t2, e2, i2, o2) {
        this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
      };
      de.prototype.isHidden = function() {
        return 0 === this.opacity && !this.placed;
      };
      var _e = function(t2, e2, i2, o2, r2) {
        this.text = new de(t2 ? t2.text : null, e2, i2, r2), this.icon = new de(t2 ? t2.icon : null, e2, o2, r2);
      };
      _e.prototype.isHidden = function() {
        return this.text.isHidden() && this.icon.isHidden();
      };
      var fe = function(t2, e2, i2) {
        this.text = t2, this.icon = e2, this.skipFade = i2;
      }, me = function() {
        this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
      }, ge = function(t2, e2, i2, o2, r2) {
        this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
      }, ve = function(t2) {
        this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
      };
      function ye(e2, i2, o2, r2, a2) {
        var n2 = t.getAnchorAlignment(e2), s2 = -(n2.horizontalAlign - 0.5) * i2, l2 = -(n2.verticalAlign - 0.5) * o2, c3 = t.evaluateVariableOffset(e2, r2);
        return new t.Point(s2 + c3[0] * a2, l2 + c3[1] * a2);
      }
      function xe(e2, i2, o2, r2, a2, n2) {
        var s2 = e2.x1, l2 = e2.x2, c3 = e2.y1, u2 = e2.y2, h3 = e2.anchorPointX, p3 = e2.anchorPointY, d2 = new t.Point(i2, o2);
        return r2 && d2._rotate(a2 ? n2 : -n2), { x1: s2 + d2.x, y1: c3 + d2.y, x2: l2 + d2.x, y2: u2 + d2.y, anchorPointX: h3, anchorPointY: p3 };
      }
      ve.prototype.get = function(t2) {
        if (this.crossSourceCollisions)
          return { ID: 0, predicate: null };
        if (!this.collisionGroups[t2]) {
          var e2 = ++this.maxGroupID;
          this.collisionGroups[t2] = { ID: e2, predicate: function(t3) {
            return t3.collisionGroupID === e2;
          } };
        }
        return this.collisionGroups[t2];
      };
      var be = function(t2, e2, i2, o2) {
        this.transform = t2.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e2, this.retainedQueryData = {}, this.collisionGroups = new ve(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
      };
      function we(t2, e2, i2, o2, r2) {
        t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
      }
      be.prototype.getBucketParts = function(e2, i2, o2, r2) {
        var a2 = o2.getBucket(i2), n2 = o2.latestFeatureIndex;
        if (a2 && n2 && i2.id === a2.layerIds[0]) {
          var s2 = o2.collisionBoxArray, l2 = a2.layers[0].layout, c3 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u2 = o2.tileSize / t.EXTENT, h3 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), p3 = "map" === l2.get("text-pitch-alignment"), d2 = "map" === l2.get("text-rotation-alignment"), _24 = pe(o2, 1, this.transform.zoom), f2 = Jt(h3, p3, d2, this.transform, _24), m2 = null;
          if (p3) {
            var g2 = Qt(h3, p3, d2, this.transform, _24);
            m2 = t.multiply([], this.transform.labelPlaneMatrix, g2);
          }
          this.retainedQueryData[a2.bucketInstanceId] = new ge(a2.bucketInstanceId, n2, a2.sourceLayerIndex, a2.index, o2.tileID);
          var v3 = { bucket: a2, layout: l2, posMatrix: h3, textLabelPlaneMatrix: f2, labelToScreenMatrix: m2, scale: c3, textPixelRatio: u2, holdingForFade: o2.holdingForFade(), collisionBoxArray: s2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
          if (r2)
            for (var y3 = 0, x2 = a2.sortKeyRanges; y3 < x2.length; y3 += 1) {
              var b2 = x2[y3];
              e2.push({ sortKey: b2.sortKey, symbolInstanceStart: b2.symbolInstanceStart, symbolInstanceEnd: b2.symbolInstanceEnd, parameters: v3 });
            }
          else
            e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: v3 });
        }
      }, be.prototype.attemptAnchorPlacement = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3, d2, _24) {
        var f2, m2 = [h3.textOffset0, h3.textOffset1], g2 = ye(t2, i2, o2, m2, r2), v3 = this.collisionIndex.placeCollisionBox(xe(e2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c3.predicate);
        if (!_24 || 0 !== this.collisionIndex.placeCollisionBox(xe(_24, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c3.predicate).box.length)
          return v3.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h3.crossTileID] && this.prevPlacement.placements[h3.crossTileID] && this.prevPlacement.placements[h3.crossTileID].text && (f2 = this.prevPlacement.variableOffsets[h3.crossTileID].anchor), this.variableOffsets[h3.crossTileID] = { textOffset: m2, width: i2, height: o2, anchor: t2, textBoxScale: r2, prevAnchor: f2 }, this.markUsedJustification(p3, t2, h3, d2), p3.allowVerticalPlacement && (this.markUsedOrientation(p3, d2, h3), this.placedOrientations[h3.crossTileID] = d2), { shift: g2, placedGlyphBoxes: v3 }) : void 0;
      }, be.prototype.placeLayerBucketPart = function(e2, i2, o2) {
        var r2 = this, a2 = e2.parameters, n2 = a2.bucket, s2 = a2.layout, l2 = a2.posMatrix, c3 = a2.textLabelPlaneMatrix, u2 = a2.labelToScreenMatrix, h3 = a2.textPixelRatio, p3 = a2.holdingForFade, d2 = a2.collisionBoxArray, _24 = a2.partiallyEvaluatedTextSize, f2 = a2.collisionGroup, m2 = s2.get("text-optional"), g2 = s2.get("icon-optional"), v3 = s2.get("text-allow-overlap"), y3 = s2.get("icon-allow-overlap"), x2 = "map" === s2.get("text-rotation-alignment"), b2 = "map" === s2.get("text-pitch-alignment"), w2 = "none" !== s2.get("icon-text-fit"), T2 = "viewport-y" === s2.get("symbol-z-order"), E2 = v3 && (y3 || !n2.hasIconData() || g2), I3 = y3 && (v3 || !n2.hasTextData() || m2);
        !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2);
        var P2 = function(e3, a3) {
          if (!i2[e3.crossTileID])
            if (p3)
              r2.placements[e3.crossTileID] = new fe(false, false, false);
            else {
              var d3, T3 = false, P3 = false, S3 = true, C3 = null, z3 = { box: null, offscreen: null }, D3 = { box: null, offscreen: null }, A4 = null, M2 = null, L2 = 0, R2 = 0, k2 = 0;
              a3.textFeatureIndex ? L2 = a3.textFeatureIndex : e3.useRuntimeCollisionCircles && (L2 = e3.featureIndex), a3.verticalTextFeatureIndex && (R2 = a3.verticalTextFeatureIndex);
              var B2 = a3.textBox;
              if (B2) {
                var O3 = function(i3) {
                  var o3 = t.WritingMode.horizontal;
                  if (n2.allowVerticalPlacement && !i3 && r2.prevPlacement) {
                    var a4 = r2.prevPlacement.placedOrientations[e3.crossTileID];
                    a4 && (r2.placedOrientations[e3.crossTileID] = a4, r2.markUsedOrientation(n2, o3 = a4, e3));
                  }
                  return o3;
                }, F2 = function(i3, o3) {
                  if (n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && a3.verticalTextBox)
                    for (var r3 = 0, s3 = n2.writingModes; r3 < s3.length && (s3[r3] === t.WritingMode.vertical ? (z3 = o3(), D3 = z3) : z3 = i3(), !(z3 && z3.box && z3.box.length)); r3 += 1)
                      ;
                  else
                    z3 = i3();
                };
                if (s2.get("text-variable-anchor")) {
                  var U2 = s2.get("text-variable-anchor");
                  if (r2.prevPlacement && r2.prevPlacement.variableOffsets[e3.crossTileID]) {
                    var N2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                    U2.indexOf(N2.anchor) > 0 && (U2 = U2.filter(function(t2) {
                      return t2 !== N2.anchor;
                    })).unshift(N2.anchor);
                  }
                  var Z3 = function(t2, i3, o3) {
                    for (var a4 = t2.x2 - t2.x1, s3 = t2.y2 - t2.y1, c4 = e3.textBoxScale, u3 = w2 && !y3 ? i3 : null, p4 = { box: [], offscreen: false }, d4 = v3 ? 2 * U2.length : U2.length, _25 = 0; _25 < d4; ++_25) {
                      var m3 = r2.attemptAnchorPlacement(U2[_25 % U2.length], t2, a4, s3, c4, x2, b2, h3, l2, f2, _25 >= U2.length, e3, n2, o3, u3);
                      if (m3 && (p4 = m3.placedGlyphBoxes) && p4.box && p4.box.length) {
                        T3 = true, C3 = m3.shift;
                        break;
                      }
                    }
                    return p4;
                  };
                  F2(function() {
                    return Z3(B2, a3.iconBox, t.WritingMode.horizontal);
                  }, function() {
                    var i3 = a3.verticalTextBox;
                    return n2.allowVerticalPlacement && !(z3 && z3.box && z3.box.length) && e3.numVerticalGlyphVertices > 0 && i3 ? Z3(i3, a3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), z3 && (T3 = z3.box, S3 = z3.offscreen);
                  var q2 = O3(z3 && z3.box);
                  if (!T3 && r2.prevPlacement) {
                    var j2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                    j2 && (r2.variableOffsets[e3.crossTileID] = j2, r2.markUsedJustification(n2, j2.anchor, e3, q2));
                  }
                } else {
                  var V3 = function(t2, i3) {
                    var o3 = r2.collisionIndex.placeCollisionBox(t2, v3, h3, l2, f2.predicate);
                    return o3 && o3.box && o3.box.length && (r2.markUsedOrientation(n2, i3, e3), r2.placedOrientations[e3.crossTileID] = i3), o3;
                  };
                  F2(function() {
                    return V3(B2, t.WritingMode.horizontal);
                  }, function() {
                    var i3 = a3.verticalTextBox;
                    return n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i3 ? V3(i3, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), O3(z3 && z3.box && z3.box.length);
                }
              }
              if (T3 = (d3 = z3) && d3.box && d3.box.length > 0, S3 = d3 && d3.offscreen, e3.useRuntimeCollisionCircles) {
                var G2 = n2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), W2 = t.evaluateSizeForFeature(n2.textSizeData, _24, G2), X2 = s2.get("text-padding");
                A4 = r2.collisionIndex.placeCollisionCircles(v3, G2, n2.lineVertexArray, n2.glyphOffsetArray, W2, l2, c3, u2, o2, b2, f2.predicate, e3.collisionCircleDiameter, X2), T3 = v3 || A4.circles.length > 0 && !A4.collisionDetected, S3 = S3 && A4.offscreen;
              }
              if (a3.iconFeatureIndex && (k2 = a3.iconFeatureIndex), a3.iconBox) {
                var H2 = function(t2) {
                  var e4 = w2 && C3 ? xe(t2, C3.x, C3.y, x2, b2, r2.transform.angle) : t2;
                  return r2.collisionIndex.placeCollisionBox(e4, y3, h3, l2, f2.predicate);
                };
                P3 = D3 && D3.box && D3.box.length && a3.verticalIconBox ? (M2 = H2(a3.verticalIconBox)).box.length > 0 : (M2 = H2(a3.iconBox)).box.length > 0, S3 = S3 && M2.offscreen;
              }
              var K2 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Y2 = g2 || 0 === e3.numIconVertices;
              if (K2 || Y2 ? Y2 ? K2 || (P3 = P3 && T3) : T3 = P3 && T3 : P3 = T3 = P3 && T3, T3 && d3 && d3.box && r2.collisionIndex.insertCollisionBox(d3.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, D3 && D3.box && R2 ? R2 : L2, f2.ID), P3 && M2 && r2.collisionIndex.insertCollisionBox(M2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, k2, f2.ID), A4 && (T3 && r2.collisionIndex.insertCollisionCircles(A4.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, L2, f2.ID), o2)) {
                var J2 = n2.bucketInstanceId, Q2 = r2.collisionCircleArrays[J2];
                void 0 === Q2 && (Q2 = r2.collisionCircleArrays[J2] = new me());
                for (var $2 = 0; $2 < A4.circles.length; $2 += 4)
                  Q2.circles.push(A4.circles[$2 + 0]), Q2.circles.push(A4.circles[$2 + 1]), Q2.circles.push(A4.circles[$2 + 2]), Q2.circles.push(A4.collisionDetected ? 1 : 0);
              }
              r2.placements[e3.crossTileID] = new fe(T3 || E2, P3 || I3, S3 || n2.justReloaded), i2[e3.crossTileID] = true;
            }
        };
        if (T2)
          for (var S2 = n2.getSortedSymbolIndexes(this.transform.angle), C2 = S2.length - 1; C2 >= 0; --C2) {
            var z2 = S2[C2];
            P2(n2.symbolInstances.get(z2), n2.collisionArrays[z2]);
          }
        else
          for (var D2 = e2.symbolInstanceStart; D2 < e2.symbolInstanceEnd; D2++)
            P2(n2.symbolInstances.get(D2), n2.collisionArrays[D2]);
        if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
          var A3 = this.collisionCircleArrays[n2.bucketInstanceId];
          t.invert(A3.invProjMatrix, l2), A3.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        n2.justReloaded = false;
      }, be.prototype.markUsedJustification = function(e2, i2, o2, r2) {
        var a2;
        a2 = r2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
        for (var n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex]; n2 < s2.length; n2 += 1) {
          var l2 = s2[n2];
          l2 >= 0 && (e2.text.placedSymbolArray.get(l2).crossTileID = a2 >= 0 && l2 !== a2 ? 0 : o2.crossTileID);
        }
      }, be.prototype.markUsedOrientation = function(e2, i2, o2) {
        for (var r2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, a2 = i2 === t.WritingMode.vertical ? i2 : 0, n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex]; n2 < s2.length; n2 += 1)
          e2.text.placedSymbolArray.get(s2[n2]).placedOrientation = r2;
        o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
      }, be.prototype.commit = function(t2) {
        this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
        var e2 = this.prevPlacement, i2 = false;
        this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
        var o2 = e2 ? e2.symbolFadeChange(t2) : 1, r2 = e2 ? e2.opacities : {}, a2 = e2 ? e2.variableOffsets : {}, n2 = e2 ? e2.placedOrientations : {};
        for (var s2 in this.placements) {
          var l2 = this.placements[s2], c3 = r2[s2];
          c3 ? (this.opacities[s2] = new _e(c3, o2, l2.text, l2.icon), i2 = i2 || l2.text !== c3.text.placed || l2.icon !== c3.icon.placed) : (this.opacities[s2] = new _e(null, o2, l2.text, l2.icon, l2.skipFade), i2 = i2 || l2.text || l2.icon);
        }
        for (var u2 in r2) {
          var h3 = r2[u2];
          if (!this.opacities[u2]) {
            var p3 = new _e(h3, o2, false, false);
            p3.isHidden() || (this.opacities[u2] = p3, i2 = i2 || h3.text.placed || h3.icon.placed);
          }
        }
        for (var d2 in a2)
          this.variableOffsets[d2] || !this.opacities[d2] || this.opacities[d2].isHidden() || (this.variableOffsets[d2] = a2[d2]);
        for (var _24 in n2)
          this.placedOrientations[_24] || !this.opacities[_24] || this.opacities[_24].isHidden() || (this.placedOrientations[_24] = n2[_24]);
        i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
      }, be.prototype.updateLayerOpacities = function(t2, e2) {
        for (var i2 = {}, o2 = 0, r2 = e2; o2 < r2.length; o2 += 1) {
          var a2 = r2[o2], n2 = a2.getBucket(t2);
          n2 && a2.latestFeatureIndex && t2.id === n2.layerIds[0] && this.updateBucketOpacities(n2, i2, a2.collisionBoxArray);
        }
      }, be.prototype.updateBucketOpacities = function(e2, i2, o2) {
        var r2 = this;
        e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
        var a2 = e2.layers[0].layout, n2 = new _e(null, 0, false, false, true), s2 = a2.get("text-allow-overlap"), l2 = a2.get("icon-allow-overlap"), c3 = a2.get("text-variable-anchor"), u2 = "map" === a2.get("text-rotation-alignment"), h3 = "map" === a2.get("text-pitch-alignment"), p3 = "none" !== a2.get("icon-text-fit"), d2 = new _e(null, 0, s2 && (l2 || !e2.hasIconData() || a2.get("icon-optional")), l2 && (s2 || !e2.hasTextData() || a2.get("text-optional")), true);
        !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
        for (var _24 = function(t2, e3, i3) {
          for (var o3 = 0; o3 < e3 / 4; o3++)
            t2.opacityVertexArray.emplaceBack(i3);
        }, f2 = function(o3) {
          var a3 = e2.symbolInstances.get(o3), s3 = a3.numHorizontalGlyphVertices, l3 = a3.numVerticalGlyphVertices, f3 = a3.crossTileID, m3 = r2.opacities[f3];
          i2[f3] ? m3 = n2 : m3 || (r2.opacities[f3] = m3 = d2), i2[f3] = true;
          var g3 = a3.numIconVertices > 0, v3 = r2.placedOrientations[a3.crossTileID], y3 = v3 === t.WritingMode.vertical, x2 = v3 === t.WritingMode.horizontal || v3 === t.WritingMode.horizontalOnly;
          if (s3 > 0 || l3 > 0) {
            var b2 = De(m3.text);
            _24(e2.text, s3, y3 ? Ae : b2), _24(e2.text, l3, x2 ? Ae : b2);
            var w2 = m3.text.isHidden();
            [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach(function(t2) {
              t2 >= 0 && (e2.text.placedSymbolArray.get(t2).hidden = w2 || y3 ? 1 : 0);
            }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = w2 || x2 ? 1 : 0);
            var T2 = r2.variableOffsets[a3.crossTileID];
            T2 && r2.markUsedJustification(e2, T2.anchor, a3, v3);
            var E2 = r2.placedOrientations[a3.crossTileID];
            E2 && (r2.markUsedJustification(e2, "left", a3, E2), r2.markUsedOrientation(e2, E2, a3));
          }
          if (g3) {
            var I3 = De(m3.icon), P2 = !(p3 && a3.verticalPlacedIconSymbolIndex && y3);
            a3.placedIconSymbolIndex >= 0 && (_24(e2.icon, a3.numIconVertices, P2 ? I3 : Ae), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = m3.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (_24(e2.icon, a3.numVerticalIconVertices, P2 ? Ae : I3), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = m3.icon.isHidden());
          }
          if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
            var S2 = e2.collisionArrays[o3];
            if (S2) {
              var C2 = new t.Point(0, 0);
              if (S2.textBox || S2.verticalTextBox) {
                var z2 = true;
                if (c3) {
                  var D2 = r2.variableOffsets[f3];
                  D2 ? (C2 = ye(D2.anchor, D2.width, D2.height, D2.textOffset, D2.textBoxScale), u2 && C2._rotate(h3 ? r2.transform.angle : -r2.transform.angle)) : z2 = false;
                }
                S2.textBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || y3, C2.x, C2.y), S2.verticalTextBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || x2, C2.x, C2.y);
              }
              var A3 = Boolean(!x2 && S2.verticalIconBox);
              S2.iconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, A3, p3 ? C2.x : 0, p3 ? C2.y : 0), S2.verticalIconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, !A3, p3 ? C2.x : 0, p3 ? C2.y : 0);
            }
          }
        }, m2 = 0; m2 < e2.symbolInstances.length; m2++)
          f2(m2);
        if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
          var g2 = this.collisionCircleArrays[e2.bucketInstanceId];
          e2.placementInvProjMatrix = g2.invProjMatrix, e2.placementViewportMatrix = g2.viewportMatrix, e2.collisionCircleArray = g2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
        }
      }, be.prototype.symbolFadeChange = function(t2) {
        return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }, be.prototype.zoomAdjustment = function(t2) {
        return Math.max(0, (this.transform.zoom - t2) / 1.5);
      }, be.prototype.hasTransitions = function(t2) {
        return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
      }, be.prototype.stillRecent = function(t2, e2) {
        var i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
        return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
      }, be.prototype.setStale = function() {
        this.stale = true;
      };
      var Te = Math.pow(2, 25), Ee = Math.pow(2, 24), Ie = Math.pow(2, 17), Pe = Math.pow(2, 16), Se = Math.pow(2, 9), Ce = Math.pow(2, 8), ze = Math.pow(2, 1);
      function De(t2) {
        if (0 === t2.opacity && !t2.placed)
          return 0;
        if (1 === t2.opacity && t2.placed)
          return 4294967295;
        var e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
        return i2 * Te + e2 * Ee + i2 * Ie + e2 * Pe + i2 * Se + e2 * Ce + i2 * ze + e2;
      }
      var Ae = 0, Me = function(t2) {
        this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && void 0 !== t2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      };
      Me.prototype.continuePlacement = function(t2, e2, i2, o2, r2) {
        for (var a2 = this._bucketParts; this._currentTileIndex < t2.length; )
          if (e2.getBucketParts(a2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
            return true;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort(function(t3, e3) {
          return t3.sortKey - e3.sortKey;
        })); this._currentPartIndex < a2.length; )
          if (e2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, r2())
            return true;
        return false;
      };
      var Le = function(t2, e2, i2, o2, r2, a2, n2) {
        this.placement = new be(t2, r2, a2, n2), this._currentPlacementIndex = e2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
      };
      Le.prototype.isDone = function() {
        return this._done;
      }, Le.prototype.continuePlacement = function(e2, i2, o2) {
        for (var r2 = this, a2 = t.browser.now(), n2 = function() {
          var e3 = t.browser.now() - a2;
          return !r2._forceFullPlacement && e3 > 2;
        }; this._currentPlacementIndex >= 0; ) {
          var s2 = i2[e2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
          if ("symbol" === s2.type && (!s2.minzoom || s2.minzoom <= l2) && (!s2.maxzoom || s2.maxzoom > l2)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Me(s2)), this._inProgressLayer.continuePlacement(o2[s2.source], this.placement, this._showCollisionBoxes, s2, n2))
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = true;
      }, Le.prototype.commit = function(t2) {
        return this.placement.commit(t2), this.placement;
      };
      var Re = 512 / t.EXTENT / 2, ke = function(t2, e2, i2) {
        this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
        for (var o2 = 0; o2 < e2.length; o2++) {
          var r2 = e2.get(o2), a2 = r2.key;
          this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: r2.crossTileID, coord: this.getScaledCoordinates(r2, t2) });
        }
      };
      ke.prototype.getScaledCoordinates = function(e2, i2) {
        var o2 = Re / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
        return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * o2) };
      }, ke.prototype.findMatches = function(t2, e2, i2) {
        for (var o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z), r2 = 0; r2 < t2.length; r2++) {
          var a2 = t2.get(r2);
          if (!a2.crossTileID) {
            var n2 = this.indexedSymbolInstances[a2.key];
            if (n2)
              for (var s2 = this.getScaledCoordinates(a2, e2), l2 = 0, c3 = n2; l2 < c3.length; l2 += 1) {
                var u2 = c3[l2];
                if (Math.abs(u2.coord.x - s2.x) <= o2 && Math.abs(u2.coord.y - s2.y) <= o2 && !i2[u2.crossTileID]) {
                  i2[u2.crossTileID] = true, a2.crossTileID = u2.crossTileID;
                  break;
                }
              }
          }
        }
      };
      var Be = function() {
        this.maxCrossTileID = 0;
      };
      Be.prototype.generate = function() {
        return ++this.maxCrossTileID;
      };
      var Oe = function() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      };
      Oe.prototype.handleWrapJump = function(t2) {
        var e2 = Math.round((t2 - this.lng) / 360);
        if (0 !== e2)
          for (var i2 in this.indexes) {
            var o2 = this.indexes[i2], r2 = {};
            for (var a2 in o2) {
              var n2 = o2[a2];
              n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), r2[n2.tileID.key] = n2;
            }
            this.indexes[i2] = r2;
          }
        this.lng = t2;
      }, Oe.prototype.addBucket = function(t2, e2, i2) {
        if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
          if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
            return false;
          this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
        }
        for (var o2 = 0; o2 < e2.symbolInstances.length; o2++)
          e2.symbolInstances.get(o2).crossTileID = 0;
        this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
        var r2 = this.usedCrossTileIDs[t2.overscaledZ];
        for (var a2 in this.indexes) {
          var n2 = this.indexes[a2];
          if (Number(a2) > t2.overscaledZ)
            for (var s2 in n2) {
              var l2 = n2[s2];
              l2.tileID.isChildOf(t2) && l2.findMatches(e2.symbolInstances, t2, r2);
            }
          else {
            var c3 = n2[t2.scaledTo(Number(a2)).key];
            c3 && c3.findMatches(e2.symbolInstances, t2, r2);
          }
        }
        for (var u2 = 0; u2 < e2.symbolInstances.length; u2++) {
          var h3 = e2.symbolInstances.get(u2);
          h3.crossTileID || (h3.crossTileID = i2.generate(), r2[h3.crossTileID] = true);
        }
        return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new ke(t2, e2.symbolInstances, e2.bucketInstanceId), true;
      }, Oe.prototype.removeBucketCrossTileIDs = function(t2, e2) {
        for (var i2 in e2.indexedSymbolInstances)
          for (var o2 = 0, r2 = e2.indexedSymbolInstances[i2]; o2 < r2.length; o2 += 1)
            delete this.usedCrossTileIDs[t2][r2[o2].crossTileID];
      }, Oe.prototype.removeStaleBuckets = function(t2) {
        var e2 = false;
        for (var i2 in this.indexes) {
          var o2 = this.indexes[i2];
          for (var r2 in o2)
            t2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], e2 = true);
        }
        return e2;
      };
      var Fe = function() {
        this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      };
      Fe.prototype.addLayer = function(t2, e2, i2) {
        var o2 = this.layerIndexes[t2.id];
        void 0 === o2 && (o2 = this.layerIndexes[t2.id] = new Oe());
        var r2 = false, a2 = {};
        o2.handleWrapJump(i2);
        for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
          var l2 = s2[n2], c3 = l2.getBucket(t2);
          c3 && t2.id === c3.layerIds[0] && (c3.bucketInstanceId || (c3.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(l2.tileID, c3, this.crossTileIDs) && (r2 = true), a2[c3.bucketInstanceId] = true);
        }
        return o2.removeStaleBuckets(a2) && (r2 = true), r2;
      }, Fe.prototype.pruneUnusedLayers = function(t2) {
        var e2 = {};
        for (var i2 in t2.forEach(function(t3) {
          e2[t3] = true;
        }), this.layerIndexes)
          e2[i2] || delete this.layerIndexes[i2];
      };
      var Ue = function(e2, i2) {
        return t.emitValidationErrors(e2, i2 && i2.filter(function(t2) {
          return "source.canvas" !== t2.identifier;
        }));
      }, Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]), qe = function() {
        var e2 = {}, i2 = t.styleSpec.$version;
        for (var o2 in t.styleSpec.$root) {
          var r2, a2 = t.styleSpec.$root[o2];
          if (a2.required)
            null != (r2 = "version" === o2 ? i2 : "array" === a2.type ? [] : {}) && (e2[o2] = r2);
        }
        return e2;
      }(), je = function(e2) {
        function i2(o2, r2) {
          var a2 = this;
          void 0 === r2 && (r2 = {}), e2.call(this), this.map = o2, this.dispatcher = new E(Ft(), this), this.imageManager = new p2(), this.imageManager.setEventedParent(this), this.glyphManager = new y2(o2._requestManager, r2.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
          var n2 = this;
          this._rtlTextPluginCallback = i2.registerForPluginStateChange(function(e3) {
            n2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, function(e4, i3) {
              if (t.triggerPluginCompletionEvent(e4), i3 && i3.every(function(t2) {
                return t2;
              }))
                for (var o3 in n2.sourceCaches)
                  n2.sourceCaches[o3].reload();
            });
          }), this.on("data", function(t2) {
            if ("source" === t2.dataType && "metadata" === t2.sourceDataType) {
              var e3 = a2.sourceCaches[t2.sourceId];
              if (e3) {
                var i3 = e3.getSource();
                if (i3 && i3.vectorLayerIds)
                  for (var o3 in a2._layers) {
                    var r3 = a2._layers[o3];
                    r3.source === i3.id && a2._validateLayer(r3);
                  }
              }
            }
          });
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.loadURL = function(e3, i3) {
          var o2 = this;
          void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" }));
          var r2 = "boolean" == typeof i3.validate ? i3.validate : !t.isMapboxURL(e3);
          e3 = this.map._requestManager.normalizeStyleURL(e3, i3.accessToken);
          var a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
          this._request = t.getJSON(a2, function(e4, i4) {
            o2._request = null, e4 ? o2.fire(new t.ErrorEvent(e4)) : i4 && o2._load(i4, r2);
          });
        }, i2.prototype.loadJSON = function(e3, i3) {
          var o2 = this;
          void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame(function() {
            o2._request = null, o2._load(e3, false !== i3.validate);
          });
        }, i2.prototype.loadEmpty = function() {
          this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(qe, false);
        }, i2.prototype._load = function(e3, i3) {
          if (!i3 || !Ue(this, t.validateStyle(e3))) {
            for (var o2 in this._loaded = true, this.stylesheet = e3, e3.sources)
              this.addSource(o2, e3.sources[o2], { validate: false });
            e3.sprite ? this._loadSprite(e3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
            var r2 = Nt(this.stylesheet.layers);
            this._order = r2.map(function(t2) {
              return t2.id;
            }), this._layers = {}, this._serializedLayers = {};
            for (var a2 = 0, n2 = r2; a2 < n2.length; a2 += 1) {
              var s2 = n2[a2];
              (s2 = t.createStyleLayer(s2)).setEventedParent(this, { layer: { id: s2.id } }), this._layers[s2.id] = s2, this._serializedLayers[s2.id] = s2.serialize();
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
          }
        }, i2.prototype._loadSprite = function(e3) {
          var i3 = this;
          this._spriteRequest = function(e4, i4, o2) {
            var r2, a2, n2, s2 = t.browser.devicePixelRatio > 1 ? "@2x" : "", l2 = t.getJSON(i4.transformRequest(i4.normalizeSpriteURL(e4, s2, ".json"), t.ResourceType.SpriteJSON), function(t2, e5) {
              l2 = null, n2 || (n2 = t2, r2 = e5, u2());
            }), c3 = t.getImage(i4.transformRequest(i4.normalizeSpriteURL(e4, s2, ".png"), t.ResourceType.SpriteImage), function(t2, e5) {
              c3 = null, n2 || (n2 = t2, a2 = e5, u2());
            });
            function u2() {
              if (n2)
                o2(n2);
              else if (r2 && a2) {
                var e5 = t.browser.getImageData(a2), i5 = {};
                for (var s3 in r2) {
                  var l3 = r2[s3], c4 = l3.width, u3 = l3.height, h3 = l3.x, p3 = l3.y, d2 = l3.sdf, _24 = l3.pixelRatio, f2 = l3.stretchX, m2 = l3.stretchY, g2 = l3.content, v3 = new t.RGBAImage({ width: c4, height: u3 });
                  t.RGBAImage.copy(e5, v3, { x: h3, y: p3 }, { x: 0, y: 0 }, { width: c4, height: u3 }), i5[s3] = { data: v3, pixelRatio: _24, sdf: d2, stretchX: f2, stretchY: m2, content: g2 };
                }
                o2(null, i5);
              }
            }
            return { cancel: function() {
              l2 && (l2.cancel(), l2 = null), c3 && (c3.cancel(), c3 = null);
            } };
          }(e3, this.map._requestManager, function(e4, o2) {
            if (i3._spriteRequest = null, e4)
              i3.fire(new t.ErrorEvent(e4));
            else if (o2)
              for (var r2 in o2)
                i3.imageManager.addImage(r2, o2[r2]);
            i3.imageManager.setLoaded(true), i3._availableImages = i3.imageManager.listImages(), i3.dispatcher.broadcast("setImages", i3._availableImages), i3.fire(new t.Event("data", { dataType: "style" }));
          });
        }, i2.prototype._validateLayer = function(e3) {
          var i3 = this.sourceCaches[e3.source];
          if (i3) {
            var o2 = e3.sourceLayer;
            if (o2) {
              var r2 = i3.getSource();
              ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + o2 + '" does not exist on source "' + r2.id + '" as specified by style layer "' + e3.id + '"')));
            }
          }
        }, i2.prototype.loaded = function() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (var t2 in this.sourceCaches)
            if (!this.sourceCaches[t2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }, i2.prototype._serializeLayers = function(t2) {
          for (var e3 = [], i3 = 0, o2 = t2; i3 < o2.length; i3 += 1) {
            var r2 = this._layers[o2[i3]];
            "custom" !== r2.type && e3.push(r2.serialize());
          }
          return e3;
        }, i2.prototype.hasTransitions = function() {
          if (this.light && this.light.hasTransition())
            return true;
          for (var t2 in this.sourceCaches)
            if (this.sourceCaches[t2].hasTransition())
              return true;
          for (var e3 in this._layers)
            if (this._layers[e3].hasTransition())
              return true;
          return false;
        }, i2.prototype._checkLoaded = function() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }, i2.prototype.update = function(e3) {
          if (this._loaded) {
            var i3 = this._changed;
            if (this._changed) {
              var o2 = Object.keys(this._updatedLayers), r2 = Object.keys(this._removedLayers);
              for (var a2 in (o2.length || r2.length) && this._updateWorkerLayers(o2, r2), this._updatedSources) {
                var n2 = this._updatedSources[a2];
                "reload" === n2 ? this._reloadSource(a2) : "clear" === n2 && this._clearSource(a2);
              }
              for (var s2 in this._updateTilesForChangedImages(), this._updatedPaintProps)
                this._layers[s2].updateTransitions(e3);
              this.light.updateTransitions(e3), this._resetUpdates();
            }
            var l2 = {};
            for (var c3 in this.sourceCaches) {
              var u2 = this.sourceCaches[c3];
              l2[c3] = u2.used, u2.used = false;
            }
            for (var h3 = 0, p3 = this._order; h3 < p3.length; h3 += 1) {
              var d2 = this._layers[p3[h3]];
              d2.recalculate(e3, this._availableImages), !d2.isHidden(e3.zoom) && d2.source && (this.sourceCaches[d2.source].used = true);
            }
            for (var _24 in l2) {
              var f2 = this.sourceCaches[_24];
              l2[_24] !== f2.used && f2.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: _24 }));
            }
            this.light.recalculate(e3), this.z = e3.zoom, i3 && this.fire(new t.Event("data", { dataType: "style" }));
          }
        }, i2.prototype._updateTilesForChangedImages = function() {
          var t2 = Object.keys(this._changedImages);
          if (t2.length) {
            for (var e3 in this.sourceCaches)
              this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t2);
            this._changedImages = {};
          }
        }, i2.prototype._updateWorkerLayers = function(t2, e3) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e3 });
        }, i2.prototype._resetUpdates = function() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }, i2.prototype.setState = function(e3) {
          var i3 = this;
          if (this._checkLoaded(), Ue(this, t.validateStyle(e3)))
            return false;
          (e3 = t.clone$1(e3)).layers = Nt(e3.layers);
          var o2 = function(e4, i4) {
            if (!e4)
              return [{ command: Zt.setStyle, args: [i4] }];
            var o3 = [];
            try {
              if (!t.deepEqual(e4.version, i4.version))
                return [{ command: Zt.setStyle, args: [i4] }];
              t.deepEqual(e4.center, i4.center) || o3.push({ command: Zt.setCenter, args: [i4.center] }), t.deepEqual(e4.zoom, i4.zoom) || o3.push({ command: Zt.setZoom, args: [i4.zoom] }), t.deepEqual(e4.bearing, i4.bearing) || o3.push({ command: Zt.setBearing, args: [i4.bearing] }), t.deepEqual(e4.pitch, i4.pitch) || o3.push({ command: Zt.setPitch, args: [i4.pitch] }), t.deepEqual(e4.sprite, i4.sprite) || o3.push({ command: Zt.setSprite, args: [i4.sprite] }), t.deepEqual(e4.glyphs, i4.glyphs) || o3.push({ command: Zt.setGlyphs, args: [i4.glyphs] }), t.deepEqual(e4.transition, i4.transition) || o3.push({ command: Zt.setTransition, args: [i4.transition] }), t.deepEqual(e4.light, i4.light) || o3.push({ command: Zt.setLight, args: [i4.light] });
              var r3 = {}, a2 = [];
              !function(e5, i5, o4, r4) {
                var a3;
                for (a3 in i5 = i5 || {}, e5 = e5 || {})
                  e5.hasOwnProperty(a3) && (i5.hasOwnProperty(a3) || jt(a3, o4, r4));
                for (a3 in i5)
                  i5.hasOwnProperty(a3) && (e5.hasOwnProperty(a3) ? t.deepEqual(e5[a3], i5[a3]) || ("geojson" === e5[a3].type && "geojson" === i5[a3].type && Gt(e5, i5, a3) ? o4.push({ command: Zt.setGeoJSONSourceData, args: [a3, i5[a3].data] }) : Vt(a3, i5, o4, r4)) : qt(a3, i5, o4));
              }(e4.sources, i4.sources, a2, r3);
              var n2 = [];
              e4.layers && e4.layers.forEach(function(t2) {
                r3[t2.source] ? o3.push({ command: Zt.removeLayer, args: [t2.id] }) : n2.push(t2);
              }), o3 = o3.concat(a2), function(e5, i5, o4) {
                i5 = i5 || [];
                var r4, a3, n3, s2, l2, c3, u2, h3 = (e5 = e5 || []).map(Xt), p3 = i5.map(Xt), d2 = e5.reduce(Ht, {}), _24 = i5.reduce(Ht, {}), f2 = h3.slice(), m2 = /* @__PURE__ */ Object.create(null);
                for (r4 = 0, a3 = 0; r4 < h3.length; r4++)
                  _24.hasOwnProperty(n3 = h3[r4]) ? a3++ : (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.indexOf(n3, a3), 1));
                for (r4 = 0, a3 = 0; r4 < p3.length; r4++)
                  f2[f2.length - 1 - r4] !== (n3 = p3[p3.length - 1 - r4]) && (d2.hasOwnProperty(n3) ? (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.lastIndexOf(n3, f2.length - a3), 1)) : a3++, o4.push({ command: Zt.addLayer, args: [_24[n3], c3 = f2[f2.length - r4]] }), f2.splice(f2.length - r4, 0, n3), m2[n3] = true);
                for (r4 = 0; r4 < p3.length; r4++)
                  if (s2 = d2[n3 = p3[r4]], l2 = _24[n3], !m2[n3] && !t.deepEqual(s2, l2))
                    if (t.deepEqual(s2.source, l2.source) && t.deepEqual(s2["source-layer"], l2["source-layer"]) && t.deepEqual(s2.type, l2.type)) {
                      for (u2 in Wt(s2.layout, l2.layout, o4, n3, null, Zt.setLayoutProperty), Wt(s2.paint, l2.paint, o4, n3, null, Zt.setPaintProperty), t.deepEqual(s2.filter, l2.filter) || o4.push({ command: Zt.setFilter, args: [n3, l2.filter] }), t.deepEqual(s2.minzoom, l2.minzoom) && t.deepEqual(s2.maxzoom, l2.maxzoom) || o4.push({ command: Zt.setLayerZoomRange, args: [n3, l2.minzoom, l2.maxzoom] }), s2)
                        s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                      for (u2 in l2)
                        l2.hasOwnProperty(u2) && !s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                    } else
                      o4.push({ command: Zt.removeLayer, args: [n3] }), c3 = f2[f2.lastIndexOf(n3) + 1], o4.push({ command: Zt.addLayer, args: [l2, c3] });
              }(n2, i4.layers, o3);
            } catch (t2) {
              console.warn("Unable to compute style diff:", t2), o3 = [{ command: Zt.setStyle, args: [i4] }];
            }
            return o3;
          }(this.serialize(), e3).filter(function(t2) {
            return !(t2.command in Ze);
          });
          if (0 === o2.length)
            return false;
          var r2 = o2.filter(function(t2) {
            return !(t2.command in Ne);
          });
          if (r2.length > 0)
            throw new Error("Unimplemented: " + r2.map(function(t2) {
              return t2.command;
            }).join(", ") + ".");
          return o2.forEach(function(t2) {
            "setTransition" !== t2.command && i3[t2.command].apply(i3, t2.args);
          }), this.stylesheet = e3, true;
        }, i2.prototype.addImage = function(e3, i3) {
          if (this.getImage(e3))
            return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(e3, i3), this._afterImageUpdated(e3);
        }, i2.prototype.updateImage = function(t2, e3) {
          this.imageManager.updateImage(t2, e3);
        }, i2.prototype.getImage = function(t2) {
          return this.imageManager.getImage(t2);
        }, i2.prototype.removeImage = function(e3) {
          if (!this.getImage(e3))
            return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
        }, i2.prototype._afterImageUpdated = function(e3) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
        }, i2.prototype.listImages = function() {
          return this._checkLoaded(), this.imageManager.listImages();
        }, i2.prototype.addSource = function(e3, i3, o2) {
          var r2 = this;
          if (void 0 === o2 && (o2 = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e3])
            throw new Error("There is already a source with this ID");
          if (!i3.type)
            throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i3).join(", ") + ".");
          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e3, i3, null, o2))) {
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            var a2 = this.sourceCaches[e3] = new Dt(e3, i3, this.dispatcher);
            a2.style = this, a2.setEventedParent(this, function() {
              return { isSourceLoaded: r2.loaded(), source: a2.serialize(), sourceId: e3 };
            }), a2.onAdd(this.map), this._changed = true;
          }
        }, i2.prototype.removeSource = function(e3) {
          if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
            throw new Error("There is no source with this ID");
          for (var i3 in this._layers)
            if (this._layers[i3].source === e3)
              return this.fire(new t.ErrorEvent(new Error('Source "' + e3 + '" cannot be removed while layer "' + i3 + '" is using it.')));
          var o2 = this.sourceCaches[e3];
          delete this.sourceCaches[e3], delete this._updatedSources[e3], o2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), o2.setEventedParent(null), o2.clearTiles(), o2.onRemove && o2.onRemove(this.map), this._changed = true;
        }, i2.prototype.setGeoJSONSourceData = function(t2, e3) {
          this._checkLoaded(), this.sourceCaches[t2].getSource().setData(e3), this._changed = true;
        }, i2.prototype.getSource = function(t2) {
          return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
        }, i2.prototype.addLayer = function(e3, i3, o2) {
          void 0 === o2 && (o2 = {}), this._checkLoaded();
          var r2 = e3.id;
          if (this.getLayer(r2))
            this.fire(new t.ErrorEvent(new Error('Layer with id "' + r2 + '" already exists on this map')));
          else {
            var a2;
            if ("custom" === e3.type) {
              if (Ue(this, t.validateCustomStyleLayer(e3)))
                return;
              a2 = t.createStyleLayer(e3);
            } else {
              if ("object" == typeof e3.source && (this.addSource(r2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: r2 })), this._validate(t.validateStyle.layer, "layers." + r2, e3, { arrayIndex: -1 }, o2))
                return;
              a2 = t.createStyleLayer(e3), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[a2.id] = a2.serialize();
            }
            var n2 = i3 ? this._order.indexOf(i3) : this._order.length;
            if (i3 && -1 === n2)
              this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.')));
            else {
              if (this._order.splice(n2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = a2, this._removedLayers[r2] && a2.source && "custom" !== a2.type) {
                var s2 = this._removedLayers[r2];
                delete this._removedLayers[r2], s2.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
              }
              this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
            }
          }
        }, i2.prototype.moveLayer = function(e3, i3) {
          if (this._checkLoaded(), this._changed = true, this._layers[e3]) {
            if (e3 !== i3) {
              var o2 = this._order.indexOf(e3);
              this._order.splice(o2, 1);
              var r2 = i3 ? this._order.indexOf(i3) : this._order.length;
              i3 && -1 === r2 ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.'))) : (this._order.splice(r2, 0, e3), this._layerOrderChanged = true);
            }
          } else
            this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be moved.")));
        }, i2.prototype.removeLayer = function(e3) {
          this._checkLoaded();
          var i3 = this._layers[e3];
          if (i3) {
            i3.setEventedParent(null);
            var o2 = this._order.indexOf(e3);
            this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i3, delete this._layers[e3], delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i3.onRemove && i3.onRemove(this.map);
          } else
            this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be removed.")));
        }, i2.prototype.getLayer = function(t2) {
          return this._layers[t2];
        }, i2.prototype.hasLayer = function(t2) {
          return t2 in this._layers;
        }, i2.prototype.setLayerZoomRange = function(e3, i3, o2) {
          this._checkLoaded();
          var r2 = this.getLayer(e3);
          r2 ? r2.minzoom === i3 && r2.maxzoom === o2 || (null != i3 && (r2.minzoom = i3), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot have zoom extent.")));
        }, i2.prototype.setFilter = function(e3, i3, o2) {
          void 0 === o2 && (o2 = {}), this._checkLoaded();
          var r2 = this.getLayer(e3);
          if (r2) {
            if (!t.deepEqual(r2.filter, i3))
              return null == i3 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, "layers." + r2.id + ".filter", i3, null, o2) || (r2.filter = t.clone$1(i3), this._updateLayer(r2)));
          } else
            this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be filtered.")));
        }, i2.prototype.getFilter = function(e3) {
          return t.clone$1(this.getLayer(e3).filter);
        }, i2.prototype.setLayoutProperty = function(e3, i3, o2, r2) {
          void 0 === r2 && (r2 = {}), this._checkLoaded();
          var a2 = this.getLayer(e3);
          a2 ? t.deepEqual(a2.getLayoutProperty(i3), o2) || (a2.setLayoutProperty(i3, o2, r2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
        }, i2.prototype.getLayoutProperty = function(e3, i3) {
          var o2 = this.getLayer(e3);
          if (o2)
            return o2.getLayoutProperty(i3);
          this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style.")));
        }, i2.prototype.setPaintProperty = function(e3, i3, o2, r2) {
          void 0 === r2 && (r2 = {}), this._checkLoaded();
          var a2 = this.getLayer(e3);
          a2 ? t.deepEqual(a2.getPaintProperty(i3), o2) || (a2.setPaintProperty(i3, o2, r2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
        }, i2.prototype.getPaintProperty = function(t2, e3) {
          return this.getLayer(t2).getPaintProperty(e3);
        }, i2.prototype.setFeatureState = function(e3, i3) {
          this._checkLoaded();
          var o2 = e3.source, r2 = e3.sourceLayer, a2 = this.sourceCaches[o2];
          if (void 0 !== a2) {
            var n2 = a2.getSource().type;
            "geojson" === n2 && r2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n2 || r2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.setFeatureState(r2, e3.id, i3)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
        }, i2.prototype.removeFeatureState = function(e3, i3) {
          this._checkLoaded();
          var o2 = e3.source, r2 = this.sourceCaches[o2];
          if (void 0 !== r2) {
            var a2 = r2.getSource().type, n2 = "vector" === a2 ? e3.sourceLayer : void 0;
            "vector" !== a2 || n2 ? i3 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r2.removeFeatureState(n2, e3.id, i3) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
        }, i2.prototype.getFeatureState = function(e3) {
          this._checkLoaded();
          var i3 = e3.source, o2 = e3.sourceLayer, r2 = this.sourceCaches[i3];
          if (void 0 !== r2) {
            if ("vector" !== r2.getSource().type || o2)
              return void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.getFeatureState(o2, e3.id);
            this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new t.ErrorEvent(new Error("The source '" + i3 + "' does not exist in the map's style.")));
        }, i2.prototype.getTransition = function() {
          return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }, i2.prototype.serialize = function() {
          return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, function(t2) {
            return t2.serialize();
          }), layers: this._serializeLayers(this._order) }, function(t2) {
            return void 0 !== t2;
          });
        }, i2.prototype._updateLayer = function(t2) {
          this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
        }, i2.prototype._flattenAndSortRenderedFeatures = function(t2) {
          for (var e3 = this, i3 = function(t3) {
            return "fill-extrusion" === e3._layers[t3].type;
          }, o2 = {}, r2 = [], a2 = this._order.length - 1; a2 >= 0; a2--) {
            var n2 = this._order[a2];
            if (i3(n2)) {
              o2[n2] = a2;
              for (var s2 = 0, l2 = t2; s2 < l2.length; s2 += 1) {
                var c3 = l2[s2][n2];
                if (c3)
                  for (var u2 = 0, h3 = c3; u2 < h3.length; u2 += 1)
                    r2.push(h3[u2]);
              }
            }
          }
          r2.sort(function(t3, e4) {
            return e4.intersectionZ - t3.intersectionZ;
          });
          for (var p3 = [], d2 = this._order.length - 1; d2 >= 0; d2--) {
            var _24 = this._order[d2];
            if (i3(_24))
              for (var f2 = r2.length - 1; f2 >= 0; f2--) {
                var m2 = r2[f2].feature;
                if (o2[m2.layer.id] < d2)
                  break;
                p3.push(m2), r2.pop();
              }
            else
              for (var g2 = 0, v3 = t2; g2 < v3.length; g2 += 1) {
                var y3 = v3[g2][_24];
                if (y3)
                  for (var x2 = 0, b2 = y3; x2 < b2.length; x2 += 1)
                    p3.push(b2[x2].feature);
              }
          }
          return p3;
        }, i2.prototype.queryRenderedFeatures = function(e3, i3, o2) {
          i3 && i3.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
          var r2 = {};
          if (i3 && i3.layers) {
            if (!Array.isArray(i3.layers))
              return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (var a2 = 0, n2 = i3.layers; a2 < n2.length; a2 += 1) {
              var s2 = n2[a2], l2 = this._layers[s2];
              if (!l2)
                return this.fire(new t.ErrorEvent(new Error("The layer '" + s2 + "' does not exist in the map's style and cannot be queried for features."))), [];
              r2[l2.source] = true;
            }
          }
          var c3 = [];
          for (var u2 in i3.availableImages = this._availableImages, this.sourceCaches)
            i3.layers && !r2[u2] || c3.push(O2(this.sourceCaches[u2], this._layers, this._serializedLayers, e3, i3, o2));
          return this.placement && c3.push(function(t2, e4, i4, o3, r3, a3, n3) {
            for (var s3 = {}, l3 = a3.queryRenderedSymbols(o3), c4 = [], u3 = 0, h3 = Object.keys(l3).map(Number); u3 < h3.length; u3 += 1)
              c4.push(n3[h3[u3]]);
            c4.sort(F);
            for (var p3 = function() {
              var i5 = _24[d2], o4 = i5.featureIndex.lookupSymbolFeatures(l3[i5.bucketInstanceId], e4, i5.bucketIndex, i5.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, t2);
              for (var a4 in o4) {
                var n4 = s3[a4] = s3[a4] || [], c5 = o4[a4];
                c5.sort(function(t3, e5) {
                  var o5 = i5.featureSortOrder;
                  if (o5) {
                    var r4 = o5.indexOf(t3.featureIndex);
                    return o5.indexOf(e5.featureIndex) - r4;
                  }
                  return e5.featureIndex - t3.featureIndex;
                });
                for (var u4 = 0, h4 = c5; u4 < h4.length; u4 += 1)
                  n4.push(h4[u4]);
              }
            }, d2 = 0, _24 = c4; d2 < _24.length; d2 += 1)
              p3();
            var f2 = function(e5) {
              s3[e5].forEach(function(o4) {
                var r4 = o4.feature, a4 = i4[t2[e5].source].getFeatureState(r4.layer["source-layer"], r4.id);
                r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = a4;
              });
            };
            for (var m2 in s3)
              f2(m2);
            return s3;
          }(this._layers, this._serializedLayers, this.sourceCaches, e3, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c3);
        }, i2.prototype.querySourceFeatures = function(e3, i3) {
          i3 && i3.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i3.filter, null, i3);
          var o2 = this.sourceCaches[e3];
          return o2 ? function(t2, e4) {
            for (var i4 = t2.getRenderableIds().map(function(e5) {
              return t2.getTileByID(e5);
            }), o3 = [], r2 = {}, a2 = 0; a2 < i4.length; a2++) {
              var n2 = i4[a2], s2 = n2.tileID.canonical.key;
              r2[s2] || (r2[s2] = true, n2.querySourceFeatures(o3, e4));
            }
            return o3;
          }(o2, i3) : [];
        }, i2.prototype.addSourceType = function(t2, e3, o2) {
          return i2.getSourceType(t2) ? o2(new Error('A source type called "' + t2 + '" already exists.')) : (i2.setSourceType(t2, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e3.workerSourceURL }, o2) : o2(null, null));
        }, i2.prototype.getLight = function() {
          return this.light.getLight();
        }, i2.prototype.setLight = function(e3, i3) {
          void 0 === i3 && (i3 = {}), this._checkLoaded();
          var o2 = this.light.getLight(), r2 = false;
          for (var a2 in e3)
            if (!t.deepEqual(e3[a2], o2[a2])) {
              r2 = true;
              break;
            }
          if (r2) {
            var n2 = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e3, i3), this.light.updateTransitions(n2);
          }
        }, i2.prototype._validate = function(e3, i3, o2, r2, a2) {
          return void 0 === a2 && (a2 = {}), (!a2 || false !== a2.validate) && Ue(this, e3.call(t.validateStyle, t.extend({ key: i3, style: this.serialize(), value: o2, styleSpec: t.styleSpec }, r2)));
        }, i2.prototype._remove = function() {
          for (var e3 in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
            this._layers[e3].setEventedParent(null);
          for (var i3 in this.sourceCaches)
            this.sourceCaches[i3].clearTiles(), this.sourceCaches[i3].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }, i2.prototype._clearSource = function(t2) {
          this.sourceCaches[t2].clearTiles();
        }, i2.prototype._reloadSource = function(t2) {
          this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
        }, i2.prototype._updateSources = function(t2) {
          for (var e3 in this.sourceCaches)
            this.sourceCaches[e3].update(t2);
        }, i2.prototype._generateCollisionBoxes = function() {
          for (var t2 in this.sourceCaches)
            this._reloadSource(t2);
        }, i2.prototype._updatePlacement = function(e3, i3, o2, r2, a2) {
          void 0 === a2 && (a2 = false);
          for (var n2 = false, s2 = false, l2 = {}, c3 = 0, u2 = this._order; c3 < u2.length; c3 += 1) {
            var h3 = this._layers[u2[c3]];
            if ("symbol" === h3.type) {
              if (!l2[h3.source]) {
                var p3 = this.sourceCaches[h3.source];
                l2[h3.source] = p3.getRenderableIds(true).map(function(t2) {
                  return p3.getTileByID(t2);
                }).sort(function(t2, e4) {
                  return e4.tileID.overscaledZ - t2.tileID.overscaledZ || (t2.tileID.isLessThan(e4.tileID) ? -1 : 1);
                });
              }
              var d2 = this.crossTileSymbolIndex.addLayer(h3, l2[h3.source], e3.center.lng);
              n2 = n2 || d2;
            }
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a2 = a2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e3.zoom)) && (this.pauseablePlacement = new Le(e3, this._order, a2, i3, o2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s2 = true), n2 && this.pauseablePlacement.placement.setStale()), s2 || n2)
            for (var _24 = 0, f2 = this._order; _24 < f2.length; _24 += 1) {
              var m2 = this._layers[f2[_24]];
              "symbol" === m2.type && this.placement.updateLayerOpacities(m2, l2[m2.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());
        }, i2.prototype._releaseSymbolFadeTiles = function() {
          for (var t2 in this.sourceCaches)
            this.sourceCaches[t2].releaseSymbolFadeTiles();
        }, i2.prototype.getImages = function(t2, e3, i3) {
          this.imageManager.getImages(e3.icons, i3), this._updateTilesForChangedImages();
          var o2 = this.sourceCaches[e3.source];
          o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
        }, i2.prototype.getGlyphs = function(t2, e3, i3) {
          this.glyphManager.getGlyphs(e3.stacks, i3);
        }, i2.prototype.getResource = function(e3, i3, o2) {
          return t.makeRequest(i3, o2);
        }, i2;
      }(t.Evented);
      je.getSourceType = function(t2) {
        return k[t2];
      }, je.setSourceType = function(t2, e2) {
        k[t2] = e2;
      }, je.registerForPluginStateChange = t.registerForPluginStateChange;
      var Ve = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Ge = gi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), He = gi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), ei = gi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), ii = gi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), si = gi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), fi = gi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), mi = gi("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");
      function gi(t2, e2) {
        var i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e2.match(/attribute ([\w]+) ([\w]+)/g), r2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), n2 = a2 ? a2.concat(r2) : r2, s2 = {};
        return { fragmentSource: t2 = t2.replace(i2, function(t3, e3, i3, o3, r3) {
          return s2[r3] = true, "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nvarying " + i3 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
        }), vertexSource: e2 = e2.replace(i2, function(t3, e3, i3, o3, r3) {
          var a3 = "float" === o3 ? "vec2" : "vec4", n3 = r3.match(/color/) ? "color" : a3;
          return s2[r3] ? "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i3 + " " + a3 + " a_" + r3 + ";\nvarying " + i3 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = a_" + r3 + ";\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i3 + " " + a3 + " a_" + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = a_" + r3 + ";\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
        }), staticAttributes: o2, staticUniforms: n2 };
      }
      var vi = Object.freeze({ __proto__: null, prelude: Ge, background: We, backgroundPattern: Xe, circle: He, clippingMask: Ke, heatmap: Ye, heatmapTexture: Je, collisionBox: Qe, collisionCircle: $e, debug: ti, fill: ei, fillOutline: ii, fillOutlinePattern: oi, fillPattern: ri, fillExtrusion: ai, fillExtrusionPattern: ni, hillshadePrepare: si, hillshade: li, line: ci, lineGradient: ui, linePattern: hi, lineSDF: pi, raster: di, symbolIcon: _i, symbolSDF: fi, symbolTextAndIcon: mi }), yi = function() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      };
      function xi(t2) {
        for (var e2 = [], i2 = 0; i2 < t2.length; i2++)
          if (null !== t2[i2]) {
            var o2 = t2[i2].split(" ");
            e2.push(o2.pop());
          }
        return e2;
      }
      yi.prototype.bind = function(t2, e2, i2, o2, r2, a2, n2, s2) {
        this.context = t2;
        for (var l2 = this.boundPaintVertexBuffers.length !== o2.length, c3 = 0; !l2 && c3 < o2.length; c3++)
          this.boundPaintVertexBuffers[c3] !== o2[c3] && (l2 = true);
        t2.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i2 && !l2 && this.boundIndexBuffer === r2 && this.boundVertexOffset === a2 && this.boundDynamicVertexBuffer === n2 && this.boundDynamicVertexBuffer2 === s2 ? (t2.bindVertexArrayOES.set(this.vao), n2 && n2.bind(), r2 && r2.dynamicDraw && r2.bind(), s2 && s2.bind()) : this.freshBind(e2, i2, o2, r2, a2, n2, s2);
      }, yi.prototype.freshBind = function(t2, e2, i2, o2, r2, a2, n2) {
        var s2, l2 = t2.numAttributes, c3 = this.context, u2 = c3.gl;
        if (c3.extVertexArrayObject)
          this.vao && this.destroy(), this.vao = c3.extVertexArrayObject.createVertexArrayOES(), c3.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = n2;
        else {
          s2 = c3.currentNumAttributes || 0;
          for (var h3 = l2; h3 < s2; h3++)
            u2.disableVertexAttribArray(h3);
        }
        e2.enableAttributes(u2, t2);
        for (var p3 = 0, d2 = i2; p3 < d2.length; p3 += 1)
          d2[p3].enableAttributes(u2, t2);
        a2 && a2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e2.bind(), e2.setVertexAttribPointers(u2, t2, r2);
        for (var _24 = 0, f2 = i2; _24 < f2.length; _24 += 1) {
          var m2 = f2[_24];
          m2.bind(), m2.setVertexAttribPointers(u2, t2, r2);
        }
        a2 && (a2.bind(), a2.setVertexAttribPointers(u2, t2, r2)), o2 && o2.bind(), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, r2)), c3.currentNumAttributes = l2;
      }, yi.prototype.destroy = function() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      };
      var bi = function(t2, e2, i2, o2, r2, a2) {
        var n2 = t2.gl;
        this.program = n2.createProgram();
        for (var s2 = xi(i2.staticAttributes), l2 = o2 ? o2.getBinderAttributes() : [], c3 = s2.concat(l2), u2 = i2.staticUniforms ? xi(i2.staticUniforms) : [], h3 = o2 ? o2.getBinderUniforms() : [], p3 = [], d2 = 0, _24 = u2.concat(h3); d2 < _24.length; d2 += 1) {
          var f2 = _24[d2];
          p3.indexOf(f2) < 0 && p3.push(f2);
        }
        var m2 = o2 ? o2.defines() : [];
        a2 && m2.push("#define OVERDRAW_INSPECTOR;");
        var g2 = m2.concat(Ge.fragmentSource, i2.fragmentSource).join("\n"), v3 = m2.concat(Ge.vertexSource, i2.vertexSource).join("\n"), y3 = n2.createShader(n2.FRAGMENT_SHADER);
        if (n2.isContextLost())
          this.failedToCreate = true;
        else {
          n2.shaderSource(y3, g2), n2.compileShader(y3), n2.attachShader(this.program, y3);
          var x2 = n2.createShader(n2.VERTEX_SHADER);
          if (n2.isContextLost())
            this.failedToCreate = true;
          else {
            n2.shaderSource(x2, v3), n2.compileShader(x2), n2.attachShader(this.program, x2), this.attributes = {};
            var b2 = {};
            this.numAttributes = c3.length;
            for (var w2 = 0; w2 < this.numAttributes; w2++)
              c3[w2] && (n2.bindAttribLocation(this.program, w2, c3[w2]), this.attributes[c3[w2]] = w2);
            n2.linkProgram(this.program), n2.deleteShader(x2), n2.deleteShader(y3);
            for (var T2 = 0; T2 < p3.length; T2++) {
              var E2 = p3[T2];
              if (E2 && !b2[E2]) {
                var I3 = n2.getUniformLocation(this.program, E2);
                I3 && (b2[E2] = I3);
              }
            }
            this.fixedUniforms = r2(t2, b2), this.binderUniforms = o2 ? o2.getUniforms(t2, b2) : [];
          }
        }
      };
      function wi(t2, e2, i2) {
        var o2 = 1 / pe(i2, 1, e2.transform.tileZoom), r2 = Math.pow(2, i2.tileID.overscaledZ), a2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / r2, n2 = a2 * (i2.tileID.canonical.x + i2.tileID.wrap * r2), s2 = a2 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [n2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & s2] };
      }
      bi.prototype.draw = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3, d2, _24, f2) {
        var m2, g2 = t2.gl;
        if (!this.failedToCreate) {
          for (var v3 in t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(r2), t2.setCullFace(a2), this.fixedUniforms)
            this.fixedUniforms[v3].set(n2[v3]);
          d2 && d2.setUniforms(t2, this.binderUniforms, h3, { zoom: p3 });
          for (var y3 = (m2 = {}, m2[g2.LINES] = 2, m2[g2.TRIANGLES] = 3, m2[g2.LINE_STRIP] = 1, m2)[e2], x2 = 0, b2 = u2.get(); x2 < b2.length; x2 += 1) {
            var w2 = b2[x2], T2 = w2.vaos || (w2.vaos = {});
            (T2[s2] || (T2[s2] = new yi())).bind(t2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c3, w2.vertexOffset, _24, f2), g2.drawElements(e2, w2.primitiveLength * y3, g2.UNSIGNED_SHORT, w2.primitiveOffset * y3 * 2);
          }
        }
      };
      var Ti = function(e2, i2, o2, r2) {
        var a2 = i2.style.light, n2 = a2.properties.get("position"), s2 = [n2.x, n2.y, n2.z], l2 = t.create$1();
        "viewport" === a2.properties.get("anchor") && t.fromRotation(l2, -i2.transform.angle), t.transformMat3(s2, s2, l2);
        var c3 = a2.properties.get("color");
        return { u_matrix: e2, u_lightpos: s2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [c3.r, c3.g, c3.b], u_vertical_gradient: +o2, u_opacity: r2 };
      }, Ei = function(e2, i2, o2, r2, a2, n2, s2) {
        return t.extend(Ti(e2, i2, o2, r2), wi(n2, i2, s2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / s2.tileSize / 8 });
      }, Ii = function(t2) {
        return { u_matrix: t2 };
      }, Pi = function(e2, i2, o2, r2) {
        return t.extend(Ii(e2), wi(o2, i2, r2));
      }, Si = function(t2, e2) {
        return { u_matrix: t2, u_world: e2 };
      }, Ci = function(e2, i2, o2, r2, a2) {
        return t.extend(Pi(e2, i2, o2, r2), { u_world: a2 });
      }, zi = function(e2, i2, o2, r2) {
        var a2, n2, s2 = e2.transform;
        if ("map" === r2.paint.get("circle-pitch-alignment")) {
          var l2 = pe(o2, 1, s2.zoom);
          a2 = true, n2 = [l2, l2];
        } else
          a2 = false, n2 = s2.pixelsToGLUnits;
        return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === r2.paint.get("circle-pitch-scale")), u_matrix: e2.translatePosMatrix(i2.posMatrix, o2, r2.paint.get("circle-translate"), r2.paint.get("circle-translate-anchor")), u_pitch_with_map: +a2, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: n2 };
      }, Di = function(t2, e2, i2) {
        var o2 = pe(i2, 1, e2.zoom), r2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), a2 = i2.tileID.overscaleFactor();
        return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * r2), e2.pixelsToGLUnits[1] / (o2 * r2)], u_overscale_factor: a2 };
      }, Ai = function(t2, e2, i2) {
        return { u_matrix: t2, u_inv_matrix: e2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_viewport_size: [i2.width, i2.height] };
      }, Mi = function(t2, e2, i2) {
        return void 0 === i2 && (i2 = 1), { u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 };
      }, Li = function(t2) {
        return { u_matrix: t2 };
      }, Ri = function(t2, e2, i2, o2) {
        return { u_matrix: t2, u_extrude_scale: pe(e2, 1, i2), u_intensity: o2 };
      }, ki = function(e2, i2, o2) {
        var r2 = e2.transform;
        return { u_matrix: Ni(e2, i2, o2), u_ratio: 1 / pe(i2, 1, r2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
      }, Bi = function(e2, i2, o2, r2) {
        return t.extend(ki(e2, i2, o2), { u_image: 0, u_image_height: r2 });
      }, Oi = function(e2, i2, o2, r2) {
        var a2 = e2.transform, n2 = Ui(i2, a2);
        return { u_matrix: Ni(e2, i2, o2), u_texsize: i2.imageAtlasTexture.size, u_ratio: 1 / pe(i2, 1, a2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [n2, r2.fromScale, r2.toScale], u_fade: r2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
      }, Fi = function(e2, i2, o2, r2, a2) {
        var n2 = e2.lineAtlas, s2 = Ui(i2, e2.transform), l2 = "round" === o2.layout.get("line-cap"), c3 = n2.getDash(r2.from, l2), u2 = n2.getDash(r2.to, l2), h3 = c3.width * a2.fromScale, p3 = u2.width * a2.toScale;
        return t.extend(ki(e2, i2, o2), { u_patternscale_a: [s2 / h3, -c3.height / 2], u_patternscale_b: [s2 / p3, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(h3, p3) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: u2.y, u_mix: a2.t });
      };
      function Ui(t2, e2) {
        return 1 / pe(t2, 1, e2.tileZoom);
      }
      function Ni(t2, e2, i2) {
        return t2.translatePosMatrix(e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      var Zi = function(t2, e2, i2, o2, r2) {
        return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (n2 = r2.paint.get("raster-saturation"), n2 > 0 ? 1 - 1 / (1.001 - n2) : -n2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: qi(r2.paint.get("raster-hue-rotate")) };
        var a2, n2;
      };
      function qi(t2) {
        t2 *= Math.PI / 180;
        var e2 = Math.sin(t2), i2 = Math.cos(t2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
      }
      var ji, Vi = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c3) {
        var u2 = r2.transform;
        return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: u2.cameraToCenterDistance, u_pitch: u2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: u2.width / u2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c3, u_texture: 0 };
      }, Gi = function(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3) {
        var p3 = a2.transform;
        return t.extend(Vi(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2), { u_gamma_scale: r2 ? Math.cos(p3._pitch) * p3.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +h3 });
      }, Wi = function(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2) {
        return t.extend(Gi(e2, i2, o2, r2, a2, n2, s2, l2, true, c3, true), { u_texsize_icon: u2, u_texture_icon: 1 });
      }, Xi = function(t2, e2, i2) {
        return { u_matrix: t2, u_opacity: e2, u_color: i2 };
      }, Hi = function(e2, i2, o2, r2, a2, n2) {
        return t.extend(function(t2, e3, i3, o3) {
          var r3 = i3.imageManager.getPattern(t2.from.toString()), a3 = i3.imageManager.getPattern(t2.to.toString()), n3 = i3.imageManager.getPixelSize(), s2 = n3.width, l2 = n3.height, c3 = Math.pow(2, o3.tileID.overscaledZ), u2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / c3, h3 = u2 * (o3.tileID.canonical.x + o3.tileID.wrap * c3), p3 = u2 * o3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: r3.tl, u_pattern_br_a: r3.br, u_pattern_tl_b: a3.tl, u_pattern_br_b: a3.br, u_texsize: [s2, l2], u_mix: e3.t, u_pattern_size_a: r3.displaySize, u_pattern_size_b: a3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / pe(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h3 >> 16, p3 >> 16], u_pixel_coord_lower: [65535 & h3, 65535 & p3] };
        }(r2, n2, o2, a2), { u_matrix: e2, u_opacity: i2 });
      }, Ki = { fillExtrusion: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
      }, fillExtrusionPattern: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
      }, fill: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
      }, fillPattern: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
      }, fillOutline: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) };
      }, fillOutlinePattern: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
      }, circle: function(e2, i2) {
        return { u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
      }, collisionBox: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i2.u_overscale_factor) };
      }, collisionCircle: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i2.u_viewport_size) };
      }, debug: function(e2, i2) {
        return { u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_overlay: new t.Uniform1i(e2, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i2.u_overlay_scale) };
      }, clippingMask: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
      }, heatmap: function(e2, i2) {
        return { u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
      }, heatmapTexture: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
      }, hillshade: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) };
      }, hillshadePrepare: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) };
      }, line: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) };
      }, lineGradient: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_image_height: new t.Uniform1f(e2, i2.u_image_height) };
      }, linePattern: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
      }, lineSDF: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i2.u_sdfgamma), u_image: new t.Uniform1i(e2, i2.u_image), u_tex_y_a: new t.Uniform1f(e2, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i2.u_tex_y_b), u_mix: new t.Uniform1f(e2, i2.u_mix) };
      }, raster: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) };
      }, symbolIcon: function(e2, i2) {
        return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) };
      }, symbolSDF: function(e2, i2) {
        return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) };
      }, symbolTextAndIcon: function(e2, i2) {
        return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) };
      }, background: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) };
      }, backgroundPattern: function(e2, i2) {
        return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) };
      } };
      function Yi(e2, i2, o2, r2, a2, n2, s2) {
        for (var l2 = e2.context, c3 = l2.gl, u2 = e2.useProgram("collisionBox"), h3 = [], p3 = 0, d2 = 0, _24 = 0; _24 < r2.length; _24++) {
          var f2 = r2[_24], m2 = i2.getTile(f2), g2 = m2.getBucket(o2);
          if (g2) {
            var v3 = f2.posMatrix;
            0 === a2[0] && 0 === a2[1] || (v3 = e2.translatePosMatrix(f2.posMatrix, m2, a2, n2));
            var y3 = s2 ? g2.textCollisionBox : g2.iconCollisionBox, x2 = g2.collisionCircleArray;
            if (x2.length > 0) {
              var b2 = t.create(), w2 = v3;
              t.mul(b2, g2.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul(b2, b2, g2.placementViewportMatrix), h3.push({ circleArray: x2, circleOffset: d2, transform: w2, invTransform: b2 }), d2 = p3 += x2.length / 4;
            }
            y3 && u2.draw(l2, c3.LINES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, Di(v3, e2.transform, m2), o2.id, y3.layoutVertexBuffer, y3.indexBuffer, y3.segments, null, e2.transform.zoom, null, null, y3.collisionVertexBuffer);
          }
        }
        if (s2 && h3.length) {
          var T2 = e2.useProgram("collisionCircle"), E2 = new t.StructArrayLayout2f1f2i16();
          E2.resize(4 * p3), E2._trim();
          for (var I3 = 0, P2 = 0, S2 = h3; P2 < S2.length; P2 += 1)
            for (var C2 = S2[P2], z2 = 0; z2 < C2.circleArray.length / 4; z2++) {
              var D2 = 4 * z2, A3 = C2.circleArray[D2 + 0], M2 = C2.circleArray[D2 + 1], L2 = C2.circleArray[D2 + 2], R2 = C2.circleArray[D2 + 3];
              E2.emplace(I3++, A3, M2, L2, R2, 0), E2.emplace(I3++, A3, M2, L2, R2, 1), E2.emplace(I3++, A3, M2, L2, R2, 2), E2.emplace(I3++, A3, M2, L2, R2, 3);
            }
          (!ji || ji.length < 2 * p3) && (ji = function(e3) {
            var i3 = 2 * e3, o3 = new t.StructArrayLayout3ui6();
            o3.resize(i3), o3._trim();
            for (var r3 = 0; r3 < i3; r3++) {
              var a3 = 6 * r3;
              o3.uint16[a3 + 0] = 4 * r3 + 0, o3.uint16[a3 + 1] = 4 * r3 + 1, o3.uint16[a3 + 2] = 4 * r3 + 2, o3.uint16[a3 + 3] = 4 * r3 + 2, o3.uint16[a3 + 4] = 4 * r3 + 3, o3.uint16[a3 + 5] = 4 * r3 + 0;
            }
            return o3;
          }(p3));
          for (var k2 = l2.createIndexBuffer(ji, true), B2 = l2.createVertexBuffer(E2, t.collisionCircleLayout.members, true), O3 = 0, F2 = h3; O3 < F2.length; O3 += 1) {
            var U2 = F2[O3], N2 = Ai(U2.transform, U2.invTransform, e2.transform);
            T2.draw(l2, c3.TRIANGLES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, N2, o2.id, B2, k2, t.SegmentVector.simpleSegment(0, 2 * U2.circleOffset, U2.circleArray.length, U2.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
          }
          B2.destroy(), k2.destroy();
        }
      }
      var Ji = t.identity(new Float32Array(16));
      function Qi(e2, i2, o2, r2, a2, n2) {
        var s2 = t.getAnchorAlignment(e2), l2 = -(s2.horizontalAlign - 0.5) * i2, c3 = -(s2.verticalAlign - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, r2);
        return new t.Point((l2 / a2 + u2[0]) * n2, (c3 / a2 + u2[1]) * n2);
      }
      function $i(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3) {
        var p3 = e2.text.placedSymbolArray, d2 = e2.text.dynamicLayoutVertexArray, _24 = e2.icon.dynamicLayoutVertexArray, f2 = {};
        d2.clear();
        for (var m2 = 0; m2 < p3.length; m2++) {
          var g2 = p3.get(m2), v3 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : r2[g2.crossTileID];
          if (v3) {
            var y3 = new t.Point(g2.anchorX, g2.anchorY), x2 = $t(y3, o2 ? l2 : s2), b2 = te(n2.cameraToCenterDistance, x2.signedDistanceFromCamera), w2 = a2.evaluateSizeForFeature(e2.textSizeData, u2, g2) * b2 / t.ONE_EM;
            o2 && (w2 *= e2.tilePixelRatio / c3);
            for (var T2 = Qi(v3.anchor, v3.width, v3.height, v3.textOffset, v3.textBoxScale, w2), E2 = o2 ? $t(y3.add(T2), s2).point : x2.point.add(i2 ? T2.rotate(-n2.angle) : T2), I3 = e2.allowVerticalPlacement && g2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P2 = 0; P2 < g2.numGlyphs; P2++)
              t.addDynamicAttributes(d2, E2, I3);
            h3 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: E2, angle: I3 });
          } else
            ce(g2.numGlyphs, d2);
        }
        if (h3) {
          _24.clear();
          for (var S2 = e2.icon.placedSymbolArray, C2 = 0; C2 < S2.length; C2++) {
            var z2 = S2.get(C2);
            if (z2.hidden)
              ce(z2.numGlyphs, _24);
            else {
              var D2 = f2[C2];
              if (D2)
                for (var A3 = 0; A3 < z2.numGlyphs; A3++)
                  t.addDynamicAttributes(_24, D2.shiftedAnchor, D2.angle);
              else
                ce(z2.numGlyphs, _24);
            }
          }
          e2.icon.dynamicLayoutVertexBuffer.updateData(_24);
        }
        e2.text.dynamicLayoutVertexBuffer.updateData(d2);
      }
      function to(t2, e2, i2) {
        return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
      }
      function eo(e2, i2, o2, r2, a2, n2, s2, l2, c3, u2, h3, p3) {
        for (var d2 = e2.context, _24 = d2.gl, f2 = e2.transform, m2 = "map" === l2, g2 = "map" === c3, v3 = m2 && "point" !== o2.layout.get("symbol-placement"), y3 = m2 && !g2 && !v3, x2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1), b2 = false, w2 = e2.depthModeForSublayer(0, It.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [], I3 = 0, P2 = r2; I3 < P2.length; I3 += 1) {
          var S2 = P2[I3], C2 = i2.getTile(S2), z2 = C2.getBucket(o2);
          if (z2) {
            var D2 = a2 ? z2.text : z2.icon;
            if (D2 && D2.segments.get().length) {
              var A3 = D2.programConfigurations.get(o2.id), M2 = a2 || z2.sdfIcons, L2 = a2 ? z2.textSizeData : z2.iconSizeData, R2 = g2 || 0 !== f2.pitch, k2 = e2.useProgram(to(M2, a2, z2), A3), B2 = t.evaluateSizeForZoom(L2, f2.zoom), O3 = void 0, F2 = [0, 0], U2 = void 0, N2 = void 0, Z3 = null, q2 = void 0;
              if (a2)
                U2 = C2.glyphAtlasTexture, N2 = _24.LINEAR, O3 = C2.glyphAtlasTexture.size, z2.iconsInText && (F2 = C2.imageAtlasTexture.size, Z3 = C2.imageAtlasTexture, q2 = R2 || e2.options.rotating || e2.options.zooming || "composite" === L2.kind || "camera" === L2.kind ? _24.LINEAR : _24.NEAREST);
              else {
                var j2 = 1 !== o2.layout.get("icon-size").constantOr(0) || z2.iconsNeedLinear;
                U2 = C2.imageAtlasTexture, N2 = M2 || e2.options.rotating || e2.options.zooming || j2 || R2 ? _24.LINEAR : _24.NEAREST, O3 = C2.imageAtlasTexture.size;
              }
              var V3 = pe(C2, 1, e2.transform.zoom), G2 = Jt(S2.posMatrix, g2, m2, e2.transform, V3), W2 = Qt(S2.posMatrix, g2, m2, e2.transform, V3), X2 = T2 && z2.hasTextData(), H2 = "none" !== o2.layout.get("icon-text-fit") && X2 && z2.hasIconData();
              v3 && ie(z2, S2.posMatrix, e2, a2, G2, W2, g2, u2);
              var K2 = e2.translatePosMatrix(S2.posMatrix, C2, n2, s2), Y2 = v3 || a2 && T2 || H2 ? Ji : G2, J2 = e2.translatePosMatrix(W2, C2, n2, s2, true), Q2 = M2 && 0 !== o2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1), $2 = { program: k2, buffers: D2, uniformValues: M2 ? z2.iconsInText ? Wi(L2.kind, B2, y3, g2, e2, K2, Y2, J2, O3, F2) : Gi(L2.kind, B2, y3, g2, e2, K2, Y2, J2, a2, O3, true) : Vi(L2.kind, B2, y3, g2, e2, K2, Y2, J2, a2, O3), atlasTexture: U2, atlasTextureIcon: Z3, atlasInterpolation: N2, atlasInterpolationIcon: q2, isSDF: M2, hasHalo: Q2 };
              if (x2 && z2.canOverlap) {
                b2 = true;
                for (var tt2 = 0, et2 = D2.segments.get(); tt2 < et2.length; tt2 += 1) {
                  var it2 = et2[tt2];
                  E2.push({ segments: new t.SegmentVector([it2]), sortKey: it2.sortKey, state: $2 });
                }
              } else
                E2.push({ segments: D2.segments, sortKey: 0, state: $2 });
            }
          }
        }
        b2 && E2.sort(function(t2, e3) {
          return t2.sortKey - e3.sortKey;
        });
        for (var ot2 = 0, rt2 = E2; ot2 < rt2.length; ot2 += 1) {
          var at2 = rt2[ot2], nt2 = at2.state;
          if (d2.activeTexture.set(_24.TEXTURE0), nt2.atlasTexture.bind(nt2.atlasInterpolation, _24.CLAMP_TO_EDGE), nt2.atlasTextureIcon && (d2.activeTexture.set(_24.TEXTURE1), nt2.atlasTextureIcon && nt2.atlasTextureIcon.bind(nt2.atlasInterpolationIcon, _24.CLAMP_TO_EDGE)), nt2.isSDF) {
            var st2 = nt2.uniformValues;
            nt2.hasHalo && (st2.u_is_halo = 1, io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h3, p3, st2)), st2.u_is_halo = 0;
          }
          io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h3, p3, nt2.uniformValues);
        }
      }
      function io(t2, e2, i2, o2, r2, a2, n2, s2, l2) {
        var c3 = o2.context;
        r2.draw(c3, c3.gl.TRIANGLES, a2, n2, s2, Ct.disabled, l2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
      }
      function oo(t2, e2, i2, o2, r2, a2, n2) {
        var s2, l2, c3, u2, h3, p3 = t2.context.gl, d2 = i2.paint.get("fill-pattern"), _24 = d2 && d2.constantOr(1), f2 = i2.getCrossfadeParameters();
        n2 ? (l2 = _24 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s2 = p3.LINES) : (l2 = _24 ? "fillPattern" : "fill", s2 = p3.TRIANGLES);
        for (var m2 = 0, g2 = o2; m2 < g2.length; m2 += 1) {
          var v3 = g2[m2], y3 = e2.getTile(v3);
          if (!_24 || y3.patternsLoaded()) {
            var x2 = y3.getBucket(i2);
            if (x2) {
              var b2 = x2.programConfigurations.get(i2.id), w2 = t2.useProgram(l2, b2);
              _24 && (t2.context.activeTexture.set(p3.TEXTURE0), y3.imageAtlasTexture.bind(p3.LINEAR, p3.CLAMP_TO_EDGE), b2.updatePaintBuffers(f2));
              var T2 = d2.constantOr(null);
              if (T2 && y3.imageAtlas) {
                var E2 = y3.imageAtlas, I3 = E2.patternPositions[T2.to.toString()], P2 = E2.patternPositions[T2.from.toString()];
                I3 && P2 && b2.setConstantPatternPositions(I3, P2);
              }
              var S2 = t2.translatePosMatrix(v3.posMatrix, y3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
              if (n2) {
                u2 = x2.indexBuffer2, h3 = x2.segments2;
                var C2 = [p3.drawingBufferWidth, p3.drawingBufferHeight];
                c3 = "fillOutlinePattern" === l2 && _24 ? Ci(S2, t2, f2, y3, C2) : Si(S2, C2);
              } else
                u2 = x2.indexBuffer, h3 = x2.segments, c3 = _24 ? Pi(S2, t2, f2, y3) : Ii(S2);
              w2.draw(t2.context, s2, r2, t2.stencilModeForClipping(v3), a2, Ct.disabled, c3, i2.id, x2.layoutVertexBuffer, u2, h3, i2.paint, t2.transform.zoom, b2);
            }
          }
        }
      }
      function ro(t2, e2, i2, o2, r2, a2, n2) {
        for (var s2 = t2.context, l2 = s2.gl, c3 = i2.paint.get("fill-extrusion-pattern"), u2 = c3.constantOr(1), h3 = i2.getCrossfadeParameters(), p3 = i2.paint.get("fill-extrusion-opacity"), d2 = 0, _24 = o2; d2 < _24.length; d2 += 1) {
          var f2 = _24[d2], m2 = e2.getTile(f2), g2 = m2.getBucket(i2);
          if (g2) {
            var v3 = g2.programConfigurations.get(i2.id), y3 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", v3);
            u2 && (t2.context.activeTexture.set(l2.TEXTURE0), m2.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v3.updatePaintBuffers(h3));
            var x2 = c3.constantOr(null);
            if (x2 && m2.imageAtlas) {
              var b2 = m2.imageAtlas, w2 = b2.patternPositions[x2.to.toString()], T2 = b2.patternPositions[x2.from.toString()];
              w2 && T2 && v3.setConstantPatternPositions(w2, T2);
            }
            var E2 = t2.translatePosMatrix(f2.posMatrix, m2, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), I3 = i2.paint.get("fill-extrusion-vertical-gradient"), P2 = u2 ? Ei(E2, t2, I3, p3, f2, h3, m2) : Ti(E2, t2, I3, p3);
            y3.draw(s2, s2.gl.TRIANGLES, r2, a2, n2, Ct.backCCW, P2, i2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, i2.paint, t2.transform.zoom, v3);
          }
        }
      }
      function ao(e2, i2, o2, r2, a2, n2) {
        var s2 = e2.context, l2 = s2.gl, c3 = i2.fbo;
        if (c3) {
          var u2 = e2.useProgram("hillshade");
          s2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c3.colorAttachment.get());
          var h3 = function(e3, i3, o3) {
            var r3 = o3.paint.get("hillshade-shadow-color"), a3 = o3.paint.get("hillshade-highlight-color"), n3 = o3.paint.get("hillshade-accent-color"), s3 = o3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === o3.paint.get("hillshade-illumination-anchor") && (s3 -= e3.transform.angle);
            var l3, c4, u3, h4 = !e3.options.moving;
            return { u_matrix: e3.transform.calculatePosMatrix(i3.tileID.toUnwrapped(), h4), u_image: 0, u_latrange: (l3 = i3.tileID, c4 = Math.pow(2, l3.canonical.z), u3 = l3.canonical.y, [new t.MercatorCoordinate(0, u3 / c4).toLngLat().lat, new t.MercatorCoordinate(0, (u3 + 1) / c4).toLngLat().lat]), u_light: [o3.paint.get("hillshade-exaggeration"), s3], u_shadow: r3, u_highlight: a3, u_accent: n3 };
          }(e2, i2, o2);
          u2.draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, h3, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments);
        }
      }
      function no(e2, i2, o2, r2, a2, n2) {
        var s2 = e2.context, l2 = s2.gl, c3 = i2.dem;
        if (c3 && c3.data) {
          var u2 = c3.dim, h3 = c3.stride, p3 = c3.getPixels();
          if (s2.activeTexture.set(l2.TEXTURE1), s2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e2.getTileTexture(h3), i2.demTexture) {
            var d2 = i2.demTexture;
            d2.update(p3, { premultiply: false }), d2.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          } else
            i2.demTexture = new t.Texture(s2, p3, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          s2.activeTexture.set(l2.TEXTURE0);
          var _24 = i2.fbo;
          if (!_24) {
            var f2 = new t.Texture(s2, { width: u2, height: u2, data: null }, l2.RGBA);
            f2.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), (_24 = i2.fbo = s2.createFramebuffer(u2, u2, true)).colorAttachment.set(f2.texture);
          }
          s2.bindFramebuffer.set(_24.framebuffer), s2.viewport.set([0, 0, u2, u2]), e2.useProgram("hillshadePrepare").draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, function(e3, i3) {
            var o3 = i3.stride, r3 = t.create();
            return t.ortho(r3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r3, r3, [0, -t.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i3.getUnpackVector() };
          }(i2.tileID, c3), o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
        }
      }
      function so(e2, i2, o2, r2, a2) {
        var n2 = r2.paint.get("raster-fade-duration");
        if (n2 > 0) {
          var s2 = t.browser.now(), l2 = (s2 - e2.timeAdded) / n2, c3 = i2 ? (s2 - i2.timeAdded) / n2 : -1, u2 = o2.getSource(), h3 = a2.coveringZoomLevel({ tileSize: u2.tileSize, roundZoom: u2.roundZoom }), p3 = !i2 || Math.abs(i2.tileID.overscaledZ - h3) > Math.abs(e2.tileID.overscaledZ - h3), d2 = p3 && e2.refreshedUponExpiration ? 1 : t.clamp(p3 ? l2 : 1 - c3, 0, 1);
          return e2.refreshedUponExpiration && l2 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      var lo = new t.Color(1, 0, 0, 1), co = new t.Color(0, 1, 0, 1), uo = new t.Color(0, 0, 1, 1), ho = new t.Color(1, 0, 1, 1), po = new t.Color(0, 1, 1, 1);
      function _o(t2, e2, i2, o2) {
        mo(t2, 0, e2 + i2 / 2, t2.transform.width, i2, o2);
      }
      function fo(t2, e2, i2, o2) {
        mo(t2, e2 - i2 / 2, 0, i2, t2.transform.height, o2);
      }
      function mo(e2, i2, o2, r2, a2, n2) {
        var s2 = e2.context, l2 = s2.gl;
        l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * t.browser.devicePixelRatio, o2 * t.browser.devicePixelRatio, r2 * t.browser.devicePixelRatio, a2 * t.browser.devicePixelRatio), s2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
      }
      function go(e2, i2, o2) {
        var r2 = e2.context, a2 = r2.gl, n2 = o2.posMatrix, s2 = e2.useProgram("debug"), l2 = It.disabled, c3 = Pt.disabled, u2 = e2.colorModeForRenderPass();
        r2.activeTexture.set(a2.TEXTURE0), e2.emptyTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), s2.draw(r2, a2.LINE_STRIP, l2, c3, u2, Ct.disabled, Mi(n2, t.Color.red), "$debug", e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
        var h3 = i2.getTileByID(o2.key).latestRawTileData, p3 = Math.floor((h3 && h3.byteLength || 0) / 1024), d2 = i2.getTile(o2).tileSize, _24 = 512 / Math.min(d2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5, f2 = o2.canonical.toString();
        o2.overscaledZ !== o2.canonical.z && (f2 += " => " + o2.overscaledZ), function(t2, e3) {
          t2.initDebugOverlayCanvas();
          var i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, r3 = t2.debugOverlayCanvas.getContext("2d");
          r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(e3, 5, 5), r3.strokeText(e3, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        }(e2, f2 + " " + p3 + "kb"), s2.draw(r2, a2.TRIANGLES, l2, c3, St.alphaBlended, Ct.disabled, Mi(n2, t.Color.transparent, _24), "$debug", e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments);
      }
      var vo = { symbol: function(e2, i2, o2, r2, a2) {
        if ("translucent" === e2.renderPass) {
          var n2 = Pt.disabled, s2 = e2.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(e3, i3, o3, r3, a3, n3, s3) {
            for (var l2 = i3.transform, c3 = "map" === a3, u2 = "map" === n3, h3 = 0, p3 = e3; h3 < p3.length; h3 += 1) {
              var d2 = p3[h3], _24 = r3.getTile(d2), f2 = _24.getBucket(o3);
              if (f2 && f2.text && f2.text.segments.get().length) {
                var m2 = t.evaluateSizeForZoom(f2.textSizeData, l2.zoom), g2 = pe(_24, 1, i3.transform.zoom), v3 = Jt(d2.posMatrix, u2, c3, i3.transform, g2), y3 = "none" !== o3.layout.get("icon-text-fit") && f2.hasIconData();
                if (m2) {
                  var x2 = Math.pow(2, l2.zoom - _24.tileID.overscaledZ);
                  $i(f2, c3, u2, s3, t.symbolSize, l2, v3, d2.posMatrix, x2, m2, y3);
                }
              }
            }
          }(r2, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), a2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && eo(e2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), n2, s2), 0 !== o2.paint.get("text-opacity").constantOr(1) && eo(e2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), n2, s2), i2.map.showCollisionBoxes && (Yi(e2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Yi(e2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }
      }, circle: function(e2, i2, o2, r2) {
        if ("translucent" === e2.renderPass) {
          var a2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
          if (0 !== a2.constantOr(1) || 0 !== n2.constantOr(1) && 0 !== s2.constantOr(1)) {
            for (var c3 = e2.context, u2 = c3.gl, h3 = e2.depthModeForSublayer(0, It.ReadOnly), p3 = Pt.disabled, d2 = e2.colorModeForRenderPass(), _24 = [], f2 = 0; f2 < r2.length; f2++) {
              var m2 = r2[f2], g2 = i2.getTile(m2), v3 = g2.getBucket(o2);
              if (v3) {
                var y3 = v3.programConfigurations.get(o2.id), x2 = { programConfiguration: y3, program: e2.useProgram("circle", y3), layoutVertexBuffer: v3.layoutVertexBuffer, indexBuffer: v3.indexBuffer, uniformValues: zi(e2, m2, g2, o2) };
                if (l2)
                  for (var b2 = 0, w2 = v3.segments.get(); b2 < w2.length; b2 += 1) {
                    var T2 = w2[b2];
                    _24.push({ segments: new t.SegmentVector([T2]), sortKey: T2.sortKey, state: x2 });
                  }
                else
                  _24.push({ segments: v3.segments, sortKey: 0, state: x2 });
              }
            }
            l2 && _24.sort(function(t2, e3) {
              return t2.sortKey - e3.sortKey;
            });
            for (var E2 = 0, I3 = _24; E2 < I3.length; E2 += 1) {
              var P2 = I3[E2], S2 = P2.state;
              S2.program.draw(c3, u2.TRIANGLES, h3, p3, d2, Ct.disabled, S2.uniformValues, o2.id, S2.layoutVertexBuffer, S2.indexBuffer, P2.segments, o2.paint, e2.transform.zoom, S2.programConfiguration);
            }
          }
        }
      }, heatmap: function(e2, i2, o2, r2) {
        if (0 !== o2.paint.get("heatmap-opacity"))
          if ("offscreen" === e2.renderPass) {
            var a2 = e2.context, n2 = a2.gl, s2 = Pt.disabled, l2 = new St([n2.ONE, n2.ONE], t.Color.transparent, [true, true, true, true]);
            !function(t2, e3, i3) {
              var o3 = t2.gl;
              t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
              var r3 = i3.heatmapFbo;
              if (r3)
                o3.bindTexture(o3.TEXTURE_2D, r3.colorAttachment.get()), t2.bindFramebuffer.set(r3.framebuffer);
              else {
                var a3 = o3.createTexture();
                o3.bindTexture(o3.TEXTURE_2D, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r3 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4, false), function(t3, e4, i4, o4) {
                  var r4 = t3.gl;
                  r4.texImage2D(r4.TEXTURE_2D, 0, r4.RGBA, e4.width / 4, e4.height / 4, 0, r4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : r4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(t2, e3, a3, r3);
              }
            }(a2, e2, o2), a2.clear({ color: t.Color.transparent });
            for (var c3 = 0; c3 < r2.length; c3++) {
              var u2 = r2[c3];
              if (!i2.hasRenderableParent(u2)) {
                var h3 = i2.getTile(u2), p3 = h3.getBucket(o2);
                if (p3) {
                  var d2 = p3.programConfigurations.get(o2.id);
                  e2.useProgram("heatmap", d2).draw(a2, n2.TRIANGLES, It.disabled, s2, l2, Ct.disabled, Ri(u2.posMatrix, h3, e2.transform.zoom, o2.paint.get("heatmap-intensity")), o2.id, p3.layoutVertexBuffer, p3.indexBuffer, p3.segments, o2.paint, e2.transform.zoom, d2);
                }
              }
            }
            a2.viewport.set([0, 0, e2.width, e2.height]);
          } else
            "translucent" === e2.renderPass && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
              var o3 = e3.context, r3 = o3.gl, a3 = i3.heatmapFbo;
              if (a3) {
                o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                var n3 = i3.colorRampTexture;
                n3 || (n3 = i3.colorRampTexture = new t.Texture(o3, i3.colorRamp, r3.RGBA)), n3.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, It.disabled, Pt.disabled, e3.colorModeForRenderPass(), Ct.disabled, function(e4, i4, o4, r4) {
                  var a4 = t.create();
                  t.ortho(a4, 0, e4.width, e4.height, 0, 0, 1);
                  var n4 = e4.context.gl;
                  return { u_matrix: a4, u_world: [n4.drawingBufferWidth, n4.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                }(e3, i3), i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
              }
            }(e2, o2));
      }, line: function(e2, i2, o2, r2) {
        if ("translucent" === e2.renderPass) {
          var a2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
          if (0 !== a2.constantOr(1) && 0 !== n2.constantOr(1))
            for (var s2 = e2.depthModeForSublayer(0, It.ReadOnly), l2 = e2.colorModeForRenderPass(), c3 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), h3 = u2.constantOr(1), p3 = o2.paint.get("line-gradient"), d2 = o2.getCrossfadeParameters(), _24 = h3 ? "linePattern" : c3 ? "lineSDF" : p3 ? "lineGradient" : "line", f2 = e2.context, m2 = f2.gl, g2 = true, v3 = 0, y3 = r2; v3 < y3.length; v3 += 1) {
              var x2 = y3[v3], b2 = i2.getTile(x2);
              if (!h3 || b2.patternsLoaded()) {
                var w2 = b2.getBucket(o2);
                if (w2) {
                  var T2 = w2.programConfigurations.get(o2.id), E2 = e2.context.program.get(), I3 = e2.useProgram(_24, T2), P2 = g2 || I3.program !== E2, S2 = u2.constantOr(null);
                  if (S2 && b2.imageAtlas) {
                    var C2 = b2.imageAtlas, z2 = C2.patternPositions[S2.to.toString()], D2 = C2.patternPositions[S2.from.toString()];
                    z2 && D2 && T2.setConstantPatternPositions(z2, D2);
                  }
                  var A3 = h3 ? Oi(e2, b2, o2, d2) : c3 ? Fi(e2, b2, o2, c3, d2) : p3 ? Bi(e2, b2, o2, w2.lineClipsArray.length) : ki(e2, b2, o2);
                  if (h3)
                    f2.activeTexture.set(m2.TEXTURE0), b2.imageAtlasTexture.bind(m2.LINEAR, m2.CLAMP_TO_EDGE), T2.updatePaintBuffers(d2);
                  else if (c3 && (P2 || e2.lineAtlas.dirty))
                    f2.activeTexture.set(m2.TEXTURE0), e2.lineAtlas.bind(f2);
                  else if (p3) {
                    var M2 = w2.gradients[o2.id], L2 = M2.texture;
                    if (o2.gradientVersion !== M2.version) {
                      var R2 = 256;
                      if (o2.stepInterpolant) {
                        var k2 = i2.getSource().maxzoom, B2 = x2.canonical.z === k2 ? Math.ceil(1 << e2.transform.maxZoom - x2.canonical.z) : 1;
                        R2 = t.clamp(t.nextPowerOfTwo(w2.maxLineLength / t.EXTENT * 1024 * B2), 256, f2.maxTextureSize);
                      }
                      M2.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: R2, image: M2.gradient || void 0, clips: w2.lineClipsArray }), M2.texture ? M2.texture.update(M2.gradient) : M2.texture = new t.Texture(f2, M2.gradient, m2.RGBA), M2.version = o2.gradientVersion, L2 = M2.texture;
                    }
                    f2.activeTexture.set(m2.TEXTURE0), L2.bind(o2.stepInterpolant ? m2.NEAREST : m2.LINEAR, m2.CLAMP_TO_EDGE);
                  }
                  I3.draw(f2, m2.TRIANGLES, s2, e2.stencilModeForClipping(x2), l2, Ct.disabled, A3, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, e2.transform.zoom, T2, w2.layoutVertexBuffer2), g2 = false;
                }
              }
            }
        }
      }, fill: function(e2, i2, o2, r2) {
        var a2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
        if (0 !== n2.constantOr(1)) {
          var s2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c3 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === a2.constantOr(t.Color.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
          if (e2.renderPass === c3) {
            var u2 = e2.depthModeForSublayer(1, "opaque" === e2.renderPass ? It.ReadWrite : It.ReadOnly);
            oo(e2, i2, o2, r2, u2, s2, false);
          }
          if ("translucent" === e2.renderPass && o2.paint.get("fill-antialias")) {
            var h3 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);
            oo(e2, i2, o2, r2, h3, s2, true);
          }
        }
      }, "fill-extrusion": function(t2, e2, i2, o2) {
        var r2 = i2.paint.get("fill-extrusion-opacity");
        if (0 !== r2 && "translucent" === t2.renderPass) {
          var a2 = new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D);
          if (1 !== r2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
            ro(t2, e2, i2, o2, a2, Pt.disabled, St.disabled), ro(t2, e2, i2, o2, a2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
          else {
            var n2 = t2.colorModeForRenderPass();
            ro(t2, e2, i2, o2, a2, Pt.disabled, n2);
          }
        }
      }, hillshade: function(t2, e2, i2, o2) {
        if ("offscreen" === t2.renderPass || "translucent" === t2.renderPass) {
          for (var r2 = t2.context, a2 = t2.depthModeForSublayer(0, It.ReadOnly), n2 = t2.colorModeForRenderPass(), s2 = "translucent" === t2.renderPass ? t2.stencilConfigForOverlap(o2) : [{}, o2], l2 = s2[0], c3 = 0, u2 = s2[1]; c3 < u2.length; c3 += 1) {
            var h3 = u2[c3], p3 = e2.getTile(h3);
            p3.needsHillshadePrepare && "offscreen" === t2.renderPass ? no(t2, p3, i2, a2, Pt.disabled, n2) : "translucent" === t2.renderPass && ao(t2, p3, i2, a2, l2[h3.overscaledZ], n2);
          }
          r2.viewport.set([0, 0, t2.width, t2.height]);
        }
      }, raster: function(t2, e2, i2, o2) {
        if ("translucent" === t2.renderPass && 0 !== i2.paint.get("raster-opacity") && o2.length)
          for (var r2 = t2.context, a2 = r2.gl, n2 = e2.getSource(), s2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), c3 = n2 instanceof M ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = c3[0], h3 = c3[1], p3 = h3[h3.length - 1].overscaledZ, d2 = !t2.options.moving, _24 = 0, f2 = h3; _24 < f2.length; _24 += 1) {
            var m2 = f2[_24], g2 = t2.depthModeForSublayer(m2.overscaledZ - p3, 1 === i2.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a2.LESS), v3 = e2.getTile(m2), y3 = t2.transform.calculatePosMatrix(m2.toUnwrapped(), d2);
            v3.registerFadeDuration(i2.paint.get("raster-fade-duration"));
            var x2 = e2.findLoadedParent(m2, 0), b2 = so(v3, x2, e2, i2, t2.transform), w2 = void 0, T2 = void 0, E2 = "nearest" === i2.paint.get("raster-resampling") ? a2.NEAREST : a2.LINEAR;
            r2.activeTexture.set(a2.TEXTURE0), v3.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), r2.activeTexture.set(a2.TEXTURE1), x2 ? (x2.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), w2 = Math.pow(2, x2.tileID.overscaledZ - v3.tileID.overscaledZ), T2 = [v3.tileID.canonical.x * w2 % 1, v3.tileID.canonical.y * w2 % 1]) : v3.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
            var I3 = Zi(y3, T2 || [0, 0], w2 || 1, b2, i2);
            n2 instanceof M ? s2.draw(r2, a2.TRIANGLES, g2, Pt.disabled, l2, Ct.disabled, I3, i2.id, n2.boundsBuffer, t2.quadTriangleIndexBuffer, n2.boundsSegments) : s2.draw(r2, a2.TRIANGLES, g2, u2[m2.overscaledZ], l2, Ct.disabled, I3, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
      }, background: function(t2, e2, i2) {
        var o2 = i2.paint.get("background-color"), r2 = i2.paint.get("background-opacity");
        if (0 !== r2) {
          var a2 = t2.context, n2 = a2.gl, s2 = t2.transform, l2 = s2.tileSize, c3 = i2.paint.get("background-pattern");
          if (!t2.isPatternMissing(c3)) {
            var u2 = !c3 && 1 === o2.a && 1 === r2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass === u2) {
              var h3 = Pt.disabled, p3 = t2.depthModeForSublayer(0, "opaque" === u2 ? It.ReadWrite : It.ReadOnly), d2 = t2.colorModeForRenderPass(), _24 = t2.useProgram(c3 ? "backgroundPattern" : "background"), f2 = s2.coveringTiles({ tileSize: l2 });
              c3 && (a2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
              for (var m2 = i2.getCrossfadeParameters(), g2 = 0, v3 = f2; g2 < v3.length; g2 += 1) {
                var y3 = v3[g2], x2 = t2.transform.calculatePosMatrix(y3.toUnwrapped()), b2 = c3 ? Hi(x2, r2, t2, c3, { tileID: y3, tileSize: l2 }, m2) : Xi(x2, r2, o2);
                _24.draw(a2, n2.TRIANGLES, p3, h3, d2, Ct.disabled, b2, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
              }
            }
          }
        }
      }, debug: function(t2, e2, i2) {
        for (var o2 = 0; o2 < i2.length; o2++)
          go(t2, e2, i2[o2]);
      }, custom: function(t2, e2, i2) {
        var o2 = t2.context, r2 = i2.implementation;
        if ("offscreen" === t2.renderPass) {
          var a2 = r2.prerender;
          a2 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), a2.call(r2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
        } else if ("translucent" === t2.renderPass) {
          t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Pt.disabled);
          var n2 = "3d" === r2.renderingMode ? new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, It.ReadOnly);
          o2.setDepthMode(n2), r2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
        }
      } }, yo = function(t2, e2) {
        this.context = new zt(t2), this.transform = e2, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};
      };
      yo.prototype.resize = function(e2, i2) {
        if (this.width = e2 * t.browser.devicePixelRatio, this.height = i2 * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
          for (var o2 = 0, r2 = this.style._order; o2 < r2.length; o2 += 1)
            this.style._layers[r2[o2]].resize();
      }, yo.prototype.setup = function() {
        var e2 = this.context, i2 = new t.StructArrayLayout2i4();
        i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
        var o2 = new t.StructArrayLayout2i4();
        o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
        var r2 = new t.StructArrayLayout4i8();
        r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, A2.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
        var a2 = new t.StructArrayLayout2i4();
        a2.emplaceBack(0, 0), a2.emplaceBack(1, 0), a2.emplaceBack(0, 1), a2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(a2, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
        var n2 = new t.StructArrayLayout1ui2();
        n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
        var s2 = new t.StructArrayLayout3ui6();
        s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(s2), this.emptyTexture = new t.Texture(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA);
        var l2 = this.context.gl;
        this.stencilClearMode = new Pt({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
      }, yo.prototype.clearStencil = function() {
        var e2 = this.context, i2 = e2.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0;
        var o2 = t.create();
        t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o2), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }, yo.prototype._renderTileClippingMasks = function(t2, e2) {
        if (this.currentStencilSource !== t2.source && t2.isTileClipped() && e2 && e2.length) {
          this.currentStencilSource = t2.source;
          var i2 = this.context, o2 = i2.gl;
          this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(St.disabled), i2.setDepthMode(It.disabled);
          var r2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (var a2 = 0, n2 = e2; a2 < n2.length; a2 += 1) {
            var s2 = n2[a2], l2 = this._tileClippingMaskIDs[s2.key] = this.nextStencilID++;
            r2.draw(i2, o2.TRIANGLES, It.disabled, new Pt({ func: o2.ALWAYS, mask: 0 }, l2, 255, o2.KEEP, o2.KEEP, o2.REPLACE), St.disabled, Ct.disabled, Li(s2.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
      }, yo.prototype.stencilModeFor3D = function() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        var t2 = this.nextStencilID++, e2 = this.context.gl;
        return new Pt({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
      }, yo.prototype.stencilModeForClipping = function(t2) {
        var e2 = this.context.gl;
        return new Pt({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
      }, yo.prototype.stencilConfigForOverlap = function(t2) {
        var e2, i2 = this.context.gl, o2 = t2.sort(function(t3, e3) {
          return e3.overscaledZ - t3.overscaledZ;
        }), r2 = o2[o2.length - 1].overscaledZ, a2 = o2[0].overscaledZ - r2 + 1;
        if (a2 > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
          for (var n2 = {}, s2 = 0; s2 < a2; s2++)
            n2[s2 + r2] = new Pt({ func: i2.GEQUAL, mask: 255 }, s2 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
          return this.nextStencilID += a2, [n2, o2];
        }
        return [(e2 = {}, e2[r2] = Pt.disabled, e2), o2];
      }, yo.prototype.colorModeForRenderPass = function() {
        var e2 = this.context.gl;
        return this._showOverdrawInspector ? new St([e2.CONSTANT_COLOR, e2.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [true, true, true, true]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;
      }, yo.prototype.depthModeForSublayer = function(t2, e2, i2) {
        if (!this.opaquePassEnabledForLayer())
          return It.disabled;
        var o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
        return new It(i2 || this.context.gl.LEQUAL, e2, [o2, o2]);
      }, yo.prototype.opaquePassEnabledForLayer = function() {
        return this.currentLayer < this.opaquePassCutoff;
      }, yo.prototype.render = function(e2, i2) {
        var o2 = this;
        this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();
        var r2 = this.style._order, a2 = this.style.sourceCaches;
        for (var n2 in a2) {
          var s2 = a2[n2];
          s2.used && s2.prepare(this.context);
        }
        var l2, c3, u2 = {}, h3 = {}, p3 = {};
        for (var d2 in a2) {
          var _24 = a2[d2];
          u2[d2] = _24.getVisibleCoordinates(), h3[d2] = u2[d2].slice().reverse(), p3[d2] = _24.getVisibleCoordinates(true).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (var f2 = 0; f2 < r2.length; f2++)
          if (this.style._layers[r2[f2]].is3D()) {
            this.opaquePassCutoff = f2;
            break;
          }
        this.renderPass = "offscreen";
        for (var m2 = 0, g2 = r2; m2 < g2.length; m2 += 1) {
          var v3 = this.style._layers[g2[m2]];
          if (v3.hasOffscreenPass() && !v3.isHidden(this.transform.zoom)) {
            var y3 = h3[v3.source];
            ("custom" === v3.type || y3.length) && this.renderLayer(this, a2[v3.source], v3, y3);
          }
        }
        for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          var x2 = this.style._layers[r2[this.currentLayer]], b2 = a2[x2.source], w2 = u2[x2.source];
          this._renderTileClippingMasks(x2, w2), this.renderLayer(this, b2, x2, w2);
        }
        for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
          var T2 = this.style._layers[r2[this.currentLayer]], E2 = a2[T2.source], I3 = ("symbol" === T2.type ? p3 : h3)[T2.source];
          this._renderTileClippingMasks(T2, u2[T2.source]), this.renderLayer(this, E2, T2, I3);
        }
        this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function(t2) {
          t2.source && !t2.isHidden(o2.transform.zoom) && (t2.source !== (c3 && c3.id) && (c3 = o2.style.sourceCaches[t2.source]), (!l2 || l2.getSource().maxzoom < c3.getSource().maxzoom) && (l2 = c3));
        }), l2 && vo.debug(this, l2, l2.getVisibleCoordinates())), this.options.showPadding && function(t2) {
          var e3 = t2.transform.padding;
          _o(t2, t2.transform.height - (e3.top || 0), 3, lo), _o(t2, e3.bottom || 0, 3, co), fo(t2, e3.left || 0, 3, uo), fo(t2, t2.transform.width - (e3.right || 0), 3, ho);
          var i3 = t2.transform.centerPoint;
          !function(t3, e4, i4, o3) {
            mo(t3, e4 - 1, i4 - 10, 2, 20, o3), mo(t3, e4 - 10, i4 - 1, 20, 2, o3);
          }(t2, i3.x, t2.transform.height - i3.y, po);
        }(this), this.context.setDefault();
      }, yo.prototype.renderLayer = function(t2, e2, i2, o2) {
        i2.isHidden(this.transform.zoom) || ("background" === i2.type || "custom" === i2.type || o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), vo[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
      }, yo.prototype.gpuTimingStart = function(t2) {
        if (this.options.gpuTiming) {
          var e2 = this.context.extTimerQuery, i2 = this.gpuTimers[t2.id];
          i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
        }
      }, yo.prototype.gpuTimingEnd = function() {
        if (this.options.gpuTiming) {
          var t2 = this.context.extTimerQuery;
          t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
        }
      }, yo.prototype.collectGpuTimers = function() {
        var t2 = this.gpuTimers;
        return this.gpuTimers = {}, t2;
      }, yo.prototype.queryGpuTimers = function(t2) {
        var e2 = {};
        for (var i2 in t2) {
          var o2 = t2[i2], r2 = this.context.extTimerQuery, a2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
          r2.deleteQueryEXT(o2.query), e2[i2] = a2;
        }
        return e2;
      }, yo.prototype.translatePosMatrix = function(e2, i2, o2, r2, a2) {
        if (!o2[0] && !o2[1])
          return e2;
        var n2 = a2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
        if (n2) {
          var s2 = Math.sin(n2), l2 = Math.cos(n2);
          o2 = [o2[0] * l2 - o2[1] * s2, o2[0] * s2 + o2[1] * l2];
        }
        var c3 = [a2 ? o2[0] : pe(i2, o2[0], this.transform.zoom), a2 ? o2[1] : pe(i2, o2[1], this.transform.zoom), 0], u2 = new Float32Array(16);
        return t.translate(u2, e2, c3), u2;
      }, yo.prototype.saveTileTexture = function(t2) {
        var e2 = this._tileTextures[t2.size[0]];
        e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
      }, yo.prototype.getTileTexture = function(t2) {
        var e2 = this._tileTextures[t2];
        return e2 && e2.length > 0 ? e2.pop() : null;
      }, yo.prototype.isPatternMissing = function(t2) {
        if (!t2)
          return false;
        if (!t2.from || !t2.to)
          return true;
        var e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
        return !e2 || !i2;
      }, yo.prototype.useProgram = function(t2, e2) {
        this.cache = this.cache || {};
        var i2 = "" + t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
        return this.cache[i2] || (this.cache[i2] = new bi(this.context, t2, vi[t2], e2, Ki[t2], this._showOverdrawInspector)), this.cache[i2];
      }, yo.prototype.setCustomLayerDefaults = function() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }, yo.prototype.setBaseState = function() {
        var t2 = this.context.gl;
        this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
      }, yo.prototype.initDebugOverlayCanvas = function() {
        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }, yo.prototype.destroy = function() {
        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      };
      var xo = function(t2, e2) {
        this.points = t2, this.planes = e2;
      };
      xo.fromInvProjectionMatrix = function(e2, i2, o2) {
        var r2 = Math.pow(2, o2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(i3) {
          return t.transformMat4([], i3, e2);
        }).map(function(e3) {
          return t.scale$1([], e3, 1 / e3[3] / i2 * r2);
        }), n2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(e3) {
          var i3 = t.sub([], a2[e3[0]], a2[e3[1]]), o3 = t.sub([], a2[e3[2]], a2[e3[1]]), r3 = t.normalize([], t.cross([], i3, o3)), n3 = -t.dot(r3, a2[e3[1]]);
          return r3.concat(n3);
        });
        return new xo(a2, n2);
      };
      var bo = function(e2, i2) {
        this.min = e2, this.max = i2, this.center = t.scale$2([], t.add([], this.min, this.max), 0.5);
      };
      bo.prototype.quadrant = function(e2) {
        for (var i2 = [e2 % 2 == 0, e2 < 2], o2 = t.clone$2(this.min), r2 = t.clone$2(this.max), a2 = 0; a2 < i2.length; a2++)
          o2[a2] = i2[a2] ? this.min[a2] : this.center[a2], r2[a2] = i2[a2] ? this.center[a2] : this.max[a2];
        return r2[2] = this.max[2], new bo(o2, r2);
      }, bo.prototype.distanceX = function(t2) {
        return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
      }, bo.prototype.distanceY = function(t2) {
        return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
      }, bo.prototype.intersects = function(e2) {
        for (var i2 = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o2 = true, r2 = 0; r2 < e2.planes.length; r2++) {
          for (var a2 = e2.planes[r2], n2 = 0, s2 = 0; s2 < i2.length; s2++)
            n2 += t.dot$1(a2, i2[s2]) >= 0;
          if (0 === n2)
            return 0;
          n2 !== i2.length && (o2 = false);
        }
        if (o2)
          return 2;
        for (var l2 = 0; l2 < 3; l2++) {
          for (var c3 = Number.MAX_VALUE, u2 = -Number.MAX_VALUE, h3 = 0; h3 < e2.points.length; h3++) {
            var p3 = e2.points[h3][l2] - this.min[l2];
            c3 = Math.min(c3, p3), u2 = Math.max(u2, p3);
          }
          if (u2 < 0 || c3 > this.max[l2] - this.min[l2])
            return 0;
        }
        return 1;
      };
      var wo = function(t2, e2, i2, o2) {
        if (void 0 === t2 && (t2 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === o2 && (o2 = 0), isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
          throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = t2, this.bottom = e2, this.left = i2, this.right = o2;
      };
      wo.prototype.interpolate = function(e2, i2, o2) {
        return null != i2.top && null != e2.top && (this.top = t.number(e2.top, i2.top, o2)), null != i2.bottom && null != e2.bottom && (this.bottom = t.number(e2.bottom, i2.bottom, o2)), null != i2.left && null != e2.left && (this.left = t.number(e2.left, i2.left, o2)), null != i2.right && null != e2.right && (this.right = t.number(e2.right, i2.right, o2)), this;
      }, wo.prototype.getCenter = function(e2, i2) {
        var o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), r2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
        return new t.Point(o2, r2);
      }, wo.prototype.equals = function(t2) {
        return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
      }, wo.prototype.clone = function() {
        return new wo(this.top, this.bottom, this.left, this.right);
      }, wo.prototype.toJSON = function() {
        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
      };
      var To = function(e2, i2, o2, r2, a2) {
        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a2 || a2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
      }, Eo = { minZoom: { configurable: true }, maxZoom: { configurable: true }, minPitch: { configurable: true }, maxPitch: { configurable: true }, renderWorldCopies: { configurable: true }, worldSize: { configurable: true }, centerOffset: { configurable: true }, size: { configurable: true }, bearing: { configurable: true }, pitch: { configurable: true }, fov: { configurable: true }, zoom: { configurable: true }, center: { configurable: true }, padding: { configurable: true }, centerPoint: { configurable: true }, unmodified: { configurable: true }, point: { configurable: true } };
      To.prototype.clone = function() {
        var t2 = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
        return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
      }, Eo.minZoom.get = function() {
        return this._minZoom;
      }, Eo.minZoom.set = function(t2) {
        this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
      }, Eo.maxZoom.get = function() {
        return this._maxZoom;
      }, Eo.maxZoom.set = function(t2) {
        this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
      }, Eo.minPitch.get = function() {
        return this._minPitch;
      }, Eo.minPitch.set = function(t2) {
        this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
      }, Eo.maxPitch.get = function() {
        return this._maxPitch;
      }, Eo.maxPitch.set = function(t2) {
        this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
      }, Eo.renderWorldCopies.get = function() {
        return this._renderWorldCopies;
      }, Eo.renderWorldCopies.set = function(t2) {
        void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
      }, Eo.worldSize.get = function() {
        return this.tileSize * this.scale;
      }, Eo.centerOffset.get = function() {
        return this.centerPoint._sub(this.size._div(2));
      }, Eo.size.get = function() {
        return new t.Point(this.width, this.height);
      }, Eo.bearing.get = function() {
        return -this.angle / Math.PI * 180;
      }, Eo.bearing.set = function(e2) {
        var i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
        this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
      }, Eo.pitch.get = function() {
        return this._pitch / Math.PI * 180;
      }, Eo.pitch.set = function(e2) {
        var i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
      }, Eo.fov.get = function() {
        return this._fov / Math.PI * 180;
      }, Eo.fov.set = function(t2) {
        t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
      }, Eo.zoom.get = function() {
        return this._zoom;
      }, Eo.zoom.set = function(t2) {
        var e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
        this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
      }, Eo.center.get = function() {
        return this._center;
      }, Eo.center.set = function(t2) {
        t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
      }, Eo.padding.get = function() {
        return this._edgeInsets.toJSON();
      }, Eo.padding.set = function(t2) {
        this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
      }, Eo.centerPoint.get = function() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }, To.prototype.isPaddingEqual = function(t2) {
        return this._edgeInsets.equals(t2);
      }, To.prototype.interpolatePadding = function(t2, e2, i2) {
        this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
      }, To.prototype.coveringZoomLevel = function(t2) {
        var e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
        return Math.max(0, e2);
      }, To.prototype.getVisibleUnwrappedCoordinates = function(e2) {
        var i2 = [new t.UnwrappedTileID(0, e2)];
        if (this._renderWorldCopies)
          for (var o2 = this.pointCoordinate(new t.Point(0, 0)), r2 = this.pointCoordinate(new t.Point(this.width, 0)), a2 = this.pointCoordinate(new t.Point(this.width, this.height)), n2 = this.pointCoordinate(new t.Point(0, this.height)), s2 = Math.floor(Math.min(o2.x, r2.x, a2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, a2.x, n2.x)), c3 = s2 - 1; c3 <= l2 + 1; c3++)
            0 !== c3 && i2.push(new t.UnwrappedTileID(c3, e2));
        return i2;
      }, To.prototype.coveringTiles = function(e2) {
        var i2 = this.coveringZoomLevel(e2), o2 = i2;
        if (void 0 !== e2.minzoom && i2 < e2.minzoom)
          return [];
        void 0 !== e2.maxzoom && i2 > e2.maxzoom && (i2 = e2.maxzoom);
        var r2 = t.MercatorCoordinate.fromLngLat(this.center), a2 = Math.pow(2, i2), n2 = [a2 * r2.x, a2 * r2.y, 0], s2 = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2), l2 = e2.minzoom || 0;
        this.pitch <= 60 && this._edgeInsets.top < 0.1 && (l2 = i2);
        var c3 = function(t2) {
          return { aabb: new bo([t2 * a2, 0, 0], [(t2 + 1) * a2, a2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false };
        }, u2 = [], h3 = [], p3 = i2, d2 = e2.reparseOverscaled ? o2 : i2;
        if (this._renderWorldCopies)
          for (var _24 = 1; _24 <= 3; _24++)
            u2.push(c3(-_24)), u2.push(c3(_24));
        for (u2.push(c3(0)); u2.length > 0; ) {
          var f2 = u2.pop(), m2 = f2.x, g2 = f2.y, v3 = f2.fullyVisible;
          if (!v3) {
            var y3 = f2.aabb.intersects(s2);
            if (0 === y3)
              continue;
            v3 = 2 === y3;
          }
          var x2 = f2.aabb.distanceX(n2), b2 = f2.aabb.distanceY(n2), w2 = Math.max(Math.abs(x2), Math.abs(b2));
          if (f2.zoom === p3 || w2 > 3 + (1 << p3 - f2.zoom) - 2 && f2.zoom >= l2)
            h3.push({ tileID: new t.OverscaledTileID(f2.zoom === p3 ? d2 : f2.zoom, f2.wrap, f2.zoom, m2, g2), distanceSq: t.sqrLen([n2[0] - 0.5 - m2, n2[1] - 0.5 - g2]) });
          else
            for (var T2 = 0; T2 < 4; T2++) {
              var E2 = (m2 << 1) + T2 % 2, I3 = (g2 << 1) + (T2 >> 1);
              u2.push({ aabb: f2.aabb.quadrant(T2), zoom: f2.zoom + 1, x: E2, y: I3, wrap: f2.wrap, fullyVisible: v3 });
            }
        }
        return h3.sort(function(t2, e3) {
          return t2.distanceSq - e3.distanceSq;
        }).map(function(t2) {
          return t2.tileID;
        });
      }, To.prototype.resize = function(t2, e2) {
        this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
      }, Eo.unmodified.get = function() {
        return this._unmodified;
      }, To.prototype.zoomScale = function(t2) {
        return Math.pow(2, t2);
      }, To.prototype.scaleZoom = function(t2) {
        return Math.log(t2) / Math.LN2;
      }, To.prototype.project = function(e2) {
        var i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
        return new t.Point(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
      }, To.prototype.unproject = function(e2) {
        return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
      }, Eo.point.get = function() {
        return this.project(this.center);
      }, To.prototype.setLocationAtPoint = function(e2, i2) {
        var o2 = this.pointCoordinate(i2), r2 = this.pointCoordinate(this.centerPoint), a2 = this.locationCoordinate(e2), n2 = new t.MercatorCoordinate(a2.x - (o2.x - r2.x), a2.y - (o2.y - r2.y));
        this.center = this.coordinateLocation(n2), this._renderWorldCopies && (this.center = this.center.wrap());
      }, To.prototype.locationPoint = function(t2) {
        return this.coordinatePoint(this.locationCoordinate(t2));
      }, To.prototype.pointLocation = function(t2) {
        return this.coordinateLocation(this.pointCoordinate(t2));
      }, To.prototype.locationCoordinate = function(e2) {
        return t.MercatorCoordinate.fromLngLat(e2);
      }, To.prototype.coordinateLocation = function(t2) {
        return t2.toLngLat();
      }, To.prototype.pointCoordinate = function(e2) {
        var i2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
        t.transformMat4(i2, i2, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse);
        var r2 = i2[3], a2 = o2[3], n2 = i2[1] / r2, s2 = o2[1] / a2, l2 = i2[2] / r2, c3 = o2[2] / a2, u2 = l2 === c3 ? 0 : (0 - l2) / (c3 - l2);
        return new t.MercatorCoordinate(t.number(i2[0] / r2, o2[0] / a2, u2) / this.worldSize, t.number(n2, s2, u2) / this.worldSize);
      }, To.prototype.coordinatePoint = function(e2) {
        var i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
        return t.transformMat4(i2, i2, this.pixelMatrix), new t.Point(i2[0] / i2[3], i2[1] / i2[3]);
      }, To.prototype.getBounds = function() {
        return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));
      }, To.prototype.getMaxBounds = function() {
        return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
      }, To.prototype.setMaxBounds = function(t2) {
        t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
      }, To.prototype.calculatePosMatrix = function(e2, i2) {
        void 0 === i2 && (i2 = false);
        var o2 = e2.key, r2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
        if (r2[o2])
          return r2[o2];
        var a2 = e2.canonical, n2 = this.worldSize / this.zoomScale(a2.z), s2 = a2.x + Math.pow(2, a2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
        return t.translate(l2, l2, [s2 * n2, a2.y * n2, 0]), t.scale(l2, l2, [n2 / t.EXTENT, n2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), r2[o2] = new Float32Array(l2), r2[o2];
      }, To.prototype.customLayerMatrix = function() {
        return this.mercatorMatrix.slice();
      }, To.prototype._constrain = function() {
        if (this.center && this.width && this.height && !this._constraining) {
          this._constraining = true;
          var e2, i2, o2, r2, a2 = -90, n2 = 90, s2 = -180, l2 = 180, c3 = this.size, u2 = this._unmodified;
          if (this.latRange) {
            var h3 = this.latRange;
            a2 = t.mercatorYfromLat(h3[1]) * this.worldSize, e2 = (n2 = t.mercatorYfromLat(h3[0]) * this.worldSize) - a2 < c3.y ? c3.y / (n2 - a2) : 0;
          }
          if (this.lngRange) {
            var p3 = this.lngRange;
            s2 = t.mercatorXfromLng(p3[0]) * this.worldSize, i2 = (l2 = t.mercatorXfromLng(p3[1]) * this.worldSize) - s2 < c3.x ? c3.x / (l2 - s2) : 0;
          }
          var d2 = this.point, _24 = Math.max(i2 || 0, e2 || 0);
          if (_24)
            return this.center = this.unproject(new t.Point(i2 ? (l2 + s2) / 2 : d2.x, e2 ? (n2 + a2) / 2 : d2.y)), this.zoom += this.scaleZoom(_24), this._unmodified = u2, void (this._constraining = false);
          if (this.latRange) {
            var f2 = d2.y, m2 = c3.y / 2;
            f2 - m2 < a2 && (r2 = a2 + m2), f2 + m2 > n2 && (r2 = n2 - m2);
          }
          if (this.lngRange) {
            var g2 = d2.x, v3 = c3.x / 2;
            g2 - v3 < s2 && (o2 = s2 + v3), g2 + v3 > l2 && (o2 = l2 - v3);
          }
          void 0 === o2 && void 0 === r2 || (this.center = this.unproject(new t.Point(void 0 !== o2 ? o2 : d2.x, void 0 !== r2 ? r2 : d2.y))), this._unmodified = u2, this._constraining = false;
        }
      }, To.prototype._calcMatrices = function() {
        if (this.height) {
          var e2 = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          var i2 = Math.PI / 2 + this._pitch, o2 = this._fov * (0.5 + e2.y / this.height), r2 = Math.sin(o2) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i2 - o2, 0.01, Math.PI - 0.01)), a2 = this.point, n2 = a2.x, s2 = a2.y, l2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r2 + this.cameraToCenterDistance), c3 = this.height / 50, u2 = new Float64Array(16);
          t.perspective(u2, this._fov, this.width / this.height, c3, l2), u2[8] = 2 * -e2.x / this.width, u2[9] = 2 * e2.y / this.height, t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u2, u2, this._pitch), t.rotateZ(u2, u2, this.angle), t.translate(u2, u2, [-n2, -s2, 0]), this.mercatorMatrix = t.scale([], u2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u2, u2, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u2, this.invProjMatrix = t.invert([], this.projMatrix);
          var h3 = this.width % 2 / 2, p3 = this.height % 2 / 2, d2 = Math.cos(this.angle), _24 = Math.sin(this.angle), f2 = n2 - Math.round(n2) + d2 * h3 + _24 * p3, m2 = s2 - Math.round(s2) + d2 * p3 + _24 * h3, g2 = new Float64Array(u2);
          if (t.translate(g2, g2, [f2 > 0.5 ? f2 - 1 : f2, m2 > 0.5 ? m2 - 1 : m2, 0]), this.alignedProjMatrix = g2, u2 = t.create(), t.scale(u2, u2, [this.width / 2, -this.height / 2, 1]), t.translate(u2, u2, [1, -1, 0]), this.labelPlaneMatrix = u2, u2 = t.create(), t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [-1, -1, 0]), t.scale(u2, u2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u2 = t.invert(new Float64Array(16), this.pixelMatrix)))
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = u2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
      }, To.prototype.maxPitchScaleFactor = function() {
        if (!this.pixelMatrixInverse)
          return 1;
        var e2 = this.pointCoordinate(new t.Point(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
        return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
      }, To.prototype.getCameraPoint = function() {
        var e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new t.Point(0, e2));
      }, To.prototype.getCameraQueryGeometry = function(e2) {
        var i2 = this.getCameraPoint();
        if (1 === e2.length)
          return [e2[0], i2];
        for (var o2 = i2.x, r2 = i2.y, a2 = i2.x, n2 = i2.y, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
          var c3 = l2[s2];
          o2 = Math.min(o2, c3.x), r2 = Math.min(r2, c3.y), a2 = Math.max(a2, c3.x), n2 = Math.max(n2, c3.y);
        }
        return [new t.Point(o2, r2), new t.Point(a2, r2), new t.Point(a2, n2), new t.Point(o2, n2), new t.Point(o2, r2)];
      }, Object.defineProperties(To.prototype, Eo);
      var Io = function(e2) {
        var i2, o2, r2, a2;
        this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i2 = this._updateHashUnthrottled.bind(this), o2 = false, r2 = null, a2 = function() {
          r2 = null, o2 && (i2(), r2 = setTimeout(a2, 300), o2 = false);
        }, function() {
          return o2 = true, r2 || a2(), r2;
        });
      };
      Io.prototype.addTo = function(e2) {
        return this._map = e2, t.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
      }, Io.prototype.remove = function() {
        return t.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
      }, Io.prototype.getHashString = function(e2) {
        var i2 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, r2), n2 = Math.round(i2.lng * a2) / a2, s2 = Math.round(i2.lat * a2) / a2, l2 = this._map.getBearing(), c3 = this._map.getPitch(), u2 = "";
        if (u2 += e2 ? "/" + n2 + "/" + s2 + "/" + o2 : o2 + "/" + s2 + "/" + n2, (l2 || c3) && (u2 += "/" + Math.round(10 * l2) / 10), c3 && (u2 += "/" + Math.round(c3)), this._hashName) {
          var h3 = this._hashName, p3 = false, d2 = t.window.location.hash.slice(1).split("&").map(function(t2) {
            var e3 = t2.split("=")[0];
            return e3 === h3 ? (p3 = true, e3 + "=" + u2) : t2;
          }).filter(function(t2) {
            return t2;
          });
          return p3 || d2.push(h3 + "=" + u2), "#" + d2.join("&");
        }
        return "#" + u2;
      }, Io.prototype._getCurrentHash = function() {
        var e2, i2 = this, o2 = t.window.location.hash.replace("#", "");
        return this._hashName ? (o2.split("&").map(function(t2) {
          return t2.split("=");
        }).forEach(function(t2) {
          t2[0] === i2._hashName && (e2 = t2);
        }), (e2 && e2[1] || "").split("/")) : o2.split("/");
      }, Io.prototype._onHashChange = function() {
        var t2 = this._getCurrentHash();
        if (t2.length >= 3 && !t2.some(function(t3) {
          return isNaN(t3);
        })) {
          var e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
          return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e2, pitch: +(t2[4] || 0) }), true;
        }
        return false;
      }, Io.prototype._updateHashUnthrottled = function() {
        var e2 = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
        try {
          t.window.history.replaceState(t.window.history.state, null, e2);
        } catch (t2) {
        }
      };
      var Po = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, So = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Po), Co = t.extend({ deceleration: 20, maxSpeed: 1400 }, Po), zo = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Po), Do = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Po), Ao = function(t2) {
        this._map = t2, this.clear();
      };
      function Mo(t2, e2) {
        (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
      }
      function Lo(e2, i2, o2) {
        var r2 = o2.maxSpeed, a2 = o2.linearity, n2 = o2.deceleration, s2 = t.clamp(e2 * a2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(s2) / (n2 * a2);
        return { easing: o2.easing, duration: 1e3 * l2, amount: s2 * (l2 / 2) };
      }
      Ao.prototype.clear = function() {
        this._inertiaBuffer = [];
      }, Ao.prototype.record = function(e2) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.browser.now(), settings: e2 });
      }, Ao.prototype._drainInertiaBuffer = function() {
        for (var e2 = this._inertiaBuffer, i2 = t.browser.now(); e2.length > 0 && i2 - e2[0].time > 160; )
          e2.shift();
      }, Ao.prototype._onMoveEnd = function(e2) {
        if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
          for (var i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.Point(0, 0), pinchAround: void 0, around: void 0 }, o2 = 0, r2 = this._inertiaBuffer; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2].settings;
            i2.zoom += a2.zoomDelta || 0, i2.bearing += a2.bearingDelta || 0, i2.pitch += a2.pitchDelta || 0, a2.panDelta && i2.pan._add(a2.panDelta), a2.around && (i2.around = a2.around), a2.pinchAround && (i2.pinchAround = a2.pinchAround);
          }
          var n2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
          if (i2.pan.mag()) {
            var l2 = Lo(i2.pan.mag(), n2, t.extend({}, So, e2 || {}));
            s2.offset = i2.pan.mult(l2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Mo(s2, l2);
          }
          if (i2.zoom) {
            var c3 = Lo(i2.zoom, n2, Co);
            s2.zoom = this._map.transform.zoom + c3.amount, Mo(s2, c3);
          }
          if (i2.bearing) {
            var u2 = Lo(i2.bearing, n2, zo);
            s2.bearing = this._map.transform.bearing + t.clamp(u2.amount, -179, 179), Mo(s2, u2);
          }
          if (i2.pitch) {
            var h3 = Lo(i2.pitch, n2, Do);
            s2.pitch = this._map.transform.pitch + h3.amount, Mo(s2, h3);
          }
          if (s2.zoom || s2.bearing) {
            var p3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
            s2.around = p3 ? this._map.unproject(p3) : this._map.getCenter();
          }
          return this.clear(), t.extend(s2, { noMoveStart: true });
        }
      };
      var Ro = function(e2) {
        function o2(o3, r3, a2, n2) {
          void 0 === n2 && (n2 = {});
          var s2 = i.mousePos(r3.getCanvasContainer(), a2), l2 = r3.unproject(s2);
          e2.call(this, o3, t.extend({ point: s2, lngLat: l2, originalEvent: a2 }, n2)), this._defaultPrevented = false, this.target = r3;
        }
        e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
        var r2 = { defaultPrevented: { configurable: true } };
        return o2.prototype.preventDefault = function() {
          this._defaultPrevented = true;
        }, r2.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(o2.prototype, r2), o2;
      }(t.Event), ko = function(e2) {
        function o2(o3, r3, a2) {
          var n2 = "touchend" === o3 ? a2.changedTouches : a2.touches, s2 = i.touchPos(r3.getCanvasContainer(), n2), l2 = s2.map(function(t2) {
            return r3.unproject(t2);
          }), c3 = s2.reduce(function(t2, e3, i2, o4) {
            return t2.add(e3.div(o4.length));
          }, new t.Point(0, 0)), u2 = r3.unproject(c3);
          e2.call(this, o3, { points: s2, point: c3, lngLats: l2, lngLat: u2, originalEvent: a2 }), this._defaultPrevented = false;
        }
        e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
        var r2 = { defaultPrevented: { configurable: true } };
        return o2.prototype.preventDefault = function() {
          this._defaultPrevented = true;
        }, r2.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(o2.prototype, r2), o2;
      }(t.Event), Bo = function(t2) {
        function e2(e3, i3, o2) {
          t2.call(this, e3, { originalEvent: o2 }), this._defaultPrevented = false;
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var i2 = { defaultPrevented: { configurable: true } };
        return e2.prototype.preventDefault = function() {
          this._defaultPrevented = true;
        }, i2.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(e2.prototype, i2), e2;
      }(t.Event), Oo = function(t2, e2) {
        this._map = t2, this._clickTolerance = e2.clickTolerance;
      };
      Oo.prototype.reset = function() {
        delete this._mousedownPos;
      }, Oo.prototype.wheel = function(t2) {
        return this._firePreventable(new Bo(t2.type, this._map, t2));
      }, Oo.prototype.mousedown = function(t2, e2) {
        return this._mousedownPos = e2, this._firePreventable(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.mouseup = function(t2) {
        this._map.fire(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.click = function(t2, e2) {
        this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.dblclick = function(t2) {
        return this._firePreventable(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.mouseover = function(t2) {
        this._map.fire(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.mouseout = function(t2) {
        this._map.fire(new Ro(t2.type, this._map, t2));
      }, Oo.prototype.touchstart = function(t2) {
        return this._firePreventable(new ko(t2.type, this._map, t2));
      }, Oo.prototype.touchmove = function(t2) {
        this._map.fire(new ko(t2.type, this._map, t2));
      }, Oo.prototype.touchend = function(t2) {
        this._map.fire(new ko(t2.type, this._map, t2));
      }, Oo.prototype.touchcancel = function(t2) {
        this._map.fire(new ko(t2.type, this._map, t2));
      }, Oo.prototype._firePreventable = function(t2) {
        if (this._map.fire(t2), t2.defaultPrevented)
          return {};
      }, Oo.prototype.isEnabled = function() {
        return true;
      }, Oo.prototype.isActive = function() {
        return false;
      }, Oo.prototype.enable = function() {
      }, Oo.prototype.disable = function() {
      };
      var Fo = function(t2) {
        this._map = t2;
      };
      Fo.prototype.reset = function() {
        this._delayContextMenu = false, delete this._contextMenuEvent;
      }, Fo.prototype.mousemove = function(t2) {
        this._map.fire(new Ro(t2.type, this._map, t2));
      }, Fo.prototype.mousedown = function() {
        this._delayContextMenu = true;
      }, Fo.prototype.mouseup = function() {
        this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }, Fo.prototype.contextmenu = function(t2) {
        this._delayContextMenu ? this._contextMenuEvent = t2 : this._map.fire(new Ro(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
      }, Fo.prototype.isEnabled = function() {
        return true;
      }, Fo.prototype.isActive = function() {
        return false;
      }, Fo.prototype.enable = function() {
      }, Fo.prototype.disable = function() {
      };
      var Uo = function(t2, e2) {
        this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
      };
      function No(t2, e2) {
        for (var i2 = {}, o2 = 0; o2 < t2.length; o2++)
          i2[t2[o2].identifier] = e2[o2];
        return i2;
      }
      Uo.prototype.isEnabled = function() {
        return !!this._enabled;
      }, Uo.prototype.isActive = function() {
        return !!this._active;
      }, Uo.prototype.enable = function() {
        this.isEnabled() || (this._enabled = true);
      }, Uo.prototype.disable = function() {
        this.isEnabled() && (this._enabled = false);
      }, Uo.prototype.mousedown = function(t2, e2) {
        this.isEnabled() && t2.shiftKey && 0 === t2.button && (i.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
      }, Uo.prototype.mousemoveWindow = function(t2, e2) {
        if (this._active) {
          var o2 = e2;
          if (!(this._lastPos.equals(o2) || !this._box && o2.dist(this._startPos) < this._clickTolerance)) {
            var r2 = this._startPos;
            this._lastPos = o2, this._box || (this._box = i.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
            var a2 = Math.min(r2.x, o2.x), n2 = Math.max(r2.x, o2.x), s2 = Math.min(r2.y, o2.y), l2 = Math.max(r2.y, o2.y);
            i.setTransform(this._box, "translate(" + a2 + "px," + s2 + "px)"), this._box.style.width = n2 - a2 + "px", this._box.style.height = l2 - s2 + "px";
          }
        }
      }, Uo.prototype.mouseupWindow = function(e2, o2) {
        var r2 = this;
        if (this._active && 0 === e2.button) {
          var a2 = this._startPos, n2 = o2;
          if (this.reset(), i.suppressClick(), a2.x !== n2.x || a2.y !== n2.y)
            return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: function(t2) {
              return t2.fitScreenCoordinates(a2, n2, r2._map.getBearing(), { linear: true });
            } };
          this._fireEvent("boxzoomcancel", e2);
        }
      }, Uo.prototype.keydown = function(t2) {
        this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
      }, Uo.prototype.blur = function() {
        this.reset();
      }, Uo.prototype.reset = function() {
        this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;
      }, Uo.prototype._fireEvent = function(e2, i2) {
        return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
      };
      var Zo = function(t2) {
        this.reset(), this.numTouches = t2.numTouches;
      };
      Zo.prototype.reset = function() {
        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
      }, Zo.prototype.touchstart = function(e2, i2, o2) {
        (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
          for (var i3 = new t.Point(0, 0), o3 = 0, r2 = e3; o3 < r2.length; o3 += 1)
            i3._add(r2[o3]);
          return i3.div(e3.length);
        }(i2), this.touches = No(o2, i2)));
      }, Zo.prototype.touchmove = function(t2, e2, i2) {
        if (!this.aborted && this.centroid) {
          var o2 = No(i2, e2);
          for (var r2 in this.touches) {
            var a2 = o2[r2];
            (!a2 || a2.dist(this.touches[r2]) > 30) && (this.aborted = true);
          }
        }
      }, Zo.prototype.touchend = function(t2, e2, i2) {
        if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
          var o2 = !this.aborted && this.centroid;
          if (this.reset(), o2)
            return o2;
        }
      };
      var qo = function(t2) {
        this.singleTap = new Zo(t2), this.numTaps = t2.numTaps, this.reset();
      };
      qo.prototype.reset = function() {
        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
      }, qo.prototype.touchstart = function(t2, e2, i2) {
        this.singleTap.touchstart(t2, e2, i2);
      }, qo.prototype.touchmove = function(t2, e2, i2) {
        this.singleTap.touchmove(t2, e2, i2);
      }, qo.prototype.touchend = function(t2, e2, i2) {
        var o2 = this.singleTap.touchend(t2, e2, i2);
        if (o2) {
          var r2 = t2.timeStamp - this.lastTime < 500, a2 = !this.lastTap || this.lastTap.dist(o2) < 30;
          if (r2 && a2 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
            return this.reset(), o2;
        }
      };
      var jo = function() {
        this._zoomIn = new qo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qo({ numTouches: 2, numTaps: 1 }), this.reset();
      };
      jo.prototype.reset = function() {
        this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
      }, jo.prototype.touchstart = function(t2, e2, i2) {
        this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
      }, jo.prototype.touchmove = function(t2, e2, i2) {
        this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
      }, jo.prototype.touchend = function(t2, e2, i2) {
        var o2 = this, r2 = this._zoomIn.touchend(t2, e2, i2), a2 = this._zoomOut.touchend(t2, e2, i2);
        return r2 ? (this._active = true, t2.preventDefault(), setTimeout(function() {
          return o2.reset();
        }, 0), { cameraAnimation: function(e3) {
          return e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(r2) }, { originalEvent: t2 });
        } }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(function() {
          return o2.reset();
        }, 0), { cameraAnimation: function(e3) {
          return e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(a2) }, { originalEvent: t2 });
        } }) : void 0;
      }, jo.prototype.touchcancel = function() {
        this.reset();
      }, jo.prototype.enable = function() {
        this._enabled = true;
      }, jo.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, jo.prototype.isEnabled = function() {
        return this._enabled;
      }, jo.prototype.isActive = function() {
        return this._active;
      };
      var Vo = { 0: 1, 2: 2 }, Go = function(t2) {
        this.reset(), this._clickTolerance = t2.clickTolerance || 1;
      };
      Go.prototype.blur = function() {
        this.reset();
      }, Go.prototype.reset = function() {
        this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
      }, Go.prototype._correctButton = function(t2, e2) {
        return false;
      }, Go.prototype._move = function(t2, e2) {
        return {};
      }, Go.prototype.mousedown = function(t2, e2) {
        if (!this._lastPoint) {
          var o2 = i.mouseButton(t2);
          this._correctButton(t2, o2) && (this._lastPoint = e2, this._eventButton = o2);
        }
      }, Go.prototype.mousemoveWindow = function(t2, e2) {
        var i2 = this._lastPoint;
        if (i2) {
          if (t2.preventDefault(), function(t3, e3) {
            var i3 = Vo[e3];
            return void 0 === t3.buttons || (t3.buttons & i3) !== i3;
          }(t2, this._eventButton))
            this.reset();
          else if (this._moved || !(e2.dist(i2) < this._clickTolerance))
            return this._moved = true, this._lastPoint = e2, this._move(i2, e2);
        }
      }, Go.prototype.mouseupWindow = function(t2) {
        this._lastPoint && i.mouseButton(t2) === this._eventButton && (this._moved && i.suppressClick(), this.reset());
      }, Go.prototype.enable = function() {
        this._enabled = true;
      }, Go.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, Go.prototype.isEnabled = function() {
        return this._enabled;
      }, Go.prototype.isActive = function() {
        return this._active;
      };
      var Wo = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.mousedown = function(e3, i2) {
          t2.prototype.mousedown.call(this, e3, i2), this._lastPoint && (this._active = true);
        }, e2.prototype._correctButton = function(t3, e3) {
          return 0 === e3 && !t3.ctrlKey;
        }, e2.prototype._move = function(t3, e3) {
          return { around: e3, panDelta: e3.sub(t3) };
        }, e2;
      }(Go), Xo = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._correctButton = function(t3, e3) {
          return 0 === e3 && t3.ctrlKey || 2 === e3;
        }, e2.prototype._move = function(t3, e3) {
          var i2 = 0.8 * (e3.x - t3.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }, e2.prototype.contextmenu = function(t3) {
          t3.preventDefault();
        }, e2;
      }(Go), Ho = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._correctButton = function(t3, e3) {
          return 0 === e3 && t3.ctrlKey || 2 === e3;
        }, e2.prototype._move = function(t3, e3) {
          var i2 = -0.5 * (e3.y - t3.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }, e2.prototype.contextmenu = function(t3) {
          t3.preventDefault();
        }, e2;
      }(Go), Ko = function(t2) {
        this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset();
      };
      Ko.prototype.reset = function() {
        this._active = false, this._touches = {}, this._sum = new t.Point(0, 0);
      }, Ko.prototype.touchstart = function(t2, e2, i2) {
        return this._calculateTransform(t2, e2, i2);
      }, Ko.prototype.touchmove = function(t2, e2, i2) {
        if (this._active && !(i2.length < this._minTouches))
          return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
      }, Ko.prototype.touchend = function(t2, e2, i2) {
        this._calculateTransform(t2, e2, i2), this._active && i2.length < this._minTouches && this.reset();
      }, Ko.prototype.touchcancel = function() {
        this.reset();
      }, Ko.prototype._calculateTransform = function(e2, i2, o2) {
        o2.length > 0 && (this._active = true);
        var r2 = No(o2, i2), a2 = new t.Point(0, 0), n2 = new t.Point(0, 0), s2 = 0;
        for (var l2 in r2) {
          var c3 = r2[l2], u2 = this._touches[l2];
          u2 && (a2._add(c3), n2._add(c3.sub(u2)), s2++, r2[l2] = c3);
        }
        if (this._touches = r2, !(s2 < this._minTouches) && n2.mag()) {
          var h3 = n2.div(s2);
          if (this._sum._add(h3), !(this._sum.mag() < this._clickTolerance))
            return { around: a2.div(s2), panDelta: h3 };
        }
      }, Ko.prototype.enable = function() {
        this._enabled = true;
      }, Ko.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, Ko.prototype.isEnabled = function() {
        return this._enabled;
      }, Ko.prototype.isActive = function() {
        return this._active;
      };
      var Yo = function() {
        this.reset();
      };
      function Jo(t2, e2, i2) {
        for (var o2 = 0; o2 < t2.length; o2++)
          if (t2[o2].identifier === i2)
            return e2[o2];
      }
      function Qo(t2, e2) {
        return Math.log(t2 / e2) / Math.LN2;
      }
      Yo.prototype.reset = function() {
        this._active = false, delete this._firstTwoTouches;
      }, Yo.prototype._start = function(t2) {
      }, Yo.prototype._move = function(t2, e2, i2) {
        return {};
      }, Yo.prototype.touchstart = function(t2, e2, i2) {
        this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
      }, Yo.prototype.touchmove = function(t2, e2, i2) {
        if (this._firstTwoTouches) {
          t2.preventDefault();
          var o2 = this._firstTwoTouches, r2 = o2[1], a2 = Jo(i2, e2, o2[0]), n2 = Jo(i2, e2, r2);
          if (a2 && n2) {
            var s2 = this._aroundCenter ? null : a2.add(n2).div(2);
            return this._move([a2, n2], s2, t2);
          }
        }
      }, Yo.prototype.touchend = function(t2, e2, o2) {
        if (this._firstTwoTouches) {
          var r2 = this._firstTwoTouches, a2 = r2[1], n2 = Jo(o2, e2, r2[0]), s2 = Jo(o2, e2, a2);
          n2 && s2 || (this._active && i.suppressClick(), this.reset());
        }
      }, Yo.prototype.touchcancel = function() {
        this.reset();
      }, Yo.prototype.enable = function(t2) {
        this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
      }, Yo.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, Yo.prototype.isEnabled = function() {
        return this._enabled;
      }, Yo.prototype.isActive = function() {
        return this._active;
      };
      var $o = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
          t2.prototype.reset.call(this), delete this._distance, delete this._startDistance;
        }, e2.prototype._start = function(t3) {
          this._startDistance = this._distance = t3[0].dist(t3[1]);
        }, e2.prototype._move = function(t3, e3) {
          var i2 = this._distance;
          if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: Qo(this._distance, i2), pinchAround: e3 };
        }, e2;
      }(Yo);
      function tr(t2, e2) {
        return 180 * t2.angleWith(e2) / Math.PI;
      }
      var er = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
          t2.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
        }, e2.prototype._start = function(t3) {
          this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
        }, e2.prototype._move = function(t3, e3) {
          var i2 = this._vector;
          if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: tr(this._vector, i2), pinchAround: e3 };
        }, e2.prototype._isBelowThreshold = function(t3) {
          this._minDiameter = Math.min(this._minDiameter, t3.mag());
          var e3 = 25 / (Math.PI * this._minDiameter) * 360, i2 = tr(t3, this._startVector);
          return Math.abs(i2) < e3;
        }, e2;
      }(Yo);
      function ir(t2) {
        return Math.abs(t2.y) > Math.abs(t2.x);
      }
      var or = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
          t2.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }, e2.prototype._start = function(t3) {
          this._lastPoints = t3, ir(t3[0].sub(t3[1])) && (this._valid = false);
        }, e2.prototype._move = function(t3, e3, i2) {
          var o2 = t3[0].sub(this._lastPoints[0]), r2 = t3[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(o2, r2, i2.timeStamp), this._valid)
            return this._lastPoints = t3, this._active = true, { pitchDelta: (o2.y + r2.y) / 2 * -0.5 };
        }, e2.prototype.gestureBeginsVertically = function(t3, e3, i2) {
          if (void 0 !== this._valid)
            return this._valid;
          var o2 = t3.mag() >= 2, r2 = e3.mag() >= 2;
          if (o2 || r2) {
            if (!o2 || !r2)
              return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            var a2 = t3.y > 0 == e3.y > 0;
            return ir(t3) && ir(e3) && a2;
          }
        }, e2;
      }(Yo), rr = { panStep: 100, bearingStep: 15, pitchStep: 10 }, ar = function() {
        var t2 = rr;
        this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
      };
      function nr(t2) {
        return t2 * (2 - t2);
      }
      ar.prototype.blur = function() {
        this.reset();
      }, ar.prototype.reset = function() {
        this._active = false;
      }, ar.prototype.keydown = function(t2) {
        var e2 = this;
        if (!(t2.altKey || t2.ctrlKey || t2.metaKey)) {
          var i2 = 0, o2 = 0, r2 = 0, a2 = 0, n2 = 0;
          switch (t2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              i2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              i2 = -1;
              break;
            case 37:
              t2.shiftKey ? o2 = -1 : (t2.preventDefault(), a2 = -1);
              break;
            case 39:
              t2.shiftKey ? o2 = 1 : (t2.preventDefault(), a2 = 1);
              break;
            case 38:
              t2.shiftKey ? r2 = 1 : (t2.preventDefault(), n2 = -1);
              break;
            case 40:
              t2.shiftKey ? r2 = -1 : (t2.preventDefault(), n2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (o2 = 0, r2 = 0), { cameraAnimation: function(s2) {
            var l2 = s2.getZoom();
            s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nr, zoom: i2 ? Math.round(l2) + i2 * (t2.shiftKey ? 2 : 1) : l2, bearing: s2.getBearing() + o2 * e2._bearingStep, pitch: s2.getPitch() + r2 * e2._pitchStep, offset: [-a2 * e2._panStep, -n2 * e2._panStep], center: s2.getCenter() }, { originalEvent: t2 });
          } };
        }
      }, ar.prototype.enable = function() {
        this._enabled = true;
      }, ar.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, ar.prototype.isEnabled = function() {
        return this._enabled;
      }, ar.prototype.isActive = function() {
        return this._active;
      }, ar.prototype.disableRotation = function() {
        this._rotationDisabled = true;
      }, ar.prototype.enableRotation = function() {
        this._rotationDisabled = false;
      };
      var sr = function(e2, i2) {
        this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);
      };
      sr.prototype.setZoomRate = function(t2) {
        this._defaultZoomRate = t2;
      }, sr.prototype.setWheelZoomRate = function(t2) {
        this._wheelZoomRate = t2;
      }, sr.prototype.isEnabled = function() {
        return !!this._enabled;
      }, sr.prototype.isActive = function() {
        return !!this._active || void 0 !== this._finishTimeout;
      }, sr.prototype.isZooming = function() {
        return !!this._zooming;
      }, sr.prototype.enable = function(t2) {
        this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && "center" === t2.around);
      }, sr.prototype.disable = function() {
        this.isEnabled() && (this._enabled = false);
      }, sr.prototype.wheel = function(e2) {
        if (this.isEnabled()) {
          var i2 = e2.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY, o2 = t.browser.now(), r2 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, 0 !== i2 && i2 % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this._active || this._start(e2)), e2.preventDefault();
        }
      }, sr.prototype._onTimeout = function(t2) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
      }, sr.prototype._start = function(e2) {
        if (this._delta) {
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          var o2 = i.mousePos(this._el, e2);
          this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
      }, sr.prototype.renderFrame = function() {
        var e2 = this;
        if (this._frameId && (this._frameId = null, this.isActive())) {
          var i2 = this._map.transform;
          if (0 !== this._delta) {
            var o2 = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, r2 = 2 / (1 + Math.exp(-Math.abs(this._delta * o2)));
            this._delta < 0 && 0 !== r2 && (r2 = 1 / r2);
            var a2 = "number" == typeof this._targetZoom ? i2.zoomScale(this._targetZoom) : i2.scale;
            this._targetZoom = Math.min(i2.maxZoom, Math.max(i2.minZoom, i2.scaleZoom(a2 * r2))), "wheel" === this._type && (this._startZoom = i2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          var n2, s2 = "number" == typeof this._targetZoom ? this._targetZoom : i2.zoom, l2 = this._startZoom, c3 = this._easing, u2 = false;
          if ("wheel" === this._type && l2 && c3) {
            var h3 = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), p3 = c3(h3);
            n2 = t.number(l2, s2, p3), h3 < 1 ? this._frameId || (this._frameId = true) : u2 = true;
          } else
            n2 = s2, u2 = true;
          return this._active = true, u2 && (this._active = false, this._finishTimeout = setTimeout(function() {
            e2._zooming = false, e2._handler._triggerRenderFrame(), delete e2._targetZoom, delete e2._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !u2, zoomDelta: n2 - i2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
      }, sr.prototype._smoothOutEasing = function(e2) {
        var i2 = t.ease;
        if (this._prevEase) {
          var o2 = this._prevEase, r2 = (t.browser.now() - o2.start) / o2.duration, a2 = o2.easing(r2 + 0.01) - o2.easing(r2), n2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
          i2 = t.bezier(n2, s2, 0.25, 1);
        }
        return this._prevEase = { start: t.browser.now(), duration: e2, easing: i2 }, i2;
      }, sr.prototype.blur = function() {
        this.reset();
      }, sr.prototype.reset = function() {
        this._active = false;
      };
      var lr = function(t2, e2) {
        this._clickZoom = t2, this._tapZoom = e2;
      };
      lr.prototype.enable = function() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }, lr.prototype.disable = function() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }, lr.prototype.isEnabled = function() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }, lr.prototype.isActive = function() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      };
      var cr = function() {
        this.reset();
      };
      cr.prototype.reset = function() {
        this._active = false;
      }, cr.prototype.blur = function() {
        this.reset();
      }, cr.prototype.dblclick = function(t2, e2) {
        return t2.preventDefault(), { cameraAnimation: function(i2) {
          i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e2) }, { originalEvent: t2 });
        } };
      }, cr.prototype.enable = function() {
        this._enabled = true;
      }, cr.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, cr.prototype.isEnabled = function() {
        return this._enabled;
      }, cr.prototype.isActive = function() {
        return this._active;
      };
      var ur = function() {
        this._tap = new qo({ numTouches: 1, numTaps: 1 }), this.reset();
      };
      ur.prototype.reset = function() {
        this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
      }, ur.prototype.touchstart = function(t2, e2, i2) {
        this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e2, i2));
      }, ur.prototype.touchmove = function(t2, e2, i2) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (i2[0].identifier !== this._swipeTouch)
              return;
            var o2 = e2[0], r2 = o2.y - this._swipePoint.y;
            return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
          }
        } else
          this._tap.touchmove(t2, e2, i2);
      }, ur.prototype.touchend = function(t2, e2, i2) {
        this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(t2, e2, i2) && (this._tapTime = t2.timeStamp);
      }, ur.prototype.touchcancel = function() {
        this.reset();
      }, ur.prototype.enable = function() {
        this._enabled = true;
      }, ur.prototype.disable = function() {
        this._enabled = false, this.reset();
      }, ur.prototype.isEnabled = function() {
        return this._enabled;
      }, ur.prototype.isActive = function() {
        return this._active;
      };
      var hr = function(t2, e2, i2) {
        this._el = t2, this._mousePan = e2, this._touchPan = i2;
      };
      hr.prototype.enable = function(t2) {
        this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }, hr.prototype.disable = function() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }, hr.prototype.isEnabled = function() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }, hr.prototype.isActive = function() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      };
      var pr = function(t2, e2, i2) {
        this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
      };
      pr.prototype.enable = function() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }, pr.prototype.disable = function() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }, pr.prototype.isEnabled = function() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }, pr.prototype.isActive = function() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      };
      var dr = function(t2, e2, i2, o2) {
        this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
      };
      dr.prototype.enable = function(t2) {
        this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }, dr.prototype.disable = function() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }, dr.prototype.isEnabled = function() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }, dr.prototype.isActive = function() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }, dr.prototype.disableRotation = function() {
        this._rotationDisabled = true, this._touchRotate.disable();
      }, dr.prototype.enableRotation = function() {
        this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
      };
      var _r = function(t2) {
        return t2.zoom || t2.drag || t2.pitch || t2.rotate;
      }, fr = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
      }(t.Event);
      function mr(t2) {
        return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
      }
      var gr = function(e2, o2) {
        this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e2), this._bearingSnap = o2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
        var r2 = this._el;
        this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", void 0], [r2, "touchcancel", void 0], [r2, "mousedown", void 0], [r2, "mousemove", void 0], [r2, "mouseup", void 0], [t.window.document, "mousemove", { capture: true }], [t.window.document, "mouseup", void 0], [r2, "mouseover", void 0], [r2, "mouseout", void 0], [r2, "dblclick", void 0], [r2, "click", void 0], [r2, "keydown", { capture: false }], [r2, "keyup", void 0], [r2, "wheel", { passive: false }], [r2, "contextmenu", void 0], [t.window, "blur", void 0]];
        for (var a2 = 0, n2 = this._listeners; a2 < n2.length; a2 += 1) {
          var s2 = n2[a2], l2 = s2[0];
          i.addEventListener(l2, s2[1], l2 === t.window.document ? this.handleWindowEvent : this.handleEvent, s2[2]);
        }
      };
      gr.prototype.destroy = function() {
        for (var e2 = 0, o2 = this._listeners; e2 < o2.length; e2 += 1) {
          var r2 = o2[e2], a2 = r2[0];
          i.removeEventListener(a2, r2[1], a2 === t.window.document ? this.handleWindowEvent : this.handleEvent, r2[2]);
        }
      }, gr.prototype._addDefaultHandlers = function(t2) {
        var e2 = this._map, i2 = e2.getCanvasContainer();
        this._add("mapEvent", new Oo(e2, t2));
        var o2 = e2.boxZoom = new Uo(e2, t2);
        this._add("boxZoom", o2);
        var r2 = new jo(), a2 = new cr();
        e2.doubleClickZoom = new lr(a2, r2), this._add("tapZoom", r2), this._add("clickZoom", a2);
        var n2 = new ur();
        this._add("tapDragZoom", n2);
        var s2 = e2.touchPitch = new or();
        this._add("touchPitch", s2);
        var l2 = new Xo(t2), c3 = new Ho(t2);
        e2.dragRotate = new pr(t2, l2, c3), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]);
        var u2 = new Wo(t2), h3 = new Ko(t2);
        e2.dragPan = new hr(i2, u2, h3), this._add("mousePan", u2), this._add("touchPan", h3, ["touchZoom", "touchRotate"]);
        var p3 = new er(), d2 = new $o();
        e2.touchZoomRotate = new dr(i2, d2, p3, n2), this._add("touchRotate", p3, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]);
        var _24 = e2.scrollZoom = new sr(e2, this);
        this._add("scrollZoom", _24, ["mousePan"]);
        var f2 = e2.keyboard = new ar();
        this._add("keyboard", f2), this._add("blockableMapEvent", new Fo(e2));
        for (var m2 = 0, g2 = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m2 < g2.length; m2 += 1) {
          var v3 = g2[m2];
          t2.interactive && t2[v3] && e2[v3].enable(t2[v3]);
        }
      }, gr.prototype._add = function(t2, e2, i2) {
        this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
      }, gr.prototype.stop = function(t2) {
        if (!this._updatingCamera) {
          for (var e2 = 0, i2 = this._handlers; e2 < i2.length; e2 += 1)
            i2[e2].handler.reset();
          this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
        }
      }, gr.prototype.isActive = function() {
        for (var t2 = 0, e2 = this._handlers; t2 < e2.length; t2 += 1)
          if (e2[t2].handler.isActive())
            return true;
        return false;
      }, gr.prototype.isZooming = function() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }, gr.prototype.isRotating = function() {
        return !!this._eventsInProgress.rotate;
      }, gr.prototype.isMoving = function() {
        return Boolean(_r(this._eventsInProgress)) || this.isZooming();
      }, gr.prototype._blockedByActive = function(t2, e2, i2) {
        for (var o2 in t2)
          if (o2 !== i2 && (!e2 || e2.indexOf(o2) < 0))
            return true;
        return false;
      }, gr.prototype.handleWindowEvent = function(t2) {
        this.handleEvent(t2, t2.type + "Window");
      }, gr.prototype._getMapTouches = function(t2) {
        for (var e2 = [], i2 = 0, o2 = t2; i2 < o2.length; i2 += 1) {
          var r2 = o2[i2];
          this._el.contains(r2.target) && e2.push(r2);
        }
        return e2;
      }, gr.prototype.handleEvent = function(t2, e2) {
        this._updatingCamera = true;
        for (var o2 = "renderFrame" === t2.type ? void 0 : t2, r2 = { needsRenderFrame: false }, a2 = {}, n2 = {}, s2 = t2.touches ? this._getMapTouches(t2.touches) : void 0, l2 = s2 ? i.touchPos(this._el, s2) : i.mousePos(this._el, t2), c3 = 0, u2 = this._handlers; c3 < u2.length; c3 += 1) {
          var h3 = u2[c3], p3 = h3.handlerName, d2 = h3.handler, _24 = h3.allowed;
          if (d2.isEnabled()) {
            var f2 = void 0;
            this._blockedByActive(n2, _24, p3) ? d2.reset() : d2[e2 || t2.type] && (f2 = d2[e2 || t2.type](t2, l2, s2), this.mergeHandlerResult(r2, a2, f2, p3, o2), f2 && f2.needsRenderFrame && this._triggerRenderFrame()), (f2 || d2.isActive()) && (n2[p3] = d2);
          }
        }
        var m2 = {};
        for (var g2 in this._previousActiveHandlers)
          n2[g2] || (m2[g2] = o2);
        this._previousActiveHandlers = n2, (Object.keys(m2).length || mr(r2)) && (this._changes.push([r2, a2, m2]), this._triggerRenderFrame()), (Object.keys(n2).length || mr(r2)) && this._map._stop(true), this._updatingCamera = false;
        var v3 = r2.cameraAnimation;
        v3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], v3(this._map));
      }, gr.prototype.mergeHandlerResult = function(e2, i2, o2, r2, a2) {
        if (o2) {
          t.extend(e2, o2);
          var n2 = { handlerName: r2, originalEvent: o2.originalEvent || a2 };
          void 0 !== o2.zoomDelta && (i2.zoom = n2), void 0 !== o2.panDelta && (i2.drag = n2), void 0 !== o2.pitchDelta && (i2.pitch = n2), void 0 !== o2.bearingDelta && (i2.rotate = n2);
        }
      }, gr.prototype._applyChanges = function() {
        for (var e2 = {}, i2 = {}, o2 = {}, r2 = 0, a2 = this._changes; r2 < a2.length; r2 += 1) {
          var n2 = a2[r2], s2 = n2[0], l2 = n2[1], c3 = n2[2];
          s2.panDelta && (e2.panDelta = (e2.panDelta || new t.Point(0, 0))._add(s2.panDelta)), s2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (e2.around = s2.around), void 0 !== s2.pinchAround && (e2.pinchAround = s2.pinchAround), s2.noInertia && (e2.noInertia = s2.noInertia), t.extend(i2, l2), t.extend(o2, c3);
        }
        this._updateMapTransform(e2, i2, o2), this._changes = [];
      }, gr.prototype._updateMapTransform = function(t2, e2, i2) {
        var o2 = this._map, r2 = o2.transform;
        if (!mr(t2))
          return this._fireEvents(e2, i2, true);
        var a2 = t2.panDelta, n2 = t2.zoomDelta, s2 = t2.bearingDelta, l2 = t2.pitchDelta, c3 = t2.around, u2 = t2.pinchAround;
        void 0 !== u2 && (c3 = u2), o2._stop(true), c3 = c3 || o2.transform.centerPoint;
        var h3 = r2.pointLocation(a2 ? c3.sub(a2) : c3);
        s2 && (r2.bearing += s2), l2 && (r2.pitch += l2), n2 && (r2.zoom += n2), r2.setLocationAtPoint(h3, c3), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
      }, gr.prototype._fireEvents = function(e2, i2, o2) {
        var r2 = this, a2 = _r(this._eventsInProgress), n2 = _r(e2), s2 = {};
        for (var l2 in e2)
          this._eventsInProgress[l2] || (s2[l2 + "start"] = e2[l2].originalEvent), this._eventsInProgress[l2] = e2[l2];
        for (var c3 in !a2 && n2 && this._fireEvent("movestart", n2.originalEvent), s2)
          this._fireEvent(c3, s2[c3]);
        for (var u2 in n2 && this._fireEvent("move", n2.originalEvent), e2)
          this._fireEvent(u2, e2[u2].originalEvent);
        var h3, p3 = {};
        for (var d2 in this._eventsInProgress) {
          var _24 = this._eventsInProgress[d2], f2 = _24.handlerName, m2 = _24.originalEvent;
          this._handlersById[f2].isActive() || (delete this._eventsInProgress[d2], p3[d2 + "end"] = h3 = i2[f2] || m2);
        }
        for (var g2 in p3)
          this._fireEvent(g2, p3[g2]);
        var v3 = _r(this._eventsInProgress);
        if (o2 && (a2 || n2) && !v3) {
          this._updatingCamera = true;
          var y3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), x2 = function(t2) {
            return 0 !== t2 && -r2._bearingSnap < t2 && t2 < r2._bearingSnap;
          };
          y3 ? (x2(y3.bearing || this._map.getBearing()) && (y3.bearing = 0), this._map.easeTo(y3, { originalEvent: h3 })) : (this._map.fire(new t.Event("moveend", { originalEvent: h3 })), x2(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
        }
      }, gr.prototype._fireEvent = function(e2, i2) {
        this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
      }, gr.prototype._requestFrame = function() {
        var t2 = this;
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(e2) {
          delete t2._frameId, t2.handleEvent(new fr("renderFrame", { timeStamp: e2 })), t2._applyChanges();
        });
      }, gr.prototype._triggerRenderFrame = function() {
        void 0 === this._frameId && (this._frameId = this._requestFrame());
      };
      var vr = function(e2) {
        function i2(i3, o2) {
          e2.call(this), this._moving = false, this._zooming = false, this.transform = i3, this._bearingSnap = o2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
        }
        return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getCenter = function() {
          return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
        }, i2.prototype.setCenter = function(t2, e3) {
          return this.jumpTo({ center: t2 }, e3);
        }, i2.prototype.panBy = function(e3, i3, o2) {
          return e3 = t.Point.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i3), o2);
        }, i2.prototype.panTo = function(e3, i3, o2) {
          return this.easeTo(t.extend({ center: e3 }, i3), o2);
        }, i2.prototype.getZoom = function() {
          return this.transform.zoom;
        }, i2.prototype.setZoom = function(t2, e3) {
          return this.jumpTo({ zoom: t2 }, e3), this;
        }, i2.prototype.zoomTo = function(e3, i3, o2) {
          return this.easeTo(t.extend({ zoom: e3 }, i3), o2);
        }, i2.prototype.zoomIn = function(t2, e3) {
          return this.zoomTo(this.getZoom() + 1, t2, e3), this;
        }, i2.prototype.zoomOut = function(t2, e3) {
          return this.zoomTo(this.getZoom() - 1, t2, e3), this;
        }, i2.prototype.getBearing = function() {
          return this.transform.bearing;
        }, i2.prototype.setBearing = function(t2, e3) {
          return this.jumpTo({ bearing: t2 }, e3), this;
        }, i2.prototype.getPadding = function() {
          return this.transform.padding;
        }, i2.prototype.setPadding = function(t2, e3) {
          return this.jumpTo({ padding: t2 }, e3), this;
        }, i2.prototype.rotateTo = function(e3, i3, o2) {
          return this.easeTo(t.extend({ bearing: e3 }, i3), o2);
        }, i2.prototype.resetNorth = function(e3, i3) {
          return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i3), this;
        }, i2.prototype.resetNorthPitch = function(e3, i3) {
          return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i3), this;
        }, i2.prototype.snapToNorth = function(t2, e3) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e3) : this;
        }, i2.prototype.getPitch = function() {
          return this.transform.pitch;
        }, i2.prototype.setPitch = function(t2, e3) {
          return this.jumpTo({ pitch: t2 }, e3), this;
        }, i2.prototype.cameraForBounds = function(e3, i3) {
          e3 = t.LngLatBounds.convert(e3);
          var o2 = i3 && i3.bearing || 0;
          return this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), o2, i3);
        }, i2.prototype._cameraForBoxAndBearing = function(e3, i3, o2, r2) {
          var a2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (r2 = t.extend({ padding: a2, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
            var n2 = r2.padding;
            r2.padding = { top: n2, bottom: n2, right: n2, left: n2 };
          }
          r2.padding = t.extend(a2, r2.padding);
          var s2 = this.transform, l2 = s2.padding, c3 = s2.project(t.LngLat.convert(e3)), u2 = s2.project(t.LngLat.convert(i3)), h3 = c3.rotate(-o2 * Math.PI / 180), p3 = u2.rotate(-o2 * Math.PI / 180), d2 = new t.Point(Math.max(h3.x, p3.x), Math.max(h3.y, p3.y)), _24 = new t.Point(Math.min(h3.x, p3.x), Math.min(h3.y, p3.y)), f2 = d2.sub(_24), m2 = (s2.width - (l2.left + l2.right + r2.padding.left + r2.padding.right)) / f2.x, g2 = (s2.height - (l2.top + l2.bottom + r2.padding.top + r2.padding.bottom)) / f2.y;
          if (!(g2 < 0 || m2 < 0)) {
            var v3 = Math.min(s2.scaleZoom(s2.scale * Math.min(m2, g2)), r2.maxZoom), y3 = "number" == typeof r2.offset.x ? new t.Point(r2.offset.x, r2.offset.y) : t.Point.convert(r2.offset), x2 = new t.Point((r2.padding.left - r2.padding.right) / 2, (r2.padding.top - r2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), b2 = y3.add(x2).mult(s2.scale / s2.zoomScale(v3));
            return { center: s2.unproject(c3.add(u2).div(2).sub(b2)), zoom: v3, bearing: o2 };
          }
          t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }, i2.prototype.fitBounds = function(t2, e3, i3) {
          return this._fitInternal(this.cameraForBounds(t2, e3), e3, i3);
        }, i2.prototype.fitScreenCoordinates = function(e3, i3, o2, r2, a2) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e3)), this.transform.pointLocation(t.Point.convert(i3)), o2, r2), r2, a2);
        }, i2.prototype._fitInternal = function(e3, i3, o2) {
          return e3 ? (delete (i3 = t.extend(e3, i3)).padding, i3.linear ? this.easeTo(i3, o2) : this.flyTo(i3, o2)) : this;
        }, i2.prototype.jumpTo = function(e3, i3) {
          this.stop();
          var o2 = this.transform, r2 = false, a2 = false, n2 = false;
          return "zoom" in e3 && o2.zoom !== +e3.zoom && (r2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (a2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (n2 = true, o2.pitch = +e3.pitch), null == e3.padding || o2.isPaddingEqual(e3.padding) || (o2.padding = e3.padding), this.fire(new t.Event("movestart", i3)).fire(new t.Event("move", i3)), r2 && this.fire(new t.Event("zoomstart", i3)).fire(new t.Event("zoom", i3)).fire(new t.Event("zoomend", i3)), a2 && this.fire(new t.Event("rotatestart", i3)).fire(new t.Event("rotate", i3)).fire(new t.Event("rotateend", i3)), n2 && this.fire(new t.Event("pitchstart", i3)).fire(new t.Event("pitch", i3)).fire(new t.Event("pitchend", i3)), this.fire(new t.Event("moveend", i3));
        }, i2.prototype.easeTo = function(e3, i3) {
          var o2 = this;
          this._stop(false, e3.easeId), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.browser.prefersReducedMotion) && (e3.duration = 0);
          var r2 = this.transform, a2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), l2 = this.getPadding(), c3 = "zoom" in e3 ? +e3.zoom : a2, u2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, n2) : n2, h3 = "pitch" in e3 ? +e3.pitch : s2, p3 = "padding" in e3 ? e3.padding : r2.padding, d2 = t.Point.convert(e3.offset), _24 = r2.centerPoint.add(d2), f2 = r2.pointLocation(_24), m2 = t.LngLat.convert(e3.center || f2);
          this._normalizeCenter(m2);
          var g2, v3, y3 = r2.project(f2), x2 = r2.project(m2).sub(y3), b2 = r2.zoomScale(c3 - a2);
          e3.around && (g2 = t.LngLat.convert(e3.around), v3 = r2.locationPoint(g2));
          var w2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || c3 !== a2, this._rotating = this._rotating || n2 !== u2, this._pitching = this._pitching || h3 !== s2, this._padding = !r2.isPaddingEqual(p3), this._easeId = e3.easeId, this._prepareEase(i3, e3.noMoveStart, w2), this._ease(function(e4) {
            if (o2._zooming && (r2.zoom = t.number(a2, c3, e4)), o2._rotating && (r2.bearing = t.number(n2, u2, e4)), o2._pitching && (r2.pitch = t.number(s2, h3, e4)), o2._padding && (r2.interpolatePadding(l2, p3, e4), _24 = r2.centerPoint.add(d2)), g2)
              r2.setLocationAtPoint(g2, v3);
            else {
              var f3 = r2.zoomScale(r2.zoom - a2), m3 = c3 > a2 ? Math.min(2, b2) : Math.max(0.5, b2), w3 = Math.pow(m3, 1 - e4), T2 = r2.unproject(y3.add(x2.mult(e4 * w3)).mult(f3));
              r2.setLocationAtPoint(r2.renderWorldCopies ? T2.wrap() : T2, _24);
            }
            o2._fireMoveEvents(i3);
          }, function(t2) {
            o2._afterEase(i3, t2);
          }, e3), this;
        }, i2.prototype._prepareEase = function(e3, i3, o2) {
          void 0 === o2 && (o2 = {}), this._moving = true, i3 || o2.moving || this.fire(new t.Event("movestart", e3)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e3));
        }, i2.prototype._fireMoveEvents = function(e3) {
          this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
        }, i2.prototype._afterEase = function(e3, i3) {
          if (!this._easeId || !i3 || this._easeId !== i3) {
            delete this._easeId;
            var o2 = this._zooming, r2 = this._rotating, a2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e3)), r2 && this.fire(new t.Event("rotateend", e3)), a2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
          }
        }, i2.prototype.flyTo = function(e3, i3) {
          var o2 = this;
          if (!e3.essential && t.browser.prefersReducedMotion) {
            var r2 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(r2, i3);
          }
          this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
          var a2 = this.transform, n2 = this.getZoom(), s2 = this.getBearing(), l2 = this.getPitch(), c3 = this.getPadding(), u2 = "zoom" in e3 ? t.clamp(+e3.zoom, a2.minZoom, a2.maxZoom) : n2, h3 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, p3 = "pitch" in e3 ? +e3.pitch : l2, d2 = "padding" in e3 ? e3.padding : a2.padding, _24 = a2.zoomScale(u2 - n2), f2 = t.Point.convert(e3.offset), m2 = a2.centerPoint.add(f2), g2 = a2.pointLocation(m2), v3 = t.LngLat.convert(e3.center || g2);
          this._normalizeCenter(v3);
          var y3 = a2.project(g2), x2 = a2.project(v3).sub(y3), b2 = e3.curve, w2 = Math.max(a2.width, a2.height), T2 = w2 / _24, E2 = x2.mag();
          if ("minZoom" in e3) {
            var I3 = t.clamp(Math.min(e3.minZoom, n2, u2), a2.minZoom, a2.maxZoom), P2 = w2 / a2.zoomScale(I3 - n2);
            b2 = Math.sqrt(P2 / E2 * 2);
          }
          var S2 = b2 * b2;
          function C2(t2) {
            var e4 = (T2 * T2 - w2 * w2 + (t2 ? -1 : 1) * S2 * S2 * E2 * E2) / (2 * (t2 ? T2 : w2) * S2 * E2);
            return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
          }
          function z2(t2) {
            return (Math.exp(t2) - Math.exp(-t2)) / 2;
          }
          function D2(t2) {
            return (Math.exp(t2) + Math.exp(-t2)) / 2;
          }
          var A3 = C2(0), M2 = function(t2) {
            return D2(A3) / D2(A3 + b2 * t2);
          }, L2 = function(t2) {
            return w2 * ((D2(A3) * (z2(e4 = A3 + b2 * t2) / D2(e4)) - z2(A3)) / S2) / E2;
            var e4;
          }, R2 = (C2(1) - A3) / b2;
          if (Math.abs(E2) < 1e-6 || !isFinite(R2)) {
            if (Math.abs(w2 - T2) < 1e-6)
              return this.easeTo(e3, i3);
            var k2 = T2 < w2 ? -1 : 1;
            R2 = Math.abs(Math.log(T2 / w2)) / b2, L2 = function() {
              return 0;
            }, M2 = function(t2) {
              return Math.exp(k2 * b2 * t2);
            };
          }
          return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * R2 / ("screenSpeed" in e3 ? +e3.screenSpeed / b2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = s2 !== h3, this._pitching = p3 !== l2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i3, false), this._ease(function(e4) {
            var r3 = e4 * R2, _25 = 1 / M2(r3);
            a2.zoom = 1 === e4 ? u2 : n2 + a2.scaleZoom(_25), o2._rotating && (a2.bearing = t.number(s2, h3, e4)), o2._pitching && (a2.pitch = t.number(l2, p3, e4)), o2._padding && (a2.interpolatePadding(c3, d2, e4), m2 = a2.centerPoint.add(f2));
            var g3 = 1 === e4 ? v3 : a2.unproject(y3.add(x2.mult(L2(r3))).mult(_25));
            a2.setLocationAtPoint(a2.renderWorldCopies ? g3.wrap() : g3, m2), o2._fireMoveEvents(i3);
          }, function() {
            return o2._afterEase(i3);
          }, e3), this;
        }, i2.prototype.isEasing = function() {
          return !!this._easeFrameId;
        }, i2.prototype.stop = function() {
          return this._stop();
        }, i2.prototype._stop = function(t2, e3) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            var i3 = this._onEaseEnd;
            delete this._onEaseEnd, i3.call(this, e3);
          }
          if (!t2) {
            var o2 = this.handlers;
            o2 && o2.stop(false);
          }
          return this;
        }, i2.prototype._ease = function(e3, i3, o2) {
          false === o2.animate || 0 === o2.duration ? (e3(1), i3()) : (this._easeStart = t.browser.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }, i2.prototype._renderFrameCallback = function() {
          var e3 = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }, i2.prototype._normalizeBearing = function(e3, i3) {
          e3 = t.wrap(e3, -180, 180);
          var o2 = Math.abs(e3 - i3);
          return Math.abs(e3 - 360 - i3) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i3) < o2 && (e3 += 360), e3;
        }, i2.prototype._normalizeCenter = function(t2) {
          var e3 = this.transform;
          if (e3.renderWorldCopies && !e3.lngRange) {
            var i3 = t2.lng - e3.center.lng;
            t2.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
        }, i2;
      }(t.Evented), yr = function(e2) {
        void 0 === e2 && (e2 = {}), this.options = e2, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      };
      yr.prototype.getDefaultPosition = function() {
        return "bottom-right";
      }, yr.prototype.onAdd = function(t2) {
        var e2 = this.options && this.options.compact;
        return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }, yr.prototype.onRemove = function() {
        i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }, yr.prototype._setElementTitle = function(t2, e2) {
        var i2 = this._map._getUIString("AttributionControl." + e2);
        t2.title = i2, t2.setAttribute("aria-label", i2);
      }, yr.prototype._toggleAttribution = function() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
      }, yr.prototype._updateEditLink = function() {
        var e2 = this._editLink;
        e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        var i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }];
        if (e2) {
          var o2 = i2.reduce(function(t2, e3, o3) {
            return e3.value && (t2 += e3.key + "=" + e3.value + (o3 < i2.length - 1 ? "&" : "")), t2;
          }, "?");
          e2.href = t.config.FEEDBACK_URL + "/" + o2 + (this._map._hash ? this._map._hash.getHashString(true) : ""), e2.rel = "noopener nofollow", this._setElementTitle(e2, "MapFeedback");
        }
      }, yr.prototype._updateData = function(t2) {
        !t2 || "metadata" !== t2.sourceDataType && "visibility" !== t2.sourceDataType && "style" !== t2.dataType || (this._updateAttributions(), this._updateEditLink());
      }, yr.prototype._updateAttributions = function() {
        if (this._map.style) {
          var t2 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map(function(t3) {
            return "string" != typeof t3 ? "" : t3;
          })) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
            var e2 = this._map.style.stylesheet;
            this.styleOwner = e2.owner, this.styleId = e2.id;
          }
          var i2 = this._map.style.sourceCaches;
          for (var o2 in i2) {
            var r2 = i2[o2];
            if (r2.used) {
              var a2 = r2.getSource();
              a2.attribution && t2.indexOf(a2.attribution) < 0 && t2.push(a2.attribution);
            }
          }
          t2.sort(function(t3, e3) {
            return t3.length - e3.length;
          });
          var n2 = (t2 = t2.filter(function(e3, i3) {
            for (var o3 = i3 + 1; o3 < t2.length; o3++)
              if (t2[o3].indexOf(e3) >= 0)
                return false;
            return true;
          })).join(" | ");
          n2 !== this._attribHTML && (this._attribHTML = n2, t2.length ? (this._innerContainer.innerHTML = n2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
      }, yr.prototype._updateCompact = function() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      };
      var xr = function() {
        t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);
      };
      xr.prototype.onAdd = function(t2) {
        this._map = t2, this._container = i.create("div", "mapboxgl-ctrl");
        var e2 = i.create("a", "mapboxgl-ctrl-logo");
        return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://www.mapbox.com/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }, xr.prototype.onRemove = function() {
        i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }, xr.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, xr.prototype._updateLogo = function(t2) {
        t2 && "metadata" !== t2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }, xr.prototype._logoRequired = function() {
        if (this._map.style) {
          var t2 = this._map.style.sourceCaches;
          for (var e2 in t2)
            if (t2[e2].getSource().mapbox_logo)
              return true;
          return false;
        }
      }, xr.prototype._updateCompact = function() {
        var t2 = this._container.children;
        if (t2.length) {
          var e2 = t2[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? e2.classList.add("mapboxgl-compact") : e2.classList.remove("mapboxgl-compact");
        }
      };
      var br = function() {
        this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
      };
      br.prototype.add = function(t2) {
        var e2 = ++this._id;
        return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
      }, br.prototype.remove = function(t2) {
        for (var e2 = this._currentlyRunning, i2 = 0, o2 = e2 ? this._queue.concat(e2) : this._queue; i2 < o2.length; i2 += 1) {
          var r2 = o2[i2];
          if (r2.id === t2)
            return void (r2.cancelled = true);
        }
      }, br.prototype.run = function(t2) {
        void 0 === t2 && (t2 = 0);
        var e2 = this._currentlyRunning = this._queue;
        this._queue = [];
        for (var i2 = 0, o2 = e2; i2 < o2.length; i2 += 1) {
          var r2 = o2[i2];
          if (!r2.cancelled && (r2.callback(t2), this._cleared))
            break;
        }
        this._cleared = false, this._currentlyRunning = false;
      }, br.prototype.clear = function() {
        this._currentlyRunning && (this._cleared = true), this._queue = [];
      };
      var wr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Tr = t.window.HTMLImageElement, Er = t.window.HTMLElement, Ir = t.window.ImageBitmap, Pr = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, Sr = function(o2) {
        function r2(e2) {
          var i2 = this;
          if (null != (e2 = t.extend({}, Pr, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != e2.minPitch && e2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != e2.maxPitch && e2.maxPitch > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          var r3 = new To(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies);
          if (o2.call(this, r3, e2), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e2.locale), this._clickTolerance = e2.clickTolerance, this._requestManager = new t.RequestManager(e2.transformRequest, e2.accessToken), "string" == typeof e2.container) {
            if (this._container = t.window.document.getElementById(e2.container), !this._container)
              throw new Error("Container '" + e2.container + "' not found.");
          } else {
            if (!(e2.container instanceof Er))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e2.container;
          }
          if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", function() {
            return i2._update(false);
          }), this.on("moveend", function() {
            return i2._update(false);
          }), this.on("zoom", function() {
            return i2._update(true);
          }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, false), t.window.addEventListener("resize", this._onWindowResize, false), t.window.addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new gr(this, e2), this._hash = e2.hash && new Io("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new yr({ customAttribution: e2.customAttribution })), this.addControl(new xr(), e2.logoPosition), this.on("style.load", function() {
            i2.transform.unmodified && i2.jumpTo(i2.style.stylesheet);
          }), this.on("data", function(e3) {
            i2._update("style" === e3.dataType), i2.fire(new t.Event(e3.dataType + "data", e3));
          }), this.on("dataloading", function(e3) {
            i2.fire(new t.Event(e3.dataType + "dataloading", e3));
          });
        }
        o2 && (r2.__proto__ = o2), (r2.prototype = Object.create(o2 && o2.prototype)).constructor = r2;
        var a2 = { showTileBoundaries: { configurable: true }, showPadding: { configurable: true }, showCollisionBoxes: { configurable: true }, showOverdrawInspector: { configurable: true }, repaint: { configurable: true }, vertices: { configurable: true }, version: { configurable: true } };
        return r2.prototype._getMapId = function() {
          return this._mapId;
        }, r2.prototype.addControl = function(e2, i2) {
          if (void 0 === i2 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
            return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          var o3 = e2.onAdd(this);
          this._controls.push(e2);
          var r3 = this._controlPositions[i2];
          return -1 !== i2.indexOf("bottom") ? r3.insertBefore(o3, r3.firstChild) : r3.appendChild(o3), this;
        }, r2.prototype.removeControl = function(e2) {
          if (!e2 || !e2.onRemove)
            return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          var i2 = this._controls.indexOf(e2);
          return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
        }, r2.prototype.hasControl = function(t2) {
          return this._controls.indexOf(t2) > -1;
        }, r2.prototype.resize = function(e2) {
          var i2 = this._containerDimensions(), o3 = i2[0], r3 = i2[1];
          if (o3 === this.transform.width && r3 === this.transform.height)
            return this;
          this._resizeCanvas(o3, r3), this.transform.resize(o3, r3), this.painter.resize(o3, r3);
          var a3 = !this._moving;
          return a3 && this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2)), this.fire(new t.Event("resize", e2)), a3 && this.fire(new t.Event("moveend", e2)), this;
        }, r2.prototype.getBounds = function() {
          return this.transform.getBounds();
        }, r2.prototype.getMaxBounds = function() {
          return this.transform.getMaxBounds();
        }, r2.prototype.setMaxBounds = function(e2) {
          return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
        }, r2.prototype.setMinZoom = function(t2) {
          if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
            return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }, r2.prototype.getMinZoom = function() {
          return this.transform.minZoom;
        }, r2.prototype.setMaxZoom = function(t2) {
          if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
            return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }, r2.prototype.getMaxZoom = function() {
          return this.transform.maxZoom;
        }, r2.prototype.setMinPitch = function(t2) {
          if ((t2 = null == t2 ? 0 : t2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2 >= 0 && t2 <= this.transform.maxPitch)
            return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }, r2.prototype.getMinPitch = function() {
          return this.transform.minPitch;
        }, r2.prototype.setMaxPitch = function(t2) {
          if ((t2 = null == t2 ? 60 : t2) > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          if (t2 >= this.transform.minPitch)
            return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }, r2.prototype.getMaxPitch = function() {
          return this.transform.maxPitch;
        }, r2.prototype.getRenderWorldCopies = function() {
          return this.transform.renderWorldCopies;
        }, r2.prototype.setRenderWorldCopies = function(t2) {
          return this.transform.renderWorldCopies = t2, this._update();
        }, r2.prototype.project = function(e2) {
          return this.transform.locationPoint(t.LngLat.convert(e2));
        }, r2.prototype.unproject = function(e2) {
          return this.transform.pointLocation(t.Point.convert(e2));
        }, r2.prototype.isMoving = function() {
          return this._moving || this.handlers.isMoving();
        }, r2.prototype.isZooming = function() {
          return this._zooming || this.handlers.isZooming();
        }, r2.prototype.isRotating = function() {
          return this._rotating || this.handlers.isRotating();
        }, r2.prototype._createDelegatedListener = function(t2, e2, i2) {
          var o3, r3 = this;
          if ("mouseenter" === t2 || "mouseover" === t2) {
            var a3 = false;
            return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
              var n3 = r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : [];
              n3.length ? a3 || (a3 = true, i2.call(r3, new Ro(t2, r3, o4.originalEvent, { features: n3 }))) : a3 = false;
            }, mouseout: function() {
              a3 = false;
            } } };
          }
          if ("mouseleave" === t2 || "mouseout" === t2) {
            var n2 = false;
            return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
              (r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : []).length ? n2 = true : n2 && (n2 = false, i2.call(r3, new Ro(t2, r3, o4.originalEvent)));
            }, mouseout: function(e3) {
              n2 && (n2 = false, i2.call(r3, new Ro(t2, r3, e3.originalEvent)));
            } } };
          }
          return { layer: e2, listener: i2, delegates: (o3 = {}, o3[t2] = function(t3) {
            var o4 = r3.getLayer(e2) ? r3.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
            o4.length && (t3.features = o4, i2.call(r3, t3), delete t3.features);
          }, o3) };
        }, r2.prototype.on = function(t2, e2, i2) {
          if (void 0 === i2)
            return o2.prototype.on.call(this, t2, e2);
          var r3 = this._createDelegatedListener(t2, e2, i2);
          for (var a3 in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(r3), r3.delegates)
            this.on(a3, r3.delegates[a3]);
          return this;
        }, r2.prototype.once = function(t2, e2, i2) {
          if (void 0 === i2)
            return o2.prototype.once.call(this, t2, e2);
          var r3 = this._createDelegatedListener(t2, e2, i2);
          for (var a3 in r3.delegates)
            this.once(a3, r3.delegates[a3]);
          return this;
        }, r2.prototype.off = function(t2, e2, i2) {
          var r3 = this;
          return void 0 === i2 ? o2.prototype.off.call(this, t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && function(o3) {
            for (var a3 = o3[t2], n2 = 0; n2 < a3.length; n2++) {
              var s2 = a3[n2];
              if (s2.layer === e2 && s2.listener === i2) {
                for (var l2 in s2.delegates)
                  r3.off(l2, s2.delegates[l2]);
                return a3.splice(n2, 1), r3;
              }
            }
          }(this._delegatedListeners), this);
        }, r2.prototype.queryRenderedFeatures = function(e2, i2) {
          if (!this.style)
            return [];
          var o3;
          if (void 0 !== i2 || void 0 === e2 || e2 instanceof t.Point || Array.isArray(e2) || (i2 = e2, e2 = void 0), i2 = i2 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e2[0])
            o3 = [t.Point.convert(e2)];
          else {
            var r3 = t.Point.convert(e2[0]), a3 = t.Point.convert(e2[1]);
            o3 = [r3, new t.Point(a3.x, r3.y), a3, new t.Point(r3.x, a3.y), r3];
          }
          return this.style.queryRenderedFeatures(o3, i2, this.transform);
        }, r2.prototype.querySourceFeatures = function(t2, e2) {
          return this.style.querySourceFeatures(t2, e2);
        }, r2.prototype.setStyle = function(e2, i2) {
          return false !== (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
        }, r2.prototype._getUIString = function(t2) {
          var e2 = this._locale[t2];
          if (null == e2)
            throw new Error("Missing UI string '" + t2 + "'");
          return e2;
        }, r2.prototype._updateStyle = function(t2, e2) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new je(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
        }, r2.prototype._lazyInitEmptyStyle = function() {
          this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }, r2.prototype._diffStyle = function(e2, i2) {
          var o3 = this;
          if ("string" == typeof e2) {
            var r3 = this._requestManager.normalizeStyleURL(e2), a3 = this._requestManager.transformRequest(r3, t.ResourceType.Style);
            t.getJSON(a3, function(e3, r4) {
              e3 ? o3.fire(new t.ErrorEvent(e3)) : r4 && o3._updateDiff(r4, i2);
            });
          } else
            "object" == typeof e2 && this._updateDiff(e2, i2);
        }, r2.prototype._updateDiff = function(e2, i2) {
          try {
            this.style.setState(e2) && this._update(true);
          } catch (o3) {
            t.warnOnce("Unable to perform style diff: " + (o3.message || o3.error || o3) + ".  Rebuilding the style from scratch."), this._updateStyle(e2, i2);
          }
        }, r2.prototype.getStyle = function() {
          if (this.style)
            return this.style.serialize();
        }, r2.prototype.isStyleLoaded = function() {
          return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
        }, r2.prototype.addSource = function(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
        }, r2.prototype.isSourceLoaded = function(e2) {
          var i2 = this.style && this.style.sourceCaches[e2];
          if (void 0 !== i2)
            return i2.loaded();
          this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e2 + "'")));
        }, r2.prototype.areTilesLoaded = function() {
          var t2 = this.style && this.style.sourceCaches;
          for (var e2 in t2) {
            var i2 = t2[e2]._tiles;
            for (var o3 in i2) {
              var r3 = i2[o3];
              if ("loaded" !== r3.state && "errored" !== r3.state)
                return false;
            }
          }
          return true;
        }, r2.prototype.addSourceType = function(t2, e2, i2) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
        }, r2.prototype.removeSource = function(t2) {
          return this.style.removeSource(t2), this._update(true);
        }, r2.prototype.getSource = function(t2) {
          return this.style.getSource(t2);
        }, r2.prototype.addImage = function(e2, i2, o3) {
          void 0 === o3 && (o3 = {});
          var r3 = o3.pixelRatio;
          void 0 === r3 && (r3 = 1);
          var a3 = o3.sdf;
          void 0 === a3 && (a3 = false);
          var n2 = o3.stretchX, s2 = o3.stretchY, l2 = o3.content;
          if (this._lazyInitEmptyStyle(), i2 instanceof Tr || Ir && i2 instanceof Ir) {
            var c3 = t.browser.getImageData(i2);
            this.style.addImage(e2, { data: new t.RGBAImage({ width: c3.width, height: c3.height }, c3.data), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0 });
          } else {
            if (void 0 === i2.width || void 0 === i2.height)
              return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            var u2 = i2;
            this.style.addImage(e2, { data: new t.RGBAImage({ width: i2.width, height: i2.height }, new Uint8Array(i2.data)), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2);
          }
        }, r2.prototype.updateImage = function(e2, i2) {
          var o3 = this.style.getImage(e2);
          if (!o3)
            return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          var r3 = i2 instanceof Tr || Ir && i2 instanceof Ir ? t.browser.getImageData(i2) : i2, a3 = r3.width, n2 = r3.height, s2 = r3.data;
          return void 0 === a3 || void 0 === n2 ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a3 !== o3.data.width || n2 !== o3.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o3.data.replace(s2, !(i2 instanceof Tr || Ir && i2 instanceof Ir)), void this.style.updateImage(e2, o3));
        }, r2.prototype.hasImage = function(e2) {
          return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
        }, r2.prototype.removeImage = function(t2) {
          this.style.removeImage(t2);
        }, r2.prototype.loadImage = function(e2, i2) {
          t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i2);
        }, r2.prototype.listImages = function() {
          return this.style.listImages();
        }, r2.prototype.addLayer = function(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
        }, r2.prototype.moveLayer = function(t2, e2) {
          return this.style.moveLayer(t2, e2), this._update(true);
        }, r2.prototype.removeLayer = function(t2) {
          return this.style.removeLayer(t2), this._update(true);
        }, r2.prototype.getLayer = function(t2) {
          return this.style.getLayer(t2);
        }, r2.prototype.setLayerZoomRange = function(t2, e2, i2) {
          return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
        }, r2.prototype.setFilter = function(t2, e2, i2) {
          return void 0 === i2 && (i2 = {}), this.style.setFilter(t2, e2, i2), this._update(true);
        }, r2.prototype.getFilter = function(t2) {
          return this.style.getFilter(t2);
        }, r2.prototype.setPaintProperty = function(t2, e2, i2, o3) {
          return void 0 === o3 && (o3 = {}), this.style.setPaintProperty(t2, e2, i2, o3), this._update(true);
        }, r2.prototype.getPaintProperty = function(t2, e2) {
          return this.style.getPaintProperty(t2, e2);
        }, r2.prototype.setLayoutProperty = function(t2, e2, i2, o3) {
          return void 0 === o3 && (o3 = {}), this.style.setLayoutProperty(t2, e2, i2, o3), this._update(true);
        }, r2.prototype.getLayoutProperty = function(t2, e2) {
          return this.style.getLayoutProperty(t2, e2);
        }, r2.prototype.setLight = function(t2, e2) {
          return void 0 === e2 && (e2 = {}), this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
        }, r2.prototype.getLight = function() {
          return this.style.getLight();
        }, r2.prototype.setFeatureState = function(t2, e2) {
          return this.style.setFeatureState(t2, e2), this._update();
        }, r2.prototype.removeFeatureState = function(t2, e2) {
          return this.style.removeFeatureState(t2, e2), this._update();
        }, r2.prototype.getFeatureState = function(t2) {
          return this.style.getFeatureState(t2);
        }, r2.prototype.getContainer = function() {
          return this._container;
        }, r2.prototype.getCanvasContainer = function() {
          return this._canvasContainer;
        }, r2.prototype.getCanvas = function() {
          return this._canvas;
        }, r2.prototype._containerDimensions = function() {
          var t2 = 0, e2 = 0;
          return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
        }, r2.prototype._detectMissingCSS = function() {
          "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }, r2.prototype._setupContainer = function() {
          var t2 = this._container;
          t2.classList.add("mapboxgl-map"), (this._missingCSSCanary = i.create("div", "mapboxgl-canary", t2)).style.visibility = "hidden", this._detectMissingCSS();
          var e2 = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t2);
          this._interactive && e2.classList.add("mapboxgl-interactive"), this._canvas = i.create("canvas", "mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          var o3 = this._containerDimensions();
          this._resizeCanvas(o3[0], o3[1]);
          var r3 = this._controlContainer = i.create("div", "mapboxgl-control-container", t2), a3 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(t3) {
            a3[t3] = i.create("div", "mapboxgl-ctrl-" + t3, r3);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }, r2.prototype._resizeCanvas = function(e2, i2) {
          var o3 = t.browser.devicePixelRatio || 1;
          this._canvas.width = o3 * e2, this._canvas.height = o3 * i2, this._canvas.style.width = e2 + "px", this._canvas.style.height = i2 + "px";
        }, r2.prototype._setupPainter = function() {
          var i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
          o3 ? (this.painter = new yo(o3, this.transform), t.webpSupported.testSupport(o3)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
        }, r2.prototype._contextLost = function(e2) {
          e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
        }, r2.prototype._contextRestored = function(e2) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
        }, r2.prototype._onMapScroll = function(t2) {
          if (t2.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }, r2.prototype.loaded = function() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }, r2.prototype._update = function(t2) {
          return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }, r2.prototype._requestRenderFrame = function(t2) {
          return this._update(), this._renderTaskQueue.add(t2);
        }, r2.prototype._cancelRenderFrame = function(t2) {
          this._renderTaskQueue.remove(t2);
        }, r2.prototype._render = function(e2) {
          var i2, o3 = this, r3 = 0, a3 = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (i2 = a3.createQueryEXT(), a3.beginQueryEXT(a3.TIME_ELAPSED_EXT, i2), r3 = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), !this._removed) {
            var n2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              var s2 = this.transform.zoom, l2 = t.browser.now();
              this.style.zoomHistory.update(s2, l2);
              var c3 = new t.EvaluationParameters(s2, { now: l2, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), u2 = c3.crossFadingFactor();
              1 === u2 && u2 === this._crossFadingFactor || (n2 = true, this._crossFadingFactor = u2), this.style.update(c3);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var h3 = t.browser.now() - r3;
              a3.endQueryEXT(a3.TIME_ELAPSED_EXT, i2), setTimeout(function() {
                var e3 = a3.getQueryObjectEXT(i2, a3.QUERY_RESULT_EXT) / 1e6;
                a3.deleteQueryEXT(i2), o3.fire(new t.Event("gpu-timing-frame", { cpuTime: h3, gpuTime: e3 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var p3 = this.painter.collectGpuTimers();
              setTimeout(function() {
                var e3 = o3.painter.queryGpuTimers(p3);
                o3.fire(new t.Event("gpu-timing-layer", { layerTimes: e3 }));
              }, 50);
            }
            var d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true), this;
          }
        }, r2.prototype.remove = function() {
          this._hash && this._hash.remove();
          for (var e2 = 0, i2 = this._controls; e2 < i2.length; e2 += 1)
            i2[e2].onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, false), t.window.removeEventListener("orientationchange", this._onWindowResize, false), t.window.removeEventListener("online", this._onWindowOnline, false));
          var o3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          o3 && o3.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), Cr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = true, this.fire(new t.Event("remove"));
        }, r2.prototype.triggerRepaint = function() {
          var e2 = this;
          this.style && !this._frame && (this._frame = t.browser.frame(function(t2) {
            e2._frame = null, e2._render(t2);
          }));
        }, r2.prototype._onWindowOnline = function() {
          this._update();
        }, r2.prototype._onWindowResize = function(t2) {
          this._trackResize && this.resize({ originalEvent: t2 })._update();
        }, a2.showTileBoundaries.get = function() {
          return !!this._showTileBoundaries;
        }, a2.showTileBoundaries.set = function(t2) {
          this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
        }, a2.showPadding.get = function() {
          return !!this._showPadding;
        }, a2.showPadding.set = function(t2) {
          this._showPadding !== t2 && (this._showPadding = t2, this._update());
        }, a2.showCollisionBoxes.get = function() {
          return !!this._showCollisionBoxes;
        }, a2.showCollisionBoxes.set = function(t2) {
          this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
        }, a2.showOverdrawInspector.get = function() {
          return !!this._showOverdrawInspector;
        }, a2.showOverdrawInspector.set = function(t2) {
          this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
        }, a2.repaint.get = function() {
          return !!this._repaint;
        }, a2.repaint.set = function(t2) {
          this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
        }, a2.vertices.get = function() {
          return !!this._vertices;
        }, a2.vertices.set = function(t2) {
          this._vertices = t2, this._update();
        }, r2.prototype._setCacheLimits = function(e2, i2) {
          t.setCacheLimits(e2, i2);
        }, a2.version.get = function() {
          return t.version;
        }, Object.defineProperties(r2.prototype, a2), r2;
      }(vr);
      function Cr(t2) {
        t2.parentNode && t2.parentNode.removeChild(t2);
      }
      var zr = { showCompass: true, showZoom: true, visualizePitch: false }, Dr = function(e2) {
        var o2 = this;
        this.options = t.extend({}, zr, e2), this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(t2) {
          return t2.preventDefault();
        }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(t2) {
          return o2._map.zoomIn({}, { originalEvent: t2 });
        }), i.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(t2) {
          return o2._map.zoomOut({}, { originalEvent: t2 });
        }), i.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(t2) {
          o2.options.visualizePitch ? o2._map.resetNorthPitch({}, { originalEvent: t2 }) : o2._map.resetNorth({}, { originalEvent: t2 });
        }), this._compassIcon = i.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
      };
      Dr.prototype._updateZoomButtons = function() {
        var t2 = this._map.getZoom(), e2 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
        this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
      }, Dr.prototype._rotateCompassArrow = function() {
        var t2 = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
        this._compassIcon.style.transform = t2;
      }, Dr.prototype.onAdd = function(t2) {
        return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;
      }, Dr.prototype.onRemove = function() {
        i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
      }, Dr.prototype._createButton = function(t2, e2) {
        var o2 = i.create("button", t2, this._container);
        return o2.type = "button", o2.addEventListener("click", e2), o2;
      }, Dr.prototype._setButtonTitle = function(t2, e2) {
        var i2 = this._map._getUIString("NavigationControl." + e2);
        t2.title = i2, t2.setAttribute("aria-label", i2);
      };
      var Ar = function(e2, o2, r2) {
        void 0 === r2 && (r2 = false), this._clickTolerance = 10, this.element = o2, this.mouseRotate = new Xo({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, r2 && (this.mousePitch = new Ho({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(o2, "mousedown", this.mousedown), i.addEventListener(o2, "touchstart", this.touchstart, { passive: false }), i.addEventListener(o2, "touchmove", this.touchmove), i.addEventListener(o2, "touchend", this.touchend), i.addEventListener(o2, "touchcancel", this.reset);
      };
      function Mr(e2, i2, o2) {
        if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
          var r2 = new t.LngLat(e2.lng - 360, e2.lat), a2 = new t.LngLat(e2.lng + 360, e2.lat), n2 = o2.locationPoint(e2).distSqr(i2);
          o2.locationPoint(r2).distSqr(i2) < n2 ? e2 = r2 : o2.locationPoint(a2).distSqr(i2) < n2 && (e2 = a2);
        }
        for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
          var s2 = o2.locationPoint(e2);
          if (s2.x >= 0 && s2.y >= 0 && s2.x <= o2.width && s2.y <= o2.height)
            break;
          e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
        }
        return e2;
      }
      Ar.prototype.down = function(t2, e2) {
        this.mouseRotate.mousedown(t2, e2), this.mousePitch && this.mousePitch.mousedown(t2, e2), i.disableDrag();
      }, Ar.prototype.move = function(t2, e2) {
        var i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e2);
        if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
          var r2 = this.mousePitch.mousemoveWindow(t2, e2);
          r2 && r2.pitchDelta && i2.setPitch(i2.getPitch() + r2.pitchDelta);
        }
      }, Ar.prototype.off = function() {
        var t2 = this.element;
        i.removeEventListener(t2, "mousedown", this.mousedown), i.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), i.removeEventListener(t2, "touchmove", this.touchmove), i.removeEventListener(t2, "touchend", this.touchend), i.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
      }, Ar.prototype.offTemp = function() {
        i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup);
      }, Ar.prototype.mousedown = function(e2) {
        this.down(t.extend({}, e2, { ctrlKey: true, preventDefault: function() {
          return e2.preventDefault();
        } }), i.mousePos(this.element, e2)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup);
      }, Ar.prototype.mousemove = function(t2) {
        this.move(t2, i.mousePos(this.element, t2));
      }, Ar.prototype.mouseup = function(t2) {
        this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
      }, Ar.prototype.touchstart = function(t2) {
        1 !== t2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: function() {
          return t2.preventDefault();
        } }, this._startPos));
      }, Ar.prototype.touchmove = function(t2) {
        1 !== t2.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: function() {
          return t2.preventDefault();
        } }, this._lastPos));
      }, Ar.prototype.touchend = function(t2) {
        0 === t2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }, Ar.prototype.reset = function() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      };
      var Lr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Rr(t2, e2, i2) {
        var o2 = t2.classList;
        for (var r2 in Lr)
          o2.remove("mapboxgl-" + i2 + "-anchor-" + r2);
        o2.add("mapboxgl-" + i2 + "-anchor-" + e2);
      }
      var kr, Br = function(e2) {
        function o2(o3, r2) {
          if (e2.call(this), (o3 instanceof t.window.HTMLElement || r2) && (o3 = t.extend({ element: o3 }, r2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o3 && o3.anchor || "center", this._color = o3 && o3.color || "#3FB1CE", this._scale = o3 && o3.scale || 1, this._draggable = o3 && o3.draggable || false, this._clickTolerance = o3 && o3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = o3 && o3.rotation || 0, this._rotationAlignment = o3 && o3.rotationAlignment || "auto", this._pitchAlignment = o3 && o3.pitchAlignment && "auto" !== o3.pitchAlignment ? o3.pitchAlignment : this._rotationAlignment, o3 && o3.element)
            this._element = o3.element, this._offset = t.Point.convert(o3 && o3.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");
            var a2 = i.createNS("http://www.w3.org/2000/svg", "svg");
            a2.setAttributeNS(null, "display", "block"), a2.setAttributeNS(null, "height", "41px"), a2.setAttributeNS(null, "width", "27px"), a2.setAttributeNS(null, "viewBox", "0 0 27 41");
            var n2 = i.createNS("http://www.w3.org/2000/svg", "g");
            n2.setAttributeNS(null, "stroke", "none"), n2.setAttributeNS(null, "stroke-width", "1"), n2.setAttributeNS(null, "fill", "none"), n2.setAttributeNS(null, "fill-rule", "evenodd");
            var s2 = i.createNS("http://www.w3.org/2000/svg", "g");
            s2.setAttributeNS(null, "fill-rule", "nonzero");
            var l2 = i.createNS("http://www.w3.org/2000/svg", "g");
            l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
            for (var c3 = 0, u2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; c3 < u2.length; c3 += 1) {
              var h3 = u2[c3], p3 = i.createNS("http://www.w3.org/2000/svg", "ellipse");
              p3.setAttributeNS(null, "opacity", "0.04"), p3.setAttributeNS(null, "cx", "10.5"), p3.setAttributeNS(null, "cy", "5.80029008"), p3.setAttributeNS(null, "rx", h3.rx), p3.setAttributeNS(null, "ry", h3.ry), l2.appendChild(p3);
            }
            var d2 = i.createNS("http://www.w3.org/2000/svg", "g");
            d2.setAttributeNS(null, "fill", this._color);
            var _24 = i.createNS("http://www.w3.org/2000/svg", "path");
            _24.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d2.appendChild(_24);
            var f2 = i.createNS("http://www.w3.org/2000/svg", "g");
            f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "fill", "#000000");
            var m2 = i.createNS("http://www.w3.org/2000/svg", "path");
            m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f2.appendChild(m2);
            var g2 = i.createNS("http://www.w3.org/2000/svg", "g");
            g2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g2.setAttributeNS(null, "fill", "#FFFFFF");
            var v3 = i.createNS("http://www.w3.org/2000/svg", "g");
            v3.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            var y3 = i.createNS("http://www.w3.org/2000/svg", "circle");
            y3.setAttributeNS(null, "fill", "#000000"), y3.setAttributeNS(null, "opacity", "0.25"), y3.setAttributeNS(null, "cx", "5.5"), y3.setAttributeNS(null, "cy", "5.5"), y3.setAttributeNS(null, "r", "5.4999962");
            var x2 = i.createNS("http://www.w3.org/2000/svg", "circle");
            x2.setAttributeNS(null, "fill", "#FFFFFF"), x2.setAttributeNS(null, "cx", "5.5"), x2.setAttributeNS(null, "cy", "5.5"), x2.setAttributeNS(null, "r", "5.4999962"), v3.appendChild(y3), v3.appendChild(x2), s2.appendChild(l2), s2.appendChild(d2), s2.appendChild(f2), s2.appendChild(g2), s2.appendChild(v3), a2.appendChild(s2), a2.setAttributeNS(null, "height", 41 * this._scale + "px"), a2.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a2), this._offset = t.Point.convert(o3 && o3.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(t2) {
            t2.preventDefault();
          }), this._element.addEventListener("mousedown", function(t2) {
            t2.preventDefault();
          }), Rr(this._element, this._anchor, "marker"), this._popup = null;
        }
        return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(t2) {
          return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }, o2.prototype.remove = function() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;
        }, o2.prototype.getLngLat = function() {
          return this._lngLat;
        }, o2.prototype.setLngLat = function(e3) {
          return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }, o2.prototype.getElement = function() {
          return this._element;
        }, o2.prototype.setPopup = function(t2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
            if (!("offset" in t2.options)) {
              var e3 = Math.sqrt(Math.pow(13.5, 2) / 2);
              t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e3, -1 * (24.6 + e3)], "bottom-right": [-e3, -1 * (24.6 + e3)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
            }
            this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }, o2.prototype._onKeyPress = function(t2) {
          var e3 = t2.code, i2 = t2.charCode || t2.keyCode;
          "Space" !== e3 && "Enter" !== e3 && 32 !== i2 && 13 !== i2 || this.togglePopup();
        }, o2.prototype._onMapClick = function(t2) {
          var e3 = t2.originalEvent.target, i2 = this._element;
          this._popup && (e3 === i2 || i2.contains(e3)) && this.togglePopup();
        }, o2.prototype.getPopup = function() {
          return this._popup;
        }, o2.prototype.togglePopup = function() {
          var t2 = this._popup;
          return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
        }, o2.prototype._update = function(t2) {
          if (this._map) {
            this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            var e3 = "";
            "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e3 = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
            var o3 = "";
            "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o3 = "rotateX(" + this._map.getPitch() + "deg)"), t2 && "moveend" !== t2.type || (this._pos = this._pos.round()), i.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o3 + " " + e3);
          }
        }, o2.prototype.getOffset = function() {
          return this._offset;
        }, o2.prototype.setOffset = function(e3) {
          return this._offset = t.Point.convert(e3), this._update(), this;
        }, o2.prototype._onMove = function(e3) {
          if (!this._isDragging) {
            var i2 = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = e3.point.dist(this._pointerdownPos) >= i2;
          }
          this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
        }, o2.prototype._onUp = function() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
        }, o2.prototype._addDragHandler = function(t2) {
          this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }, o2.prototype.setDraggable = function(t2) {
          return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }, o2.prototype.isDraggable = function() {
          return this._draggable;
        }, o2.prototype.setRotation = function(t2) {
          return this._rotation = t2 || 0, this._update(), this;
        }, o2.prototype.getRotation = function() {
          return this._rotation;
        }, o2.prototype.setRotationAlignment = function(t2) {
          return this._rotationAlignment = t2 || "auto", this._update(), this;
        }, o2.prototype.getRotationAlignment = function() {
          return this._rotationAlignment;
        }, o2.prototype.setPitchAlignment = function(t2) {
          return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
        }, o2.prototype.getPitchAlignment = function() {
          return this._pitchAlignment;
        }, o2;
      }(t.Evented), Or = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true }, Fr = 0, Ur = false, Nr = function(e2) {
        function o2(i2) {
          e2.call(this), this.options = t.extend({}, Or, i2), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.onAdd = function(e3) {
          var o3;
          return this._map = e3, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), o3 = this._setupUI, void 0 !== kr ? o3(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then(function(t2) {
            o3(kr = "denied" !== t2.state);
          }) : o3(kr = !!t.window.navigator.geolocation), this._container;
        }, o2.prototype.onRemove = function() {
          void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = false;
        }, o2.prototype._isOutOfMapMaxBounds = function(t2) {
          var e3 = this._map.getMaxBounds(), i2 = t2.coords;
          return e3 && (i2.longitude < e3.getWest() || i2.longitude > e3.getEast() || i2.latitude < e3.getSouth() || i2.latitude > e3.getNorth());
        }, o2.prototype._setErrorState = function() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }, o2.prototype._onSuccess = function(e3) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(e3))
              return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = e3, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
          }
        }, o2.prototype._updateCamera = function(e3) {
          var i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o3 = e3.coords.accuracy, r2 = this._map.getBearing(), a2 = t.extend({ bearing: r2 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o3), a2, { geolocateSource: true });
        }, o2.prototype._updateMarker = function(e3) {
          if (e3) {
            var i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }, o2.prototype._updateCircleRadius = function() {
          var t2 = this._map._container.clientHeight / 2, e3 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o3 = e3.distanceTo(i2), r2 = Math.ceil(2 * this._accuracy / o3);
          this._circleElement.style.width = r2 + "px", this._circleElement.style.height = r2 + "px";
        }, o2.prototype._onZoom = function() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }, o2.prototype._onError = function(e3) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === e3.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                var i2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = i2, this._geolocateButton.setAttribute("aria-label", i2), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === e3.code && Ur)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
          }
        }, o2.prototype._finish = function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }, o2.prototype._setupUI = function(e3) {
          var o3 = this;
          if (this._container.addEventListener("contextmenu", function(t2) {
            return t2.preventDefault();
          }), this._geolocateButton = i.create("button", "mapboxgl-ctrl-geolocate", this._container), i.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", false === e3) {
            t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            var r2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = true, this._geolocateButton.title = r2, this._geolocateButton.setAttribute("aria-label", r2);
          } else {
            var a2 = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = a2, this._geolocateButton.setAttribute("aria-label", a2);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", function(e4) {
            e4.geolocateSource || "ACTIVE_LOCK" !== o3._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (o3._watchState = "BACKGROUND", o3._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), o3._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), o3.fire(new t.Event("trackuserlocationend")));
          });
        }, o2.prototype.trigger = function() {
          if (!this._setup)
            return t.warnOnce("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Fr--, Ur = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              var e3;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e3 = { maximumAge: 6e5, timeout: 0 }, Ur = true) : (e3 = this.options.positionOptions, Ur = false), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e3);
            }
          } else
            t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }, o2.prototype._clearWatch = function() {
          t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }, o2;
      }(t.Evented), Zr = { maxWidth: 100, unit: "metric" }, qr = function(e2) {
        this.options = t.extend({}, Zr, e2), t.bindAll(["_onMove", "setUnit"], this);
      };
      function jr(t2, e2, i2) {
        var o2 = i2 && i2.maxWidth || 100, r2 = t2._container.clientHeight / 2, a2 = t2.unproject([0, r2]), n2 = t2.unproject([o2, r2]), s2 = a2.distanceTo(n2);
        if (i2 && "imperial" === i2.unit) {
          var l2 = 3.2808 * s2;
          l2 > 5280 ? Vr(e2, o2, l2 / 5280, t2._getUIString("ScaleControl.Miles")) : Vr(e2, o2, l2, t2._getUIString("ScaleControl.Feet"));
        } else
          i2 && "nautical" === i2.unit ? Vr(e2, o2, s2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : s2 >= 1e3 ? Vr(e2, o2, s2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : Vr(e2, o2, s2, t2._getUIString("ScaleControl.Meters"));
      }
      function Vr(t2, e2, i2, o2) {
        var r2, a2, n2, s2 = (r2 = i2, (a2 = Math.pow(10, ("" + Math.floor(r2)).length - 1)) * (n2 = (n2 = r2 / a2) >= 10 ? 10 : n2 >= 5 ? 5 : n2 >= 3 ? 3 : n2 >= 2 ? 2 : n2 >= 1 ? 1 : function(t3) {
          var e3 = Math.pow(10, Math.ceil(-Math.log(t3) / Math.LN10));
          return Math.round(t3 * e3) / e3;
        }(n2)));
        t2.style.width = e2 * (s2 / i2) + "px", t2.innerHTML = s2 + "&nbsp;" + o2;
      }
      qr.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, qr.prototype._onMove = function() {
        jr(this._map, this._container, this.options);
      }, qr.prototype.onAdd = function(t2) {
        return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
      }, qr.prototype.onRemove = function() {
        i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
      }, qr.prototype.setUnit = function(t2) {
        this.options.unit = t2, jr(this._map, this._container, this.options);
      };
      var Gr = function(e2) {
        this._fullscreen = false, e2 && e2.container && (e2.container instanceof t.window.HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");
      };
      Gr.prototype.onAdd = function(e2) {
        return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
      }, Gr.prototype.onRemove = function() {
        i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
      }, Gr.prototype._checkFullscreenSupport = function() {
        return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);
      }, Gr.prototype._setupUI = function() {
        var e2 = this._fullscreenButton = i.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
        i.create("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", true), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
      }, Gr.prototype._updateTitle = function() {
        var t2 = this._getTitle();
        this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
      }, Gr.prototype._getTitle = function() {
        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
      }, Gr.prototype._isFullscreen = function() {
        return this._fullscreen;
      }, Gr.prototype._changeIcon = function() {
        (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
      }, Gr.prototype._onClickFullscreen = function() {
        this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
      };
      var Wr = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Xr = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Hr = function(e2) {
        function o2(i2) {
          e2.call(this), this.options = t.extend(Object.create(Wr), i2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(e3) {
          return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
        }, o2.prototype.isOpen = function() {
          return !!this._map;
        }, o2.prototype.remove = function() {
          return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
        }, o2.prototype.getLngLat = function() {
          return this._lngLat;
        }, o2.prototype.setLngLat = function(e3) {
          return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }, o2.prototype.trackPointer = function() {
          return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }, o2.prototype.getElement = function() {
          return this._container;
        }, o2.prototype.setText = function(e3) {
          return this.setDOMContent(t.window.document.createTextNode(e3));
        }, o2.prototype.setHTML = function(e3) {
          var i2, o3 = t.window.document.createDocumentFragment(), r2 = t.window.document.createElement("body");
          for (r2.innerHTML = e3; i2 = r2.firstChild; )
            o3.appendChild(i2);
          return this.setDOMContent(o3);
        }, o2.prototype.getMaxWidth = function() {
          return this._container && this._container.style.maxWidth;
        }, o2.prototype.setMaxWidth = function(t2) {
          return this.options.maxWidth = t2, this._update(), this;
        }, o2.prototype.setDOMContent = function(t2) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = i.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }, o2.prototype.addClassName = function(t2) {
          this._container && this._container.classList.add(t2);
        }, o2.prototype.removeClassName = function(t2) {
          this._container && this._container.classList.remove(t2);
        }, o2.prototype.setOffset = function(t2) {
          return this.options.offset = t2, this._update(), this;
        }, o2.prototype.toggleClassName = function(t2) {
          if (this._container)
            return this._container.classList.toggle(t2);
        }, o2.prototype._createCloseButton = function() {
          this.options.closeButton && (this._closeButton = i.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }, o2.prototype._onMouseUp = function(t2) {
          this._update(t2.point);
        }, o2.prototype._onMouseMove = function(t2) {
          this._update(t2.point);
        }, o2.prototype._onDrag = function(t2) {
          this._update(t2.point);
        }, o2.prototype._update = function(e3) {
          var o3 = this;
          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(t2) {
            return o3._container.classList.add(t2);
          }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e3)) {
            var r2 = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat), a2 = this.options.anchor, n2 = function e4(i2) {
              if (i2) {
                if ("number" == typeof i2) {
                  var o4 = Math.round(Math.sqrt(0.5 * Math.pow(i2, 2)));
                  return { center: new t.Point(0, 0), top: new t.Point(0, i2), "top-left": new t.Point(o4, o4), "top-right": new t.Point(-o4, o4), bottom: new t.Point(0, -i2), "bottom-left": new t.Point(o4, -o4), "bottom-right": new t.Point(-o4, -o4), left: new t.Point(i2, 0), right: new t.Point(-i2, 0) };
                }
                if (i2 instanceof t.Point || Array.isArray(i2)) {
                  var r3 = t.Point.convert(i2);
                  return { center: r3, top: r3, "top-left": r3, "top-right": r3, bottom: r3, "bottom-left": r3, "bottom-right": r3, left: r3, right: r3 };
                }
                return { center: t.Point.convert(i2.center || [0, 0]), top: t.Point.convert(i2.top || [0, 0]), "top-left": t.Point.convert(i2["top-left"] || [0, 0]), "top-right": t.Point.convert(i2["top-right"] || [0, 0]), bottom: t.Point.convert(i2.bottom || [0, 0]), "bottom-left": t.Point.convert(i2["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(i2["bottom-right"] || [0, 0]), left: t.Point.convert(i2.left || [0, 0]), right: t.Point.convert(i2.right || [0, 0]) };
              }
              return e4(new t.Point(0, 0));
            }(this.options.offset);
            if (!a2) {
              var s2, l2 = this._container.offsetWidth, c3 = this._container.offsetHeight;
              s2 = r2.y + n2.bottom.y < c3 ? ["top"] : r2.y > this._map.transform.height - c3 ? ["bottom"] : [], r2.x < l2 / 2 ? s2.push("left") : r2.x > this._map.transform.width - l2 / 2 && s2.push("right"), a2 = 0 === s2.length ? "bottom" : s2.join("-");
            }
            var u2 = r2.add(n2[a2]).round();
            i.setTransform(this._container, Lr[a2] + " translate(" + u2.x + "px," + u2.y + "px)"), Rr(this._container, a2, "popup");
          }
        }, o2.prototype._focusFirstElement = function() {
          if (this.options.focusAfterOpen && this._container) {
            var t2 = this._container.querySelector(Xr);
            t2 && t2.focus();
          }
        }, o2.prototype._onClose = function() {
          this.remove();
        }, o2;
      }(t.Evented), Kr = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: Sr, NavigationControl: Dr, GeolocateControl: Nr, AttributionControl: yr, ScaleControl: qr, FullscreenControl: Gr, Popup: Hr, Marker: Br, Style: je, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, prewarm: function() {
        Ft().acquire(Rt);
      }, clearPrewarmedResources: function() {
        var t2 = Bt;
        t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return t.config.ACCESS_TOKEN;
      }, set accessToken(e2) {
        t.config.ACCESS_TOKEN = e2;
      }, get baseApiUrl() {
        return t.config.API_URL;
      }, set baseApiUrl(e2) {
        t.config.API_URL = e2;
      }, get workerCount() {
        return kt.workerCount;
      }, set workerCount(t2) {
        kt.workerCount = t2;
      }, get maxParallelImageRequests() {
        return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(e2) {
        t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
      }, clearStorage: function(e2) {
        t.clearTileCache(e2);
      }, workerUrl: "" };
      return Kr;
    });
    return mapboxgl2;
  });
})(mapboxGl);
const mapboxgl = mapboxGl.exports;
class MapBox extends Layer {
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.accessToken;
    delete baseOptions.style;
    delete baseOptions.container;
    delete baseOptions.xyz;
    super(baseOptions);
    this.set("xyz", options.maplibreOptions.xyz);
    this.set("xyz_custom", options.maplibreOptions.xyz_custom);
    this.xyz_ = options.xyz;
    if (options.accessToken) {
      mapboxgl.accessToken = options.accessToken;
    }
    this.map_ = new mapboxgl.Map({
      container: options.maplibreOptions.container,
      style: options.maplibreOptions.style,
      attributionControl: false,
      interactive: false
    });
    this.maplibreMap = this.map_;
  }
  getMapBoxMap() {
    return this.map_;
  }
  getMapLibreMap() {
    return this.map_;
  }
  render(frameState) {
    const canvas = this.map_.getCanvas();
    const viewState = frameState.viewState;
    canvas.style.position = "absolute";
    const visible = this.getVisible();
    canvas.style.display = visible ? "block" : "none";
    const opacity = this.getOpacity().toString();
    if (opacity !== canvas.style.opacity) {
      canvas.style.opacity = opacity;
    }
    const rotation = viewState.rotation;
    if (rotation) {
      this.map_.rotateTo(toDegrees(-rotation), {
        animate: false
      });
    }
    this.map_.jumpTo({
      center: toLonLat(viewState.center),
      zoom: viewState.zoom - 1,
      animate: false
    });
    if (this.map_._frame) {
      this.map_._frame.cancel();
      this.map_._frame = null;
    }
    this.map_._render();
    return canvas;
  }
  setLayerVisibility(name, visible) {
    this.map_.setLayoutProperty(
      name,
      "visibility",
      visible ? "visible" : "none"
    );
  }
  getStyle() {
    return this.map_.getStyle();
  }
  getXYZ() {
    return this.get("xyz");
  }
}
const layersCache = /* @__PURE__ */ new Map();
class StorageStyleMapper {
  styleSerialToStyle(styleText) {
    if (styleText) {
      return JSON.parse(decodeURIComponent(styleText)) || [];
    }
    return [];
  }
  styleLocalStorageToStyle(styleText) {
    if (styleText) {
      return JSON.parse(styleText).medium || [];
    }
    return [];
  }
  styleToSerial(style) {
    if (style && style.length > 0) {
      return JSON.stringify(style);
    }
    return "";
  }
  styleToLocalStorage(style) {
    if (style && style.length > 0) {
      return JSON.stringify({ medium: style });
    }
    return "";
  }
}
const storageStyleMapper = new StorageStyleMapper();
function debounce(fn, delay) {
  let timeoutID;
  return (...args) => {
    clearTimeout(timeoutID);
    timeoutID = setTimeout(() => {
      fn.apply(args);
    }, delay);
  };
}
function stringToNumber(text2) {
  return (text2 == null ? void 0 : text2.trim()) && !isNaN(Number(text2)) ? Number(text2) : void 0;
}
function stringToNumbers(text2, separator) {
  return (text2 == null ? void 0 : text2.split(separator).map(
    (item) => item !== null && !isNaN(Number(item)) ? parseFloat(item) : void 0
  )) || [];
}
function stringToBooleans(text2, separator) {
  return (text2 == null ? void 0 : text2.split(separator).map(stringToBoolean)) || [];
}
function stringToBoolean(text2) {
  return (text2 == null ? void 0 : text2.trim()) === "true" ? true : (text2 == null ? void 0 : text2.trim()) === "false" ? false : void 0;
}
function isHiDpi() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
const SP_KEY_IPV6 = "ipv6";
const SP_KEY_APPLOGIN = "applogin";
const SP_KEY_LOCALFORAGE = "localforage";
const SP_KEY_DEBUG = "debug";
const SP_KEY_FID = "fid";
const SP_KEY_LANG = "lang";
const SP_KEY_LAYERS_OPEN = "layersOpen";
const SP_KEY_ADDRESS = "address";
const SP_KEY_VERSION = "version";
const SP_KEY_MAPID = "map_id";
const SP_KEY_LAYERS = "layers";
const SP_KEY_BGLAYER = "bgLayer";
const SP_KEY_OPACITIES = "opacities";
const SP_KEY_THEME = "theme";
const SP_KEY_ZOOM = "zoom";
const SP_KEY_SRS = "SRS";
const SP_KEY_X = "X";
const SP_KEY_Y = "Y";
const SP_KEY_SERIAL = "serial";
const SP_KEYS_STYLE = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
];
const SP_KEY_LAYERCOMPARATOR = "lc";
const SP_KEY_LAYERCOMPARATOR_SLIDERRATIO = "sliderRatio";
const SP_KEY_V2_BGLAYEROPACITY = "bgOpacity";
const SP_KEY_V2_LAYERSINDICIES = "layers_indices";
const SP_KEY_V2_LAYERSOPACITIES = "layers_opacity";
const SP_KEY_V2_LAYERSVISIBILITY = "layers_visibility";
var SP_AVAILABLE_STORAGES = /* @__PURE__ */ ((SP_AVAILABLE_STORAGES2) => {
  SP_AVAILABLE_STORAGES2[SP_AVAILABLE_STORAGES2["localStorage"] = 0] = "localStorage";
  SP_AVAILABLE_STORAGES2[SP_AVAILABLE_STORAGES2["permalink"] = 1] = "permalink";
  SP_AVAILABLE_STORAGES2[SP_AVAILABLE_STORAGES2["permalinkAsPath"] = 2] = "permalinkAsPath";
  SP_AVAILABLE_STORAGES2[SP_AVAILABLE_STORAGES2["permalinkAndLocalStorage"] = 3] = "permalinkAndLocalStorage";
  return SP_AVAILABLE_STORAGES2;
})(SP_AVAILABLE_STORAGES || {});
class StatePersistorRulesHelper {
}
class RulesReadHelper extends StatePersistorRulesHelper {
  static processRules(paramKeys) {
    if (RulesReadHelper.ruleUseLocalStorage(paramKeys)) {
      return SP_AVAILABLE_STORAGES.localStorage;
    }
    return SP_AVAILABLE_STORAGES.permalink;
  }
  static processRulesForKey(key, paramKeys) {
    if (key === SP_KEY_THEME && {}.VITE_DEPLOY_GHPAGES !== "true")
      return SP_AVAILABLE_STORAGES.permalinkAsPath;
    if (SP_KEYS_STYLE.includes(key)) {
      return SP_AVAILABLE_STORAGES.localStorage;
    }
    if (key === SP_KEY_SERIAL) {
      return SP_AVAILABLE_STORAGES.permalink;
    }
    if (key === SP_KEY_LAYERS_OPEN) {
      return SP_AVAILABLE_STORAGES.localStorage;
    }
    return void 0;
  }
  static ruleUseLocalStorage(paramKeys) {
    return [ruleEmptyParams$1, ruleOneParamOnly, ruleThreeParams].reduce(
      (prevResult, currRule) => prevResult || currRule(paramKeys),
      false
    );
  }
}
const ruleEmptyParams$1 = (paramKeys) => {
  return Object.keys(paramKeys).length === 0;
};
const ruleOneParamOnly = (paramKeys) => {
  return Object.keys(paramKeys).length === 1 && (paramKeys.hasOwnProperty(SP_KEY_IPV6) || paramKeys.hasOwnProperty(SP_KEY_APPLOGIN) || paramKeys.hasOwnProperty(SP_KEY_LOCALFORAGE));
};
const ruleThreeParams = (paramKeys) => {
  return Object.keys(paramKeys).length === 3 && paramKeys.hasOwnProperty(SP_KEY_IPV6) && paramKeys.hasOwnProperty(SP_KEY_APPLOGIN) && paramKeys.hasOwnProperty(SP_KEY_LOCALFORAGE);
};
class RulesWriteHelper extends StatePersistorRulesHelper {
  static processRules() {
    return SP_AVAILABLE_STORAGES.permalinkAndLocalStorage;
  }
  static processRulesForKey(key, paramKeys) {
    if (RulesWriteHelper.ruleUsePermalink(key)) {
      return SP_AVAILABLE_STORAGES.permalink;
    }
    if (key === SP_KEY_LAYERS_OPEN) {
      return SP_AVAILABLE_STORAGES.localStorage;
    }
    if (SP_KEYS_STYLE.includes(key)) {
      return SP_AVAILABLE_STORAGES.localStorage;
    }
    if (key === SP_KEY_SERIAL) {
      return SP_AVAILABLE_STORAGES.permalink;
    }
    if (key === SP_KEY_THEME) {
      return SP_AVAILABLE_STORAGES.permalinkAsPath;
    }
    return void 0;
  }
  static ruleUsePermalink(currentKey) {
    return [
      ruleIsLayerComparator,
      ruleIsVersion,
      ruleIsThemeForGhPagesHACK
    ].reduce(
      (prevResult, currRule) => prevResult || currRule(currentKey),
      false
    );
  }
}
const ruleIsLayerComparator = (currentKey) => {
  return currentKey === SP_KEY_LAYERCOMPARATOR || currentKey === SP_KEY_LAYERCOMPARATOR_SLIDERRATIO;
};
const ruleIsVersion = (currentKey) => {
  return currentKey === SP_KEY_VERSION;
};
const ruleIsThemeForGhPagesHACK = (currentKey) => {
  return currentKey === SP_KEY_THEME && {}.VITE_DEPLOY_GHPAGES === "true";
};
class UrlStorage {
  constructor() {
    __publicField(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(index2) {
    throw new Error("Method key() not implemented. " + index2);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (prevObj, currParam) => {
        const [currKey, currValue] = currParam.split("=");
        return { ...prevObj, [currKey]: currValue };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((val) => val.split("=")[1]);
  }
  setItem(key, value) {
    const params2 = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    params2.set(encodeURIComponent(key), encodeURIComponent(value));
    try {
      window.history.replaceState(null, "", "?" + params2.toString());
    } catch (error2) {
    }
  }
  getItem(key) {
    return this.getSnappedUrl().searchParams.get(key);
  }
  removeItem(key) {
    const params2 = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    params2.delete(key);
    try {
      window.history.replaceState(null, "", "?" + params2.toString());
    } catch (error2) {
    }
  }
  encodeQueryParam(key, value) {
    return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
  }
}
const urlStorage = new UrlStorage();
class UrlStorageAsPath extends UrlStorage {
  getItem(key) {
    const paths = this.getSnappedUrl().pathname.split("/");
    const keyPathIndex = paths.findIndex((path) => path === key);
    return paths[keyPathIndex + 1];
  }
  setItem(key, value) {
    const queryParams = new URL(window.location.toString()).search;
    const url = `${"/dev/main.html/"}${key}/${value}${queryParams}`;
    try {
      window.history.replaceState(null, "", url);
    } catch (error2) {
    }
  }
}
const urlPathStorage = new UrlStorageAsPath();
class StorageProxy {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(index2) {
    throw new Error("Method key() not implemented. " + index2);
  }
  removeItem(key) {
    const writeStorages = this.getWriteStorages(key);
    writeStorages == null ? void 0 : writeStorages.map(
      (storage) => storage.removeItem(key)
    );
  }
  setItem(key, value) {
    this.setValue(key, value);
  }
  getItem(key) {
    return this.getValue(key);
  }
  get paramKeys() {
    return urlStorage.getSnappedParamsAsObj();
  }
  getValue(key) {
    var _a;
    const readStorage = (_a = this.correspondingStorages(
      RulesReadHelper.processRules(this.paramKeys)
    )) == null ? void 0 : _a.pop();
    const storage = this.storageForKey(key, RulesReadHelper, readStorage);
    return storage ? storage.getItem(key) : null;
  }
  setValue(key, value) {
    const writeStorages = this.getWriteStorages(key);
    writeStorages == null ? void 0 : writeStorages.map(
      (storage) => storage.setItem(key, value)
    );
  }
  getWriteStorages(key) {
    const writeStorages = this.correspondingStorages(
      RulesWriteHelper.processRules()
    );
    const storage = this.storageForKey(key, RulesWriteHelper);
    return storage ? [storage] : writeStorages;
  }
  storageForKey(key, ruler, defaultStorage) {
    var _a;
    const overriddenStorage = (_a = this.correspondingStorages(
      ruler.processRulesForKey(key, this.paramKeys)
    )) == null ? void 0 : _a.pop();
    return overriddenStorage != null ? overriddenStorage : defaultStorage;
  }
  correspondingStorages(depositsKey) {
    if (depositsKey === SP_AVAILABLE_STORAGES.permalinkAndLocalStorage) {
      return [urlStorage, localStorage];
    } else if (depositsKey === SP_AVAILABLE_STORAGES.localStorage) {
      return [localStorage];
    } else if (depositsKey === SP_AVAILABLE_STORAGES.permalink) {
      return [urlStorage];
    } else if (depositsKey === SP_AVAILABLE_STORAGES.permalinkAsPath) {
      return [urlPathStorage];
    }
    return void 0;
  }
}
const storageProxy = new StorageProxy();
function isV3(paramKeys) {
  return ruleEmptyParams(paramKeys) || ruleOneParamAmong(paramKeys) || ruleTwoParamsAmong(paramKeys) || ruleThreeParamsAmong(paramKeys);
}
const ruleEmptyParams = (paramKeys) => {
  return Object.keys(paramKeys).length === 0;
};
const ruleOneParamAmong = (paramKeys) => {
  const keys = Object.keys(paramKeys);
  return Object.keys(paramKeys).length === 1 && [
    SP_KEY_IPV6,
    SP_KEY_APPLOGIN,
    SP_KEY_LOCALFORAGE,
    SP_KEY_FID,
    SP_KEY_LANG,
    SP_KEY_ADDRESS,
    SP_KEY_DEBUG
  ].some((spKey) => keys.indexOf(spKey) !== -1);
};
const ruleTwoParamsAmong = (paramKeys) => {
  const keys = Object.keys(paramKeys);
  const fnEvery = (spKey) => keys.indexOf(spKey) !== -1;
  const tuples = [
    [SP_KEY_APPLOGIN, SP_KEY_LOCALFORAGE],
    [SP_KEY_DEBUG, SP_KEY_FID],
    [SP_KEY_LANG, SP_KEY_FID],
    [SP_KEY_DEBUG, SP_KEY_LANG],
    [SP_KEY_DEBUG, SP_KEY_ADDRESS],
    [SP_KEY_LANG, SP_KEY_ADDRESS]
  ];
  return Object.keys(paramKeys).length === 2 && tuples.reduce(
    (prevResult, currRule) => prevResult || currRule.every(fnEvery),
    false
  );
};
const ruleThreeParamsAmong = (paramKeys) => {
  const keys = Object.keys(paramKeys);
  const fnEvery = (spKey) => keys.indexOf(spKey) !== -1;
  const tuple1 = [SP_KEY_IPV6, SP_KEY_APPLOGIN, SP_KEY_LOCALFORAGE].every(
    fnEvery
  );
  const tuple2 = [SP_KEY_DEBUG, SP_KEY_FID, SP_KEY_LANG].every(fnEvery);
  const tuple3 = [SP_KEY_DEBUG, SP_KEY_ADDRESS, SP_KEY_LANG].every(fnEvery);
  return Object.keys(paramKeys).length === 3 && (tuple1 || tuple2 || tuple3);
};
class StorageHelper {
  constructor() {
    __publicField(this, "intialVersion");
    const paramKeys = storageProxy.paramKeys;
    const version2 = this.getValue(SP_KEY_VERSION, stringToNumber);
    this.intialVersion = version2 ? Math.max(2, Math.min(version2, 3)) : isV3(paramKeys) ? 3 : 2;
    this.setValue(SP_KEY_VERSION, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(value, mapper) {
    return mapper ? mapper(value) : value;
  }
  mapToStorage(value, mapper) {
    return mapper ? mapper(value) : String(value);
  }
  getValue(key, mapper) {
    return this.mapToEntity(storageProxy.getValue(key), mapper);
  }
  setValue(key, value, mapper) {
    storageProxy.setValue(key, this.mapToStorage(value, mapper));
  }
  removeItem(key) {
    storageProxy.removeItem(key);
  }
}
const storageHelper = new StorageHelper();
const stylePropertyTypeList = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
];
const bgConfigFixture = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: true
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: false,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: false
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: false,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: false
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: false,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: false
      },
      {
        unlocalized_label: "Kids",
        hillshade: false,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: false
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: false,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: false
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: false,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: false
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: true
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: true
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: true
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: true
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: true
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: true
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: true
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: true
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: true
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: true
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: true
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: true
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: true
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: true
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function useMvtStyles() {
  function getDefaultMapBoxStyleUrl(label) {
    const searchParams = new URLSearchParams(document.location.search);
    const server = searchParams.get("embeddedserver");
    const proto = searchParams.get("embeddedserverprotocol") || "http";
    const url = (server ? `${proto}://${server}` : "https://vectortiles.geoportail.lu") + `/styles/${label}/style.json`;
    return url;
  }
  function getDefaultMapBoxStyleXYZ(label) {
    return `https://vectortiles.geoportail.lu/styles/${label}/{z}/{x}/{y}.png`;
  }
  function isValidSerial(serial) {
    const isValidUUIDv4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi;
    return isValidUUIDv4Regex.test(serial);
  }
  const styleStore = useStyleStore();
  function setCustomStyleSerial(bgLayer, serial) {
    if (bgLayer === null || bgLayer === void 0)
      return;
    const newVectorSources = /* @__PURE__ */ new Map();
    styleStore.bgVectorSources.forEach((vectorSource, key) => {
      if (key === bgLayer.id) {
        const newVectorSource = Object.assign({}, vectorSource, {
          xyz_custom: serial
        });
        newVectorSources.set(key, newVectorSource);
      } else {
        newVectorSources.set(key, vectorSource);
      }
    });
    styleStore.setBgVectorSources(newVectorSources);
  }
  function setConfigForLayer(label, keyword2, isAuthenticated = false) {
    const xyz_custom = "";
    const defaultMapBoxStyle = getDefaultMapBoxStyleUrl(keyword2);
    const defaultMapBoxStyleXYZ = getDefaultMapBoxStyleXYZ(keyword2);
    const config = {
      label,
      defaultMapBoxStyle,
      defaultMapBoxStyleXYZ,
      xyz: defaultMapBoxStyleXYZ,
      xyz_custom,
      style: defaultMapBoxStyle
    };
    const serial = new URLSearchParams(window.location.search).get("serial");
    const serialLayer = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (serial) {
      if (isValidSerial(serial)) {
        console.log(serialLayer);
      }
    } else if (isAuthenticated)
      ;
    else {
      return Promise.resolve(config);
    }
    return Promise.resolve(config);
  }
  function getRoadStyleFromSimpleStyle(simpleStyle) {
    const med_road_style = bgConfigFixture().medium_default_styles.road;
    if (simpleStyle) {
      simpleStyle.colors.forEach((element, i) => {
        med_road_style[i].color = element;
      });
      const hillshadeIndex = med_road_style.findIndex(
        (el) => el.label === "Hillshade"
      );
      med_road_style[hillshadeIndex].visible = simpleStyle.hillshade;
    }
    return med_road_style;
  }
  function applyDefaultStyle(bgLayer, baseStyles, activeStyle) {
    if (!bgLayer)
      return;
    if (!baseStyles.get(bgLayer.id))
      return;
    const baseStyle = JSON.parse(
      JSON.stringify(baseStyles.get(bgLayer.id))
    );
    if (!baseStyle)
      return;
    if (!baseStyle || !baseStyle.layers)
      return;
    if (activeStyle) {
      activeStyle.forEach((styleItem) => {
        baseStyle == null ? void 0 : baseStyle.layers.forEach((layer, i) => {
          for (const styleProperty of stylePropertyTypeList) {
            const props = styleItem[`${styleProperty}s`] || [];
            if (props.includes(layer.id)) {
              const basePaint = Object.assign(
                {},
                baseStyle.layers[i].paint
              );
              if (styleItem.color) {
                basePaint[`${styleProperty}-color`] = styleItem.color;
                basePaint[`${styleProperty}-opacity`] = 1;
                baseStyle.layers[i].paint = basePaint;
              }
              baseStyle.layers[i].layout = Object.assign(
                {},
                baseStyle.layers[i].layout,
                { visibility: styleItem.visible ? "visible" : "none" }
              );
            }
          }
        });
      });
    }
    return baseStyle;
  }
  function unregisterStyle(styleId, registerUrls) {
    if (styleId === null) {
      return Promise.resolve();
    } else {
      const url = `${registerUrls.get("delete")}?id=${styleId}`;
      return fetch(url).catch(() => "");
    }
  }
  function registerStyle(style, oldStyleId, registerUrls) {
    return unregisterStyle(oldStyleId, registerUrls).then(() => {
      const formData = new FormData();
      const data = JSON.stringify(style);
      const blob = new Blob([data], { type: "application/json" });
      formData.append("style", blob, "style.json");
      const options = {
        method: "POST",
        body: formData
      };
      return fetch(registerUrls.get("upload") || "", options).then((response) => response.json()).then((result) => {
        return result.id;
      });
    });
  }
  function applyConsolidatedStyle(bgLayer, consolidatedStyle) {
    if (!consolidatedStyle)
      return;
    const mbMap = bgLayer.maplibreMap;
    if (!mbMap)
      return;
    if (mbMap.loaded()) {
      mbMap.setStyle(consolidatedStyle);
    } else {
      new Promise((resolve2) => mbMap.once("data", resolve2)).then(
        () => mbMap.setStyle(consolidatedStyle)
      );
    }
  }
  function getVectorId(bgLayer) {
    const bgLayerDef = bgConfigFixture().bg_layers.find(
      (l) => l.id == (bgLayer == null ? void 0 : bgLayer.id)
    );
    return bgLayerDef == null ? void 0 : bgLayerDef.vector_id;
  }
  function isLayerStyleEditable(bgLayer) {
    const bgLayerDef = bgConfigFixture().bg_layers.find(
      (l) => l.id == (bgLayer == null ? void 0 : bgLayer.id)
    );
    return (bgLayerDef == null ? void 0 : bgLayerDef.vector_id) !== void 0;
  }
  function getStyleCapabilitiesFromLayer(bgLayer) {
    const bgLayerDef = bgConfigFixture().bg_layers.find(
      (l) => l.id == (bgLayer == null ? void 0 : bgLayer.id)
    );
    return {
      isEditable: (bgLayerDef == null ? void 0 : bgLayerDef.vector_id) !== void 0,
      hasSimpleStyle: (bgLayerDef == null ? void 0 : bgLayerDef.simple_style_class) !== void 0,
      hasAdvancedStyle: (bgLayerDef == null ? void 0 : bgLayerDef.medium_style_class) !== void 0,
      hasExpertStyle: (bgLayerDef == null ? void 0 : bgLayerDef.expert_style_class) !== void 0
    };
  }
  function checkSelection(bgStyle, simpleStyleConf) {
    return simpleStyleConf.map(
      (style) => Object.assign(style, {
        selected: style.colors.every(
          (element, i) => {
            var _a;
            return ((_a = bgStyle[i]) == null ? void 0 : _a.color) === element;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl,
    getDefaultMapBoxStyleXYZ,
    setConfigForLayer,
    getRoadStyleFromSimpleStyle,
    applyDefaultStyle,
    applyConsolidatedStyle,
    getVectorId,
    setCustomStyleSerial,
    unregisterStyle,
    registerStyle,
    checkSelection,
    isLayerStyleEditable,
    getStyleCapabilitiesFromLayer
  };
}
const useStyleStore = defineStore(
  "style",
  () => {
    const styleService = useMvtStyles();
    const bgStyle = shallowRef();
    const bgVectorSources = shallowRef(/* @__PURE__ */ new Map());
    const bgVectorBaseStyles = shallowRef(
      /* @__PURE__ */ new Map()
    );
    const isExpertStyleActive = shallowRef(false);
    const styleSerial = shallowRef(null);
    const appliedStyle = shallowRef();
    const registerUrls = shallowRef(
      /* @__PURE__ */ new Map([
        ["get", "/getvtstyle"],
        ["upload", "/uploadvtstyle"],
        ["delete", "/deletevtstyle"]
      ])
    );
    const promises = [];
    bgConfigFixture().bg_layers.forEach((bgLayer) => {
      if (bgLayer.vector_id) {
        const conf = styleService.setConfigForLayer(
          bgLayer.icon_id,
          bgLayer.vector_id
        );
        promises.push(
          conf.then((c2) => {
            return { id: bgLayer.id, config: c2 };
          })
        );
      }
    });
    Promise.all(promises).then((styleConfigs) => {
      const vectorDict = /* @__PURE__ */ new Map();
      styleConfigs.forEach((c2) => vectorDict.set(c2.id, c2.config));
      bgVectorSources.value = vectorDict;
    });
    function setRegisterUrl(key, url) {
      registerUrls.value.set(key, url);
    }
    function setBgVectorSources(vectorDict) {
      bgVectorSources.value = vectorDict;
    }
    function removeBaseStyle(id) {
      const styleDict = /* @__PURE__ */ new Map();
      bgVectorBaseStyles.value.forEach((style, key) => {
        if (key !== id)
          styleDict.set(key, style);
      });
      bgVectorBaseStyles.value = styleDict;
    }
    function setBaseStyle(id, baseStyle) {
      const styleDict = /* @__PURE__ */ new Map();
      bgVectorBaseStyles.value.forEach(
        (style, key) => styleDict.set(key, style)
      );
      styleDict.set(id, baseStyle);
      bgVectorBaseStyles.value = styleDict;
    }
    function setSimpleStyle(simpleStyle) {
      bgStyle.value = styleService.getRoadStyleFromSimpleStyle(simpleStyle);
      disableExpertStyle();
    }
    function setStyle2(style) {
      bgStyle.value = style;
      disableExpertStyle();
    }
    function disableExpertStyle() {
      isExpertStyleActive.value = false;
    }
    function enableExpertStyle() {
      isExpertStyleActive.value = true;
    }
    return {
      bgStyle,
      bgVectorSources,
      bgVectorBaseStyles,
      isExpertStyleActive,
      appliedStyle,
      removeBaseStyle,
      setBaseStyle,
      setBgVectorSources,
      setRegisterUrl,
      setSimpleStyle,
      setStyle: setStyle2,
      disableExpertStyle,
      enableExpertStyle,
      styleSerial,
      registerUrls
    };
  },
  {}
);
const useMapStore = defineStore("map", () => {
  const map2 = ref({});
  const layers = shallowRef([]);
  const bgLayer = ref(void 0);
  function setBgLayer(layer) {
    bgLayer.value = layer;
  }
  function addLayers(...newLayers) {
    layers.value = [.../* @__PURE__ */ new Set([...layers.value, ...newLayers])];
  }
  function removeLayers(...layerIds) {
    layers.value = layers.value.filter(
      (layer) => layerIds.indexOf(layer.id) === -1
    );
  }
  function hasLayer(layerId) {
    var _a;
    return !!((_a = layers.value) == null ? void 0 : _a.find((layer) => layer.id === layerId));
  }
  function reorderLayers(layersId) {
    var _a;
    layers.value = [
      ...((_a = layers.value) == null ? void 0 : _a.sort(
        (a, b) => layersId.indexOf(a.id) - layersId.indexOf(b.id)
      )) || []
    ];
  }
  function setLayerOpacity(layerId, opacity) {
    layers.value = layers.value.map((elt) => {
      if (elt.id === layerId) {
        return { ...elt, opacity, previousOpacity: elt.opacity };
      }
      return elt;
    });
  }
  return {
    map: map2,
    layers,
    bgLayer,
    addLayers,
    removeLayers,
    reorderLayers,
    setLayerOpacity,
    setBgLayer,
    hasLayer
  };
});
class StatePersistorStyleService {
  constructor() {
    __publicField(this, "styleWatcher");
  }
  bootstrapStyle() {
    const styleStore = useStyleStore();
    let stop;
    let activatePersistance = false;
    stop = watchEffect(() => {
      if (styleStore.bgVectorSources) {
        this.restoreStyle(false);
        if (activatePersistance)
          this.persistStyle();
        activatePersistance = true;
        stop && stop();
      }
    });
  }
  persistStyle() {
    const styleStore = useStyleStore();
    const { bgStyle } = storeToRefs(styleStore);
    if (!this.styleWatcher) {
      this.styleWatcher = watch(
        bgStyle,
        (value, oldValue) => {
          if (oldValue !== value) {
            const mapStore = useMapStore();
            if (mapStore.bgLayer) {
              storageHelper.setValue(
                mapStore.bgLayer.name,
                value || [],
                storageStyleMapper.styleToLocalStorage
              );
              storageHelper.setValue(
                SP_KEY_SERIAL,
                value || [],
                storageStyleMapper.styleToSerial
              );
            }
          }
        },
        { immediate: true }
      );
    }
  }
  restoreStyle(localStorageOnly) {
    const styleStore = useStyleStore();
    styleStore.setStyle(null);
    const mapStore = useMapStore();
    const bgLayer = mapStore.bgLayer;
    if (bgLayer) {
      let bgStyle = [];
      if (!localStorageOnly) {
        bgStyle = storageHelper.getValue(
          SP_KEY_SERIAL,
          storageStyleMapper.styleSerialToStyle
        );
      }
      if (bgStyle.length === 0) {
        bgStyle = storageHelper.getValue(
          bgLayer.name,
          storageStyleMapper.styleLocalStorageToStyle
        );
      }
      if (bgStyle && bgStyle.length > 0) {
        styleStore.setStyle(bgStyle);
      }
    }
  }
}
const statePersistorStyleService = new StatePersistorStyleService();
const TILE_GRID_RESOLUTION = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
];
const TILE_MATRIX_IDS = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
];
const DEFAULT_BGZINDEX = -200;
const proxyWmsUrl = "https://map.geoportail.lu/ogcproxywms";
const remoteProxyWms = "https://map.geoportail.lu/httpsproxy";
function getOlcsExtent() {
  return transformExtent(
    [5.31, 49.38, 6.64, 50.21],
    PROJECTION_WGS84,
    PROJECTION_WEBMERCATOR
  );
}
function createWmsLayer(layer) {
  const { name, layers, imageType, url, id } = layer;
  const olLayer = new ImageLayer({
    properties: {
      "olcs.extent": getOlcsExtent(),
      label: name,
      id
    },
    source: new ImageWMS({
      url: url || proxyWmsUrl,
      hidpi: isHiDpi(),
      serverType: "mapserver",
      params: {
        FORMAT: imageType,
        LAYERS: layers
      },
      ...url !== void 0 && url !== null || remoteProxyWms ? { crossOrigin: "anonymous" } : {}
    })
  });
  olLayer.set("olcs.extent", getOlcsExtent());
  olLayer.set("label", name);
  olLayer.set("id", id);
  return olLayer;
}
function createWmtsLayer(layer) {
  const { name, imageType, id } = layer;
  const hasRetina = getLayerHasRetina(layer);
  const projection = get$3(PROJECTION_WEBMERCATOR);
  const extent = projection.getExtent();
  const olLayer = new TileLayer({
    source: new WMTS({
      url: getLayerWmtsUrl(layer),
      tilePixelRatio: hasRetina ? 2 : 1,
      layer: name,
      matrixSet: `GLOBAL_WEBMERCATOR_4_V3${hasRetina ? "_HD" : ""}`,
      format: imageType,
      requestEncoding: "REST",
      projection,
      tileGrid: new WmtsTileGrid({
        origin: getTopLeft(extent),
        extent,
        resolutions: TILE_GRID_RESOLUTION,
        matrixIds: TILE_MATRIX_IDS
      }),
      style: "default",
      crossOrigin: "anonymous"
    }),
    properties: {
      "olcs.extent": getOlcsExtent(),
      label: name,
      id
    }
  });
  olLayer.set("olcs.extent", getOlcsExtent());
  olLayer.set("label", name);
  olLayer.set("id", id);
  return olLayer;
}
function createVectorLayer(vectorSources, bgLayer) {
  const mapService = useMap();
  const styleSource = vectorSources.get(bgLayer.id);
  if (!styleSource) {
    return;
  }
  const options = Object.assign(
    {
      container: mapService.getOlMap().getTarget()
    },
    styleSource
  );
  const newBgBaseLayer = new MapBox({
    maplibreOptions: options,
    label: bgLayer.name,
    id: bgLayer.id,
    queryable_id: bgLayer.id,
    metadata: bgLayer.metadata
  });
  const styleStore = useStyleStore();
  if (newBgBaseLayer == null ? void 0 : newBgBaseLayer.maplibreMap.loaded()) {
    styleStore.setBaseStyle(bgLayer.id, newBgBaseLayer.getStyle());
  } else {
    new Promise(
      (resolve2) => newBgBaseLayer == null ? void 0 : newBgBaseLayer.maplibreMap.once("data", resolve2)
    ).then(
      () => styleStore.setBaseStyle(
        bgLayer.id,
        newBgBaseLayer == null ? void 0 : newBgBaseLayer.maplibreMap.getStyle()
      )
    );
  }
  return newBgBaseLayer;
}
function getLayerWmtsUrl(layer, requestScheme = "https") {
  const imageExt = layer.imageType.split("/")[1];
  const domain = storageHelper.getValue(SP_KEY_IPV6, stringToBoolean) ? "app.geoportail.lu" : "geoportail.lu";
  return `${requestScheme === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${domain}/mapproxy_4_v3/wmts/{Layer}${getLayerHasRetina(layer) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${imageExt}`;
}
function getLayerHasRetina(layer) {
  var _a;
  return !!((_a = layer == null ? void 0 : layer.metadata) == null ? void 0 : _a.hasRetina) && isHiDpi();
}
function useOpenLayers() {
  function createLayer(spec) {
    var _a;
    let layer;
    switch (spec.type) {
      case "WMS": {
        layer = createWmsLayer(spec);
        break;
      }
      case "WMTS":
      case "BG WMTS": {
        layer = createWmtsLayer(spec);
        break;
      }
      default:
        throw new Error(`Unrecognized layer type: ${spec.type}`);
    }
    layer.set("metadata", spec.metadata);
    layer.set("queryable_id", spec.id);
    layer.setOpacity(spec.opacity);
    if ((_a = spec.metadata) == null ? void 0 : _a.hasOwnProperty("attribution")) {
      const source = layer.getSource();
      source == null ? void 0 : source.setAttributions(spec.metadata.attribution);
    }
    return layer;
  }
  function addLayer(olMap2, layer) {
    const baseLayer = getOrCreateLayer(layer);
    olMap2.addLayer(baseLayer);
  }
  function findLayer(olMap2, layerId) {
    return olMap2.getLayers().getArray().find((layer) => layer.get("id") === layerId);
  }
  function removeLayer(olMap2, layerId) {
    const layerToRemove = findLayer(olMap2, layerId);
    if (layerToRemove) {
      olMap2.removeLayer(layerToRemove);
    }
  }
  function reorderLayers(olMap2, layers) {
    const arrayLayers = olMap2.getLayers().getArray();
    layers.forEach((layer, idx) => {
      const baseLayer = arrayLayers.find(
        (mapLayer) => mapLayer.get("id") === layer.id
      );
      baseLayer == null ? void 0 : baseLayer.setZIndex(idx + 1);
    });
  }
  function setLayerOpacity(olMap2, layerId, opacity) {
    const layer = olMap2.getLayers().getArray().find((layer2) => layer2.get("id") === layerId);
    if (layer)
      layer.setOpacity(opacity);
  }
  function removeFromCache(id) {
    layersCache.delete(id);
  }
  function isLayerCached(layer) {
    return layersCache.has(layer.id);
  }
  function addLayerToCache(id, layer) {
    layersCache.set(id, layer);
  }
  function getOrCreateLayer(layer) {
    if (layer === null || layer === void 0)
      return null;
    const id = layer.id;
    const cachedLayer = layersCache.get(id);
    if (cachedLayer) {
      return cachedLayer;
    } else {
      const newLayer = createLayer(layer);
      addLayerToCache(id, newLayer);
      return newLayer;
    }
  }
  function getLayerFromCache(layer) {
    if (layer === null || layer === void 0)
      return null;
    const id = layer.id;
    return layersCache.get(id);
  }
  function applyOnBgLayer(olMap2, callbackFunction) {
    const mapLayers = olMap2.getLayers();
    const bgLayer = mapLayers.getArray().find((layer) => layer.getZIndex() === DEFAULT_BGZINDEX);
    if (bgLayer)
      callbackFunction(bgLayer);
  }
  function setBgLayer(olMap2, bgLayer, vectorSources) {
    var _a;
    const mapLayers = olMap2.getLayers();
    const currentBgLayerPos = mapLayers.getArray().findIndex((layer) => layer.getZIndex() === DEFAULT_BGZINDEX);
    const oldBgLayerId = (_a = mapLayers.getArray()[currentBgLayerPos]) == null ? void 0 : _a.get("id");
    let bgBaseLayer = void 0;
    if (bgLayer) {
      if (isLayerCached(bgLayer)) {
        bgBaseLayer = getLayerFromCache(bgLayer);
      } else {
        if (vectorSources) {
          bgBaseLayer = createVectorLayer(vectorSources, bgLayer);
        }
        bgBaseLayer = bgBaseLayer ? bgBaseLayer : createLayer(bgLayer);
        addLayerToCache(bgLayer.id, bgBaseLayer);
      }
    }
    if (currentBgLayerPos >= 0) {
      if (bgBaseLayer) {
        bgBaseLayer.setZIndex(DEFAULT_BGZINDEX);
        mapLayers.setAt(currentBgLayerPos, bgBaseLayer);
      } else {
        mapLayers.removeAt(currentBgLayerPos);
      }
    } else {
      if (bgBaseLayer) {
        bgBaseLayer.setZIndex(DEFAULT_BGZINDEX);
        olMap2.addLayer(bgBaseLayer);
      }
    }
    if (oldBgLayerId !== (bgLayer == null ? void 0 : bgLayer.id)) {
      statePersistorStyleService.restoreStyle(true);
    }
  }
  return {
    createLayer,
    addLayer,
    findLayer,
    removeLayer,
    removeFromCache,
    reorderLayers,
    setLayerOpacity,
    getLayerFromCache,
    setBgLayer,
    applyOnBgLayer
  };
}
class OlSynchronizer {
  constructor(map2) {
    __publicField(this, "previousLayers");
    __publicField(this, "previousVectorSources");
    const mapStore = useMapStore();
    const styleStore = useStyleStore();
    const mapService = useMap();
    const styleService = useMvtStyles();
    const openLayers = useOpenLayers();
    const { appliedStyle } = storeToRefs(styleStore);
    watch(
      () => mapStore.layers,
      (layers) => {
        const oldContext = {
          layers: this.previousLayers
        };
        const newContext = {
          layers
        };
        const removedLayers = mapService.getRemovedLayers(
          newContext,
          oldContext
        );
        const addedLayerComparisons = mapService.getAddedLayers(
          newContext,
          oldContext
        );
        const mutatedLayerComparisons = mapService.getMutatedLayers(
          newContext,
          oldContext
        );
        removedLayers.forEach((layer) => openLayers.removeLayer(map2, layer.id));
        addedLayerComparisons.forEach(
          (cmp) => openLayers.addLayer(map2, cmp.layer)
        );
        mutatedLayerComparisons.forEach((layer) => {
          openLayers.setLayerOpacity(map2, layer.id, layer.opacity);
        });
        if (newContext.layers) {
          openLayers.reorderLayers(map2, newContext.layers);
        }
        this.previousLayers = layers;
      }
    );
    watch(
      () => mapStore.bgLayer,
      (bgLayer) => bgLayer !== void 0 && openLayers.setBgLayer(map2, bgLayer, styleStore.bgVectorSources)
    );
    watchEffect(() => {
      if (!styleStore.isExpertStyleActive) {
        appliedStyle.value = styleService.applyDefaultStyle(
          mapStore.bgLayer,
          styleStore.bgVectorBaseStyles,
          styleStore.bgStyle
        );
      }
    });
    watch(appliedStyle, (style) => {
      if (styleStore.bgStyle === null && !styleStore.isExpertStyleActive) {
        styleService.unregisterStyle(styleStore.styleSerial, styleStore.registerUrls).then(styleStore.styleSerial = null);
      } else {
        styleService.registerStyle(style, styleStore.styleSerial, styleStore.registerUrls).then((serial) => {
          var _a;
          styleStore.styleSerial = serial;
          const id = (_a = mapStore == null ? void 0 : mapStore.bgLayer) == null ? void 0 : _a.id;
          if ((mapStore == null ? void 0 : mapStore.bgLayer) && id !== void 0 && serial !== void 0) {
            openLayers.applyOnBgLayer(map2, (bgLayer) => {
              bgLayer.set(
                "xyz_custom",
                styleService.getDefaultMapBoxStyleXYZ(serial)
              );
            });
            openLayers.setBgLayer(
              map2,
              mapStore == null ? void 0 : mapStore.bgLayer,
              styleStore.bgVectorSources
            );
          }
        });
      }
      openLayers.applyOnBgLayer(
        map2,
        (bgLayer) => styleService.applyConsolidatedStyle(bgLayer, style)
      );
    });
    watch(
      () => styleStore.bgVectorSources,
      (newVectorSources) => {
        var _a;
        for (const id of newVectorSources.keys()) {
          if (!this.previousVectorSources || this.previousVectorSources.get(id) !== newVectorSources.get(id)) {
            openLayers.removeFromCache(id);
            if (id === ((_a = mapStore == null ? void 0 : mapStore.bgLayer) == null ? void 0 : _a.id)) {
              openLayers.setBgLayer(map2, mapStore == null ? void 0 : mapStore.bgLayer, newVectorSources);
            }
          }
        }
        this.previousVectorSources = newVectorSources;
      }
    );
  }
}
const V2_ZOOM_TO_V3_ZOOM_ = {
  "0": 8,
  "1": 9,
  "2": 9,
  "3": 10,
  "4": 11,
  "5": 12,
  "6": 13,
  "7": 14,
  "8": 16,
  "9": 17,
  "10": 18,
  "11": 19,
  "12": 20,
  "13": 21
};
class StatePersistorMapService {
  bootstrap() {
    this.restore();
    this.persist();
  }
  persistZoom() {
    const view = useMap().getOlMap().getView();
    const fnStorageSetValueZoom = () => {
      const zoom = view.getZoom();
      storageHelper.setValue(SP_KEY_ZOOM, zoom ? Math.ceil(zoom) : null);
    };
    fnStorageSetValueZoom();
    olEvents.listen(
      view,
      "change:resolution",
      debounce(fnStorageSetValueZoom, 300)
    );
  }
  persistXY() {
    const view = useMap().getOlMap().getView();
    const fnStorageSetValueXY = () => {
      const center = view.getCenter();
      storageHelper.setValue(SP_KEY_X, center ? Math.round(center[0]) : null);
      storageHelper.setValue(SP_KEY_Y, center ? Math.round(center[1]) : null);
    };
    fnStorageSetValueXY();
    olEvents.listen(
      view,
      ObjectEventType.PROPERTYCHANGE,
      debounce(fnStorageSetValueXY, 300)
    );
  }
  persist() {
    this.persistXY();
    this.persistZoom();
  }
  restore() {
    const view = useMap().getOlMap().getView();
    const zoom = storageHelper.getValue(SP_KEY_ZOOM, stringToNumber);
    const version2 = storageHelper.getInitialVersion();
    const x = storageHelper.getValue(SP_KEY_X, stringToNumber);
    const y2 = storageHelper.getValue(SP_KEY_Y, stringToNumber);
    const srs = storageHelper.getValue(SP_KEY_SRS);
    const lurefToWebMercatorFn = getTransform(
      PROJECTION_LUX,
      PROJECTION_WEBMERCATOR
    );
    let viewCenter;
    let viewZoom;
    if (zoom !== void 0) {
      viewZoom = version2 === 3 ? Number(zoom) : V2_ZOOM_TO_V3_ZOOM_[zoom];
    } else {
      viewZoom = 8;
    }
    if (x != null && y2 != null) {
      if (version2 === 3 && srs != null) {
        viewCenter = transform$1([x, y2], srs, PROJECTION_WEBMERCATOR);
      } else {
        viewCenter = version2 === 3 ? [x, y2] : lurefToWebMercatorFn([y2, x], void 0, 2);
      }
    } else {
      viewCenter = transform$1(
        [6, 49.7],
        PROJECTION_WGS84,
        PROJECTION_WEBMERCATOR
      );
    }
    view.setCenter(viewCenter);
    view.setZoom(viewZoom);
  }
}
const statePersistorMapService = new StatePersistorMapService();
function useControl(ControlClass, options) {
  const control = new ControlClass(options);
  const map2 = useMap();
  const olMap2 = inject("olMap");
  onMounted(() => {
    olMap2.addControl(control);
    olMap2.changed();
  });
  onUnmounted(() => {
    const olMap22 = map2.getOlMap();
    olMap22.removeControl(control);
    olMap22.changed();
  });
  return {
    control
  };
}
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "attribution-control",
  props: {
    className: { type: String, required: false, default: "geoportailv3-attribution" },
    collapsed: { type: Boolean, required: false, default: false },
    collapsible: { type: Boolean, required: false, default: false }
  },
  setup(__props) {
    const props = __props;
    useControl(Attribution, props);
    return (_ctx, _cache) => {
      return createCommentVNode("v-if", true);
    };
  }
});
const AttributionControl = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map-controls/attribution-control.vue"]]);
function install(app2, {
  i18next,
  rerenderOn = ["languageChanged", "loaded", "added", "removed"]
}) {
  const genericT = i18next.t.bind(i18next);
  const lastI18nChange = ref(new Date());
  const invalidate = () => lastI18nChange.value = new Date();
  const usingI18n = () => lastI18nChange.value;
  rerenderOn.forEach((event) => {
    var _a;
    switch (event) {
      case "added":
      case "removed":
        (_a = i18next.store) == null ? void 0 : _a.on(event, invalidate);
        break;
      default:
        i18next.on(event, invalidate);
        break;
    }
  });
  app2.component("i18next", TranslationComponent);
  app2.mixin({
    beforeCreate() {
      var _a, _b;
      const options = this.$options;
      if (!options.__i18n && !options.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const name = this.$options.name;
      const rand = (Math.random() * 10 ** 8 | 0).toString();
      const localNs = [name, rand].filter((x) => !!x).join("-");
      this.__bundles = [];
      const loadBundle = (bundle) => {
        Object.entries(bundle).forEach(([lng2, resources]) => {
          i18next.addResourceBundle(lng2, localNs, resources, true, false);
          this.__bundles.push([lng2, localNs]);
        });
      };
      (_a = options.__i18n) == null ? void 0 : _a.forEach((bundle) => {
        loadBundle(JSON.parse(bundle));
      });
      let { lng, ns, keyPrefix } = handleI18nOptions(options, loadBundle);
      if ((_b = this.__bundles) == null ? void 0 : _b.length) {
        ns = [localNs].concat(ns != null ? ns : []);
      }
      const t = getTranslationFunction(lng, ns);
      this.__translate = (key, options2) => {
        if (!keyPrefix || includesNs(key)) {
          return t(key, options2);
        } else {
          return t(keyPrefix + "." + key, options2);
        }
      };
    },
    unmounted() {
      var _a;
      (_a = this.__bundles) == null ? void 0 : _a.forEach(([lng, ns]) => i18next.removeResourceBundle(lng, ns));
    }
  });
  app2.config.globalProperties.$t = function(key, options) {
    var _a;
    usingI18n();
    if (i18next.isInitialized) {
      return ((_a = this == null ? void 0 : this.__translate) != null ? _a : genericT)(key, options);
    } else {
      return key;
    }
  };
  app2.config.globalProperties.$i18next = new Proxy(i18next, {
    get(target, prop) {
      usingI18n();
      return Reflect.get(target, prop);
    }
  });
  function getTranslationFunction(lng, ns) {
    if (lng) {
      return i18next.getFixedT(lng, ns);
    } else if (ns) {
      return i18next.getFixedT(null, ns);
    } else {
      return genericT;
    }
  }
  function includesNs(key) {
    const nsSeparator = i18next.options.nsSeparator;
    return typeof nsSeparator === "string" && key.includes(nsSeparator);
  }
  function handleI18nOptions(options, loadBundle) {
    let lng;
    let ns;
    let keyPrefix;
    if (options.i18nOptions) {
      let messages;
      let namespaces;
      ({
        lng,
        namespaces = i18next.options.defaultNS,
        keyPrefix,
        messages
      } = options.i18nOptions);
      if (messages) {
        loadBundle(messages);
      }
      ns = typeof namespaces === "string" ? [namespaces] : namespaces;
      if (ns) {
        i18next.loadNamespaces(ns);
      }
    }
    return { lng, ns, keyPrefix };
  }
}
function useTranslation() {
  const instance2 = getCurrentInstance();
  if (!instance2) {
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  }
  const globalProps = instance2.appContext.config.globalProperties;
  return {
    i18next: globalProps.$i18next,
    t: globalProps.$t.bind(instance2.proxy)
  };
}
var slotNamePattern = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi");
var TranslationComponent = defineComponent({
  props: {
    "translation": {
      type: String,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => {
      const translation = props.translation;
      const result = [];
      let match2;
      let lastIndex = 0;
      while ((match2 = slotNamePattern.exec(translation)) !== null) {
        result.push(translation.substring(lastIndex, match2.index));
        const slot = slots[match2[1]];
        if (slot) {
          result.push(...slot());
        } else {
          result.push(match2[0]);
        }
        lastIndex = slotNamePattern.lastIndex;
      }
      result.push(translation.substring(lastIndex));
      return result;
    };
  }
});
const _hoisted_1$p = ["title"];
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "location-control",
  props: {
    className: { type: String, required: false, default: "location-button" },
    label: { type: String, required: false, default: "\uE800" },
    tipLabel: { type: String, required: false, default: "Location" }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const controlElement = ref(null);
    function handleCenterToLocation() {
    }
    onMounted(
      () => useControl(Control, { ...props, ...{ target: controlElement } })
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "controlElement",
        ref: controlElement,
        class: normalizeClass(`tracker-off ${props.className} ${unref(CLASS_UNSELECTABLE)} ${unref(CLASS_CONTROL)}`)
      }, [
        createBaseVNode("button", {
          title: unref(t)(props.tipLabel),
          onClick: handleCenterToLocation
        }, toDisplayString(props.label), 9, _hoisted_1$p)
      ], 2);
    };
  }
});
const LocationControl = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map-controls/location-control.vue"]]);
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: false },
    label: { type: String, required: false, default: "\uE01C" },
    labelActive: { type: String, required: false, default: "\uE02C" }
  },
  setup(__props) {
    const props = __props;
    useControl(FullScreen, props);
    return (_ctx, _cache) => {
      return createCommentVNode("v-if", true);
    };
  }
});
const FullscreenControl = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map-controls/fullscreen-control.vue"]]);
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "zoom-control",
  props: {
    className: { type: String, required: false },
    zoomInLabel: { type: String, required: false, default: "\uE032" },
    zoomOutLabel: { type: String, required: false, default: "\uE033" }
  },
  setup(__props) {
    const props = __props;
    useControl(Zoom, props);
    return (_ctx, _cache) => {
      return createCommentVNode("v-if", true);
    };
  }
});
const ZoomControl = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map-controls/zoom-control.vue"]]);
class ZoomToExtent extends OlControlZoomToExtent {
  constructor(optOptions) {
    super(optOptions);
    __publicField(this, "ol3dm");
  }
  handleZoomToExtent() {
    if (this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled())
      ;
    else {
      super.handleZoomToExtent();
    }
  }
}
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: false },
    label: { type: String, required: false, default: "\uE01B" },
    tipLabel: { type: String, required: false },
    extent: { type: null, required: true }
  },
  setup(__props) {
    const props = __props;
    useControl(ZoomToExtent, props);
    return (_ctx, _cache) => {
      return createCommentVNode("v-if", true);
    };
  }
});
const ZoomToExtentControl = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map-controls/zoom-to-extent-control.vue"]]);
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "map-container",
  setup(__props) {
    const map2 = useMap();
    const mapContainer = ref(null);
    const olMap2 = map2.createMap();
    const DEFAULT_EXTENT = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    onMounted(() => {
      if (mapContainer.value) {
        new OlSynchronizer(olMap2);
        statePersistorMapService.bootstrap();
        olMap2.setTarget(mapContainer.value);
        window.olMap = olMap2;
      }
    });
    provide("olMap", olMap2);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: "map-container",
        ref_key: "mapContainer",
        ref: mapContainer,
        class: "h-full w-full bg-white absolute"
      }, [
        createVNode(ZoomControl),
        createVNode(ZoomToExtentControl, { extent: DEFAULT_EXTENT }),
        createVNode(FullscreenControl),
        createVNode(AttributionControl),
        createVNode(LocationControl)
      ], 512);
    };
  }
});
const MapContainer = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/map/map-container.vue"]]);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _toPrimitive$1(input, hint) {
  if (_typeof$4(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$4(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$4(key) === "symbol" ? key : String(key);
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(arr2) {
  return _arrayWithHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray(arr2) || _nonIterableRest();
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$1(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass$1(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward2(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create2(moduleName) {
      return new Logger2(this.logger, _objectSpread$6(_objectSpread$6({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone2(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck$1(this, EventEmitter2);
    this.observers = {};
  }
  _createClass$1(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off2(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit2(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve2, reject) {
    res = resolve2;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s, t) {
  a.forEach(function(m) {
    if (s[m])
      t[m] = s[m];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack2 = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack2.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack2.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack2.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j = 2;
      var p2 = paths.slice(i, i + j).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i + j) {
        j++;
        p2 = paths.slice(i, i + j).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$3(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck$1(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass$1(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$5(_objectSpread$5({}, pack), resources);
      }
      setPath(this.data, path, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$5(_objectSpread$5({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n = data && Object.keys(data) || [];
      return !!n.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$2(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$1(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass$1(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;
      if (_typeof$4(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            return {
              res: "".concat(namespace).concat(nsSeparator).concat(key),
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace
            };
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          return {
            res: key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace
          };
        }
        return key;
      }
      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$4(_objectSpread$4({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r;
            return resolved;
          }
          return r;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread$4(_objectSpread$4({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey)
                copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$4(_objectSpread$4({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l, k, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$4(_objectSpread$4({}, options), {
            interpolation: _objectSpread$4(_objectSpread$4({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$4({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve2(keys) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes2 = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes2[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes2[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes2.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes2.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = "defaultValue";
      for (var option2 in options) {
        if (Object.prototype.hasOwnProperty.call(options, option2) && prefix === option2.substring(0, prefix.length) && void 0 !== options[option2]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck$1(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass$1(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes2) {
      var _this = this;
      if (!codes2)
        return null;
      var found;
      codes2.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes2.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes2 = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes2.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes2.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes2;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _2(n) {
    return Number(n != 1);
  },
  3: function _3(n) {
    return 0;
  },
  4: function _4(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _7(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _9(n) {
    return Number(n >= 2);
  },
  10: function _10(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _11(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _12(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _13(n) {
    return Number(n !== 0);
  },
  14: function _14(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _15(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _17(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _18(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _19(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _20(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _21(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _22(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set2) {
    set2.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$1(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass$1(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$1(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass$1(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator);
        var k = p2.shift().trim();
        var f = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match2, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        clonedOptions = _objectSpread$3({}, options);
        clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f) {
            return _this2.format(v2, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  var cache = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache[key];
    if (!formatter) {
      formatter = fn(lng, options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$1(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2(_objectSpread$2({}, opt), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val, opt.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }
  _createClass$1(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add2(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function format(value, _format, lng) {
      var _this = this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f) {
        var _parseFormatStr = parseFormatStr(f), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l, _objectSpread$2(_objectSpread$2(_objectSpread$2({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$1(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck$1(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass$1(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        removePending(q, name);
        if (err)
          q.errors.push(err);
        if (q.pendingCount === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l])
              loaded2[l] = {};
            var loadedKeys = q.loaded[l];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(n) {
                if (loaded2[l][n] === void 0)
                  loaded2[l][n] = true;
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      var resolver = function resolver2(err, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      };
      var fc = this.backend[fcName].bind(this.backend);
      if (fc.length === 2) {
        try {
          var r = fc(lng, ns);
          if (r && typeof r.then === "function") {
            r.then(function(data) {
              return resolver(null, data);
            })["catch"](resolver);
          } else {
            resolver(null, r);
          }
        } catch (err) {
          resolver(err);
        }
        return;
      }
      return fc(lng, ns, resolver);
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload2(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      var clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        var opts = _objectSpread$1(_objectSpread$1({}, options), {}, {
          isUpdate
        });
        var fc = this.backend.create.bind(this.backend);
        if (fc.length < 6) {
          try {
            var r;
            if (fc.length === 5) {
              r = fc(languages, namespace, key, fallbackValue, opts);
            } else {
              r = fc(languages, namespace, key, fallbackValue);
            }
            if (r && typeof r.then === "function") {
              r.then(function(data) {
                return clb(null, data);
              })["catch"](clb);
            } else {
              clb(null, r);
            }
          } catch (err) {
            clb(err);
          }
        } else {
          fc(languages, namespace, key, fallbackValue, clb, opts);
        }
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof$4(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof$4(args[2]) === "object" || _typeof$4(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck$1(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass$1(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread(_objectSpread(_objectSpread({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread(_objectSpread({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          if (s.languageDetector.init)
            s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init)
            s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes2 = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes2.length > 0 && codes2[0] !== "dev")
          this.options.lng = codes2[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t);
          callback(err, t);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0)
              toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l) {
      if (!l || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l);
      };
      var done = function done2(err, l) {
        if (l) {
          setLngProps(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            setLngProps(l);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage)
            _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        if (this.services.languageDetector.detect.length === 0) {
          this.services.languageDetector.detect().then(setLng);
        } else {
          this.services.languageDetector.detect(setLng);
        }
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof$4(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey;
        if (options.keyPrefix && Array.isArray(key)) {
          resultKey = key.map(function(k) {
            return "".concat(options.keyPrefix).concat(keySeparator).concat(k);
          });
        } else {
          resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        }
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n) {
        if (_this7.options.ns.indexOf(n) < 0)
          _this7.options.ns.push(n);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
      return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var mergedOptions = _objectSpread(_objectSpread(_objectSpread({}, this.options), options), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone2.logger = clone2.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone2[m] = _this8[m];
      });
      clone2.services = _objectSpread({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty$2(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const useThemeStore = defineStore(
  "config",
  () => {
    const config = shallowRef();
    const themeName = ref("main");
    const themes2 = computed(() => {
      var _a;
      return (_a = config.value) == null ? void 0 : _a.themes;
    });
    const theme = computed(
      () => {
        var _a;
        return (_a = themes2.value) == null ? void 0 : _a.find((theme2) => theme2.name === themeName.value);
      }
    );
    const bgLayers = computed(() => {
      var _a;
      return ((_a = config.value) == null ? void 0 : _a.background_layers) || [];
    });
    function setThemes(themes22) {
      config.value = themes22;
    }
    function setTheme(name) {
      themeName.value = name;
    }
    return {
      config,
      themes: themes2,
      themeName,
      theme,
      bgLayers,
      setTheme,
      setThemes
    };
  },
  {}
);
function useThemes() {
  function findById(id, node) {
    return findByIdOrName(id, void 0, node);
  }
  function findByName(name, node) {
    return findByIdOrName(void 0, name, node);
  }
  function findByIdOrName(id, name, node) {
    const { theme } = useThemeStore();
    node = node || theme;
    if (id && (node == null ? void 0 : node.id) === id || name && (node == null ? void 0 : node.name) === name) {
      return node;
    } else if (node == null ? void 0 : node.children) {
      for (const child of node.children) {
        const match2 = findByIdOrName(id, name, child);
        if (match2) {
          return match2;
        }
      }
    }
  }
  function findBgLayerById(id) {
    const { bgLayers } = useThemeStore();
    return bgLayers.find((l) => l.id === id);
  }
  function findBgLayerByName(name) {
    const { bgLayers } = useThemeStore();
    return bgLayers.find((l) => l.name === name);
  }
  function setTheme(name) {
    const { setTheme: setTheme2 } = useThemeStore();
    setTheme2(name);
  }
  return {
    findById,
    findByName,
    findBgLayerById,
    findBgLayerByName,
    setTheme
  };
}
const themes = useThemes();
function useLayers() {
  function hasIntersect(exclusionA, exclusionB) {
    try {
      const concat = JSON.parse(exclusionA).concat(JSON.parse(exclusionB)).sort((a, b) => a - b);
      return concat.some(
        (element, index2, array) => index2 && element === array[index2 - 1]
      );
    } catch (e) {
      return false;
    }
  }
  function initLayer(layer) {
    var _a, _b;
    layer.opacity = layer.previousOpacity = (_b = (_a = layer.metadata) == null ? void 0 : _a.start_opacity) != null ? _b : 1;
    return layer;
  }
  function handleExclusionLayers(layer) {
    var _a;
    if (!((_a = layer.metadata) == null ? void 0 : _a.exclusion)) {
      return;
    }
    const mapStore = useMapStore();
    const excludedLayers = mapStore.layers.filter(
      (_layer) => {
        var _a2, _b;
        return hasIntersect(
          (_a2 = layer == null ? void 0 : layer.metadata) == null ? void 0 : _a2.exclusion,
          (_b = _layer == null ? void 0 : _layer.metadata) == null ? void 0 : _b.exclusion
        );
      }
    );
    if (excludedLayers.length > 0) {
      mapStore.removeLayers(...excludedLayers.map((_layer) => _layer.id));
      alert(
        instance.t(
          "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
          {
            count: excludedLayers.length,
            layersToRemove: excludedLayers.map((_layer) => instance.t(_layer.name, { ns: "client" })).join(", "),
            layer: instance.t(layer.name, { ns: "client" }),
            ns: "client"
          }
        )
      );
    }
  }
  function toggleLayer(id, show = true) {
    var _a;
    const themeStore = useThemeStore();
    const mapStore = useMapStore();
    const layer = themes.findById(id, themeStore.theme);
    if (layer) {
      const linkedLayers = ((_a = layer.metadata) == null ? void 0 : _a.linked_layers) || [];
      if (show === false) {
        mapStore.removeLayers(layer.id, ...linkedLayers);
      } else {
        handleExclusionLayers(layer);
        mapStore.addLayers(
          initLayer(layer),
          ...linkedLayers.map(
            (layerId) => initLayer(
              themes.findById(parseInt(layerId, 10))
            )
          )
        );
      }
    }
  }
  return {
    initLayer,
    handleExclusionLayers,
    toggleLayer
  };
}
const DEFAULT_LANG = "fr";
const DEFAULT_LAYER_PANEL_OPENED = true;
const DEFAULT_MY_LAYERS_TAB_OPENED = false;
const DEFAULT_THEME_GRID_OPENED = false;
const useAppStore = defineStore(
  "app",
  () => {
    const lang = ref(DEFAULT_LANG);
    const layersOpen = ref(DEFAULT_LAYER_PANEL_OPENED);
    const myLayersTabOpen = ref(DEFAULT_MY_LAYERS_TAB_OPENED);
    const themeGridOpen = ref(DEFAULT_THEME_GRID_OPENED);
    const mapId = ref();
    const remoteLayersOpen = ref();
    const styleEditorOpen = ref(false);
    function setLang(language) {
      lang.value = language;
    }
    function setLayersOpen(open2) {
      layersOpen.value = open2;
      if (!open2) {
        themeGridOpen.value = false;
        myLayersTabOpen.value = false;
      }
    }
    function setMyLayersTabOpen(open2) {
      myLayersTabOpen.value = open2;
      if (open2) {
        themeGridOpen.value = false;
      }
    }
    function setThemeGridOpen(open2) {
      themeGridOpen.value = open2;
    }
    function setRemoteLayersOpen(open2) {
      remoteLayersOpen.value = open2;
    }
    function setMapId(id) {
      mapId.value = id;
    }
    function openStyleEditorPanel() {
      styleEditorOpen.value = true;
    }
    function closeStyleEditorPanel() {
      styleEditorOpen.value = false;
    }
    return {
      lang,
      layersOpen,
      myLayersTabOpen,
      themeGridOpen,
      mapId,
      styleEditorOpen,
      remoteLayersOpen,
      setLang,
      setLayersOpen,
      setMyLayersTabOpen,
      setThemeGridOpen,
      setRemoteLayersOpen,
      setMapId,
      openStyleEditorPanel,
      closeStyleEditorPanel
    };
  },
  {}
);
const BLANK_BACKGROUNDLAYER = {
  name: "blank",
  id: 0
};
function useBackgroundLayer() {
  const appStore = useAppStore();
  const { mapId } = storeToRefs(appStore);
  const theme = useThemes();
  const mapStore = useMapStore();
  const layers = useLayers();
  const defaultSelectedBgId = computed(() => {
    var _a;
    if (!mapId.value) {
      const themeName = (_a = useThemeStore().theme) == null ? void 0 : _a.name;
      if (themeName) {
        const defaultBgLayers = bgConfigFixture().bg_layer_theme_defaults;
        return defaultBgLayers[themeName] || getDefaultSelectedId();
      }
    }
    return getDefaultSelectedId();
  });
  function setBgLayer(layerId) {
    const newBgLayer = theme.findBgLayerById(layerId);
    setMapBackground(newBgLayer || null);
  }
  function setMapBackground(bgLayer) {
    if (bgLayer) {
      if (bgLayer.type === "WMTS" || bgLayer.type === "BG WMTS") {
        bgLayer.type = "BG WMTS";
      } else if (bgLayer.type === "BG MVT") {
        console.log(`passed through MVT layer ${bgLayer.name}`);
      } else {
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${bgLayer.type} for ${bgLayer.name})`
        );
      }
      layers.handleExclusionLayers(bgLayer);
      mapStore.setBgLayer(layers.initLayer(bgLayer));
    } else {
      mapStore.setBgLayer(null);
    }
  }
  function getDefaultSelectedId() {
    var _a;
    return ((_a = getBgLayersFromConfig().find((l) => l.is_default)) == null ? void 0 : _a.id) || BLANK_BACKGROUNDLAYER.id;
  }
  function getNullId() {
    return BLANK_BACKGROUNDLAYER.id;
  }
  function getBgLayersFromConfig() {
    return bgConfigFixture().bg_layers;
  }
  return {
    setBgLayer,
    setMapBackground,
    getBgLayersFromConfig,
    getNullId,
    getDefaultSelectedId,
    defaultSelectedBgId
  };
}
const _hoisted_1$o = ["title"];
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const buttonTitle = computed(() => {
      const localizedTitle = t(props.bgTitle);
      const hasTitle = props.bgTitle.length > 0;
      const localizedLayerName = `${t("Background layer:")} ${t(props.bgName)}`;
      return `${localizedTitle}${hasTitle ? " - " : ""}${localizedLayerName}`;
    });
    const buttonClasses = computed(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${props.bgName}
        bg-${props.bgName}_sm
        md:bg-${props.bgName}
        hd:bg-${props.bgName}_sm_hi
        hd_md:bg-${props.bgName}_hi`
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        title: unref(buttonTitle),
        class: normalizeClass(unref(buttonClasses))
      }, null, 10, _hoisted_1$o);
    };
  }
});
const BackgroundSelectorItem = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/background-selector/background-selector-item.vue"]]);
const _hoisted_1$n = { class: "flex flex-row-reverse" };
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const backgroundLayer = useBackgroundLayer();
    const mapStore = useMapStore();
    const themeStore = useThemeStore();
    const { bgLayer: bgLayerContext } = storeToRefs(mapStore);
    const isOpen = ref(props.isOpen);
    const bgLayers = ref([]);
    const activeLayerId = computed(
      () => {
        var _a, _b;
        return (_b = (_a = bgLayerContext.value) == null ? void 0 : _a.id) != null ? _b : backgroundLayer.getNullId();
      }
    );
    const activeLayerName = computed(
      () => {
        var _a, _b;
        return (_b = (_a = bgLayers.value) == null ? void 0 : _a.find((layer) => layer.id === activeLayerId.value)) == null ? void 0 : _b.name;
      }
    );
    watch(
      () => themeStore.bgLayers,
      (bgLayersContext) => {
        bgLayers.value = bgConfigFixture().bg_layers.map(
          (bgl) => Object.assign(
            {
              id: bgl.id
            },
            bgLayersContext.find((l) => bgl.id === l.id),
            {
              name: bgl.icon_id
            }
          )
        );
      },
      { immediate: true }
    );
    watch(
      () => mapStore.bgLayer,
      (bgLayerContext2, bgLayerContextOld) => {
        const layersContext = mapStore.layers;
        if (bgLayerContextOld === void 0 && bgLayerContext2 === null && (layersContext == null ? void 0 : layersContext.length) === 0) {
          backgroundLayer.setBgLayer(backgroundLayer.defaultSelectedBgId.value);
          if (bgLayerContext2 === null) {
            useAlertNotificationsStore().addNotification(
              t(
                "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
                { ns: "client" }
              )
            );
          }
        }
      }
    );
    function setBackgroundLayer(layer) {
      backgroundLayer.setBgLayer(layer.id);
      isOpen.value = false;
    }
    function toggleSelector() {
      isOpen.value = !isOpen.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        createBaseVNode("div", {
          class: normalizeClass(["lux-bg-sel border border-black", isOpen.value === true ? "hidden" : "block"])
        }, [
          createVNode(BackgroundSelectorItem, {
            "aria-expanded": isOpen.value,
            "bg-title": "Select BG layer",
            "bg-name": unref(activeLayerName),
            onClick: toggleSelector
          }, null, 8, ["aria-expanded", "bg-name"])
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(isOpen.value === true ? "flex flex-col md:flex-row" : "hidden")
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(bgLayers.value, (layer) => {
            return openBlock(), createElementBlock("div", {
              key: layer.id,
              class: normalizeClass([
                "lux-bg-sel hover:bg-cyan-600",
                layer.id === unref(activeLayerId) ? "border-red-500 border-2" : "border-black border"
              ])
            }, [
              createVNode(BackgroundSelectorItem, {
                "bg-name": layer.name,
                onClick: ($event) => setBackgroundLayer(layer)
              }, null, 8, ["bg-name", "onClick"])
            ], 2);
          }), 128))
        ], 2)
      ]);
    };
  }
});
const BackgroundSelector = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/background-selector/background-selector.vue"]]);
const _hoisted_1$m = /* @__PURE__ */ createBaseVNode("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1);
const _hoisted_2$j = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" };
const _hoisted_3$h = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" };
const _hoisted_4$f = { class: "text-xl" };
const _hoisted_5$d = /* @__PURE__ */ createBaseVNode("span", { "aria-hidden": "true" }, "\xD7", -1);
const _hoisted_6$9 = [
  _hoisted_5$d
];
const _hoisted_7$6 = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
};
const _hoisted_8$6 = { class: "flex flex-row justify-end" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: true
    },
    maxHeight: {
      type: Boolean,
      default: false
    },
    title: String
  },
  emits: ["close"],
  setup(__props) {
    const { t } = useTranslation();
    const modal = ref();
    onMounted(() => {
      modal.value.focus();
    });
    const displayModal = shallowRef(true);
    function close() {
      displayModal.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createCommentVNode(" backdrop "),
        _hoisted_1$m,
        createCommentVNode(" modal "),
        createVNode(Transition, {
          appear: "",
          "enter-active-class": "duration-200 ease-out",
          "enter-from-class": "transform opacity-0 -translate-y-60",
          "enter-to-class": "opacity-100 translate-y-0",
          "leave-active-class": "duration-200 ease-in",
          "leave-from-class": "opacity-100 translate-y-0",
          "leave-to-class": "transform opacity-0 -translate-y-60",
          onAfterLeave: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
        }, {
          default: withCtx(() => [
            unref(displayModal) ? (openBlock(), createElementBlock("div", {
              key: 0,
              role: "dialog",
              ref_key: "modal",
              ref: modal,
              tabindex: "0",
              onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => close(), ["esc"])),
              class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
            }, [
              createBaseVNode("div", _hoisted_2$j, [
                createCommentVNode(" header (title)"),
                createBaseVNode("div", _hoisted_3$h, [
                  createBaseVNode("h4", _hoisted_4$f, toDisplayString(__props.title), 1),
                  createBaseVNode("button", {
                    type: "button",
                    class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                    "data-dismiss": "modal",
                    "aria-label": "Close",
                    onClick: _cache[0] || (_cache[0] = ($event) => close())
                  }, _hoisted_6$9)
                ]),
                createCommentVNode(" content slot "),
                createBaseVNode("div", {
                  class: normalizeClass(["p-[15px] overflow-y-auto", __props.maxHeight ? "max-h-96" : "max-h-full"])
                }, [
                  renderSlot(_ctx.$slots, "content")
                ], 2),
                createCommentVNode(" footer (optional)"),
                __props.footer ? (openBlock(), createElementBlock("div", _hoisted_7$6, [
                  createBaseVNode("div", _hoisted_8$6, [
                    createBaseVNode("button", {
                      type: "button",
                      class: "lux-btn",
                      "data-dismiss": "modal",
                      onClick: _cache[1] || (_cache[1] = ($event) => close())
                    }, toDisplayString(unref(t)("Close", { ns: "client" })), 1)
                  ])
                ])) : createCommentVNode("v-if", true)
              ])
            ], 544)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        })
      ]);
    };
  }
});
const ModalDialog = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/common/modal-dialog.vue"]]);
const useMetadataStore = defineStore(
  "metadata",
  () => {
    const metadataId = ref();
    function setMetadataId(id) {
      metadataId.value = id;
    }
    function clearMetadataId() {
      metadataId.value = void 0;
    }
    return {
      metadataId,
      setMetadataId,
      clearMetadataId
    };
  },
  {}
);
const _hoisted_1$l = {
  class: "mb-px",
  key: "node.id"
};
const _hoisted_2$i = ["aria-expanded", "data-cy"];
const _hoisted_3$g = { class: "leading-6" };
const _hoisted_4$e = ["aria-expanded", "data-cy"];
const _hoisted_5$c = { class: "grow" };
const _hoisted_6$8 = { class: "leading-6" };
const _hoisted_7$5 = {
  key: 1,
  class: "flex text-tertiary pr-2"
};
const _hoisted_8$5 = ["data-cy"];
const _hoisted_9$3 = { class: "ml-1 hover:underline" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: true }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const { t } = useTranslation();
    const { setMetadataId } = useMetadataStore();
    const isParent = !!props.node.children;
    const isRoot = props.node.depth === 0;
    const isMaxDepth = props.node.depth >= 10;
    const label = computed(() => t(props.node.name, { ns: "client" }));
    function toggleLayer(node) {
      emit2("toggleLayer", node);
    }
    function toggleParent(node) {
      emit2("toggleParent", node);
    }
    return (_ctx, _cache) => {
      const _component_layer_tree_node = resolveComponent("layer-tree-node", true);
      return isParent ? (openBlock(), createElementBlock("div", _hoisted_1$l, [
        createCommentVNode("    First level parents"),
        __props.node.depth === 1 ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "group node-1 w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
          "aria-expanded": __props.node.expanded,
          onClick: _cache[0] || (_cache[0] = ($event) => toggleParent(__props.node)),
          "data-cy": `parentLayerLabel-${__props.node.id}`
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["grow", __props.node.expanded ? "text-white" : "text-secondary"])
          }, toDisplayString(unref(label)), 3),
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("div", {
              class: normalizeClass(["fa fa-sharp fa-solid group-hover:text-white text-primary", __props.node.expanded ? "fa-caret-up" : "fa-caret-down"])
            }, null, 2)
          ])
        ], 8, _hoisted_2$i)) : __props.node.depth > 1 && !isMaxDepth ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createCommentVNode("    Other parents"),
          createBaseVNode("button", {
            class: normalizeClass(["w-full text-left flex px-2 py-1.5 pl-2", __props.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": __props.node.expanded,
            onClick: _cache[1] || (_cache[1] = ($event) => toggleParent(__props.node)),
            "data-cy": `parentLayerLabel-${__props.node.id}`
          }, [
            createBaseVNode("div", _hoisted_5$c, toDisplayString(unref(label)), 1),
            createBaseVNode("div", _hoisted_6$8, [
              createBaseVNode("div", {
                class: normalizeClass(["fa-sharp fa-solid", __props.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, _hoisted_4$e)
        ], 2112)) : createCommentVNode("v-if", true),
        createCommentVNode("    Children"),
        !isMaxDepth ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(["bg-secondary", [
            { "pl-2": __props.node.depth > 1 },
            { "lux-collapse": !isRoot },
            { expanded: !isRoot && __props.node.expanded }
          ]])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.node.children, (child) => {
            return openBlock(), createBlock(_component_layer_tree_node, {
              key: child.id,
              node: child,
              onToggleParent: _cache[2] || (_cache[2] = ($event) => toggleParent($event)),
              onToggleLayer: _cache[3] || (_cache[3] = ($event) => toggleLayer($event))
            }, null, 8, ["node"]);
          }), 128))
        ], 2)) : createCommentVNode("v-if", true)
      ])) : (openBlock(), createElementBlock("div", _hoisted_7$5, [
        createBaseVNode("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: _cache[4] || (_cache[4] = ($event) => unref(setMetadataId)(__props.node.id))
        }),
        createBaseVNode("button", {
          class: normalizeClass(["w-full text-left", { "font-bold": __props.node.checked }]),
          onClick: _cache[5] || (_cache[5] = ($event) => toggleLayer(__props.node)),
          "data-cy": `layerLabel-${__props.node.id}`
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["fa-solid", __props.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          createBaseVNode("span", _hoisted_9$3, toDisplayString(unref(label)), 1)
        ], 10, _hoisted_8$5)
      ]));
    };
  }
});
const LayerTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-tree/layer-tree-node.vue"]]);
class LayerTreeService {
  toggleNode(id, node, propertyName) {
    var _a;
    if ((node == null ? void 0 : node.id) === id) {
      return {
        ...node,
        [propertyName]: !node[propertyName]
      };
    } else {
      return {
        ...node,
        children: (_a = node.children) == null ? void 0 : _a.map(
          (child) => this.toggleNode(id, child, propertyName)
        )
      };
    }
  }
  updateLayers(node, layers) {
    const { id } = node;
    if (node.children) {
      return {
        ...node,
        children: node.children.map((child) => this.updateLayers(child, layers))
      };
    } else {
      const checked = !!(layers == null ? void 0 : layers.find((l) => l.id === id));
      return {
        ...node,
        checked
      };
    }
  }
}
const layerTreeService = new LayerTreeService();
var LayerImageType = /* @__PURE__ */ ((LayerImageType2) => {
  LayerImageType2["PNG"] = "image/png";
  LayerImageType2["JPG"] = "image/jpeg";
  return LayerImageType2;
})(LayerImageType || {});
var REMOTE_SERVICE_TYPE = /* @__PURE__ */ ((REMOTE_SERVICE_TYPE2) => {
  REMOTE_SERVICE_TYPE2["WMS"] = "WMS";
  REMOTE_SERVICE_TYPE2["WMTS"] = "WMTS";
  return REMOTE_SERVICE_TYPE2;
})(REMOTE_SERVICE_TYPE || {});
class EndpointError {
  constructor(message, httpStatus = 0, isCrossOriginRelated = false) {
    this.message = message;
    this.httpStatus = httpStatus;
    this.isCrossOriginRelated = isCrossOriginRelated;
  }
}
let counter = 0;
function getUniqueId() {
  return counter++;
}
function sendTaskRequest(taskName, workerInstance2, params2) {
  return new Promise((resolve2, reject) => {
    const requestId = getUniqueId();
    const request3 = {
      requestId,
      taskName,
      params: params2
    };
    if (workerInstance2 === null) {
      window.dispatchEvent(
        new CustomEvent("ogc-client.request", {
          detail: request3
        })
      );
    } else {
      workerInstance2.postMessage(request3);
    }
    const handler = ({ detail, data }) => {
      const response = detail || data;
      if (response.requestId === requestId) {
        if (workerInstance2 === null) {
          window.removeEventListener("message", handler);
        } else {
          workerInstance2.removeEventListener("message", handler);
        }
        if ("error" in response) {
          reject(response.error);
        } else {
          resolve2(response.response);
        }
      }
    };
    if (workerInstance2 === null) {
      window.addEventListener("ogc-client.response", handler);
    } else {
      workerInstance2.addEventListener("message", handler);
    }
  });
}
function addTaskHandler(taskName, scope, handler) {
  const useWorker = typeof WorkerGlobalScope !== "undefined";
  const eventHandler = async ({ detail, data }) => {
    const request3 = detail || data;
    if (request3.taskName === taskName) {
      let response, error2;
      try {
        response = await handler(request3.params);
      } catch (e) {
        error2 = e;
      }
      const message = {
        taskName,
        requestId: request3.requestId,
        ...response && { response },
        ...error2 && { error: error2 }
      };
      if (useWorker) {
        scope.postMessage(message);
      } else {
        scope.dispatchEvent(
          new CustomEvent("ogc-client.response", {
            detail: message
          })
        );
      }
    }
  };
  if (useWorker) {
    scope.addEventListener("message", eventHandler);
  } else {
    scope.addEventListener("ogc-client.request", eventHandler);
  }
}
let workerInstance;
function getWorkerInstance() {
  if (!workerInstance) {
    workerInstance = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
      type: "module"
    });
  }
  return workerInstance;
}
function parseWmsCapabilities(capabilitiesUrl) {
  return sendTaskRequest("parseWmsCapabilities", getWorkerInstance(), {
    url: capabilitiesUrl
  });
}
const emptyString$1 = "";
class StringScanner$1 {
  constructor(string) {
    this.chars = [...string];
    this.charCount = this.chars.length;
    this.charIndex = 0;
    this.charsToBytes = new Array(this.charCount);
    this.multiByteMode = false;
    this.string = string;
    let { chars: chars2, charCount, charsToBytes } = this;
    if (charCount === string.length) {
      for (let i = 0; i < charCount; ++i) {
        charsToBytes[i] = i;
      }
    } else {
      for (let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {
        charsToBytes[charIndex] = byteIndex;
        byteIndex += chars2[charIndex].length;
      }
      this.multiByteMode = true;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(string) {
    let { length } = string;
    if (length < 2 || !this.multiByteMode) {
      return length;
    }
    return string.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(count = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + count);
  }
  consume(count = 1) {
    let chars2 = this.peek(count);
    this.advance(count);
    return chars2;
  }
  consumeMatch(regex) {
    if (!regex.sticky) {
      throw new Error('`regex` must have a sticky flag ("y")');
    }
    regex.lastIndex = this.charsToBytes[this.charIndex];
    let result = regex.exec(this.string);
    if (result === null) {
      return emptyString$1;
    }
    let match2 = result[0];
    this.advance(this._charLength(match2));
    return match2;
  }
  consumeMatchFn(fn) {
    let startIndex = this.charIndex;
    while (!this.isEnd && fn(this.peek())) {
      this.advance();
    }
    return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString$1;
  }
  consumeString(stringToConsume) {
    if (this.consumeStringFast(stringToConsume)) {
      return stringToConsume;
    }
    if (!this.multiByteMode) {
      return emptyString$1;
    }
    let { length } = stringToConsume;
    let charLengthToMatch = this._charLength(stringToConsume);
    if (charLengthToMatch !== length && stringToConsume === this.peek(charLengthToMatch)) {
      this.advance(charLengthToMatch);
      return stringToConsume;
    }
    return emptyString$1;
  }
  consumeStringFast(stringToConsume) {
    if (this.peek() === stringToConsume[0]) {
      let { length } = stringToConsume;
      if (length === 1) {
        this.advance();
        return stringToConsume;
      }
      if (this.peek(length) === stringToConsume) {
        this.advance(length);
        return stringToConsume;
      }
    }
    return emptyString$1;
  }
  consumeUntilMatch(regex) {
    if (!regex.global) {
      throw new Error('`regex` must have a global flag ("g")');
    }
    let byteIndex = this.charsToBytes[this.charIndex];
    regex.lastIndex = byteIndex;
    let match2 = regex.exec(this.string);
    if (match2 === null || match2.index === byteIndex) {
      return emptyString$1;
    }
    let result = this.string.slice(byteIndex, match2.index);
    this.advance(this._charLength(result));
    return result;
  }
  consumeUntilString(searchString) {
    let { charIndex, charsToBytes, string } = this;
    let byteIndex = charsToBytes[charIndex];
    let matchByteIndex = string.indexOf(searchString, byteIndex);
    if (matchByteIndex <= 0) {
      return emptyString$1;
    }
    let result = string.slice(byteIndex, matchByteIndex);
    this.advance(this._charLength(result));
    return result;
  }
  peek(count = 1) {
    if (this.charIndex >= this.charCount) {
      return emptyString$1;
    }
    if (count === 1) {
      return this.chars[this.charIndex];
    }
    let { charsToBytes, charIndex } = this;
    return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);
  }
  reset(index2 = 0) {
    this.charIndex = index2 >= 0 ? Math.min(this.charCount, index2) : Math.max(0, this.charIndex + index2);
  }
}
var StringScanner_1 = StringScanner$1;
var syntax$1 = {};
const predefinedEntities = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
syntax$1.predefinedEntities = predefinedEntities;
function isNameChar(char) {
  if (isNameStartChar(char)) {
    return true;
  }
  let cp = getCodePoint(char);
  return cp === 45 || cp === 46 || cp >= 48 && cp <= 57 || cp === 183 || cp >= 768 && cp <= 879 || cp >= 8255 && cp <= 8256;
}
syntax$1.isNameChar = isNameChar;
function isNameStartChar(char) {
  let cp = getCodePoint(char);
  return cp === 58 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 192 && cp <= 214 || cp >= 216 && cp <= 246 || cp >= 248 && cp <= 767 || cp >= 880 && cp <= 893 || cp >= 895 && cp <= 8191 || cp >= 8204 && cp <= 8205 || cp >= 8304 && cp <= 8591 || cp >= 11264 && cp <= 12271 || cp >= 12289 && cp <= 55295 || cp >= 63744 && cp <= 64975 || cp >= 65008 && cp <= 65533 || cp >= 65536 && cp <= 983039;
}
syntax$1.isNameStartChar = isNameStartChar;
function isNotXmlChar(char) {
  return !isXmlChar(char);
}
syntax$1.isNotXmlChar = isNotXmlChar;
function isReferenceChar(char) {
  return char === "#" || isNameChar(char);
}
syntax$1.isReferenceChar = isReferenceChar;
function isWhitespace(char) {
  let cp = getCodePoint(char);
  return cp === 32 || cp === 9 || cp === 10 || cp === 13;
}
syntax$1.isWhitespace = isWhitespace;
function isXmlChar(char) {
  let cp = getCodePoint(char);
  return cp === 9 || cp === 10 || cp === 13 || cp >= 32 && cp <= 55295 || cp >= 57344 && cp <= 65533 || cp >= 65536 && cp <= 1114111;
}
syntax$1.isXmlChar = isXmlChar;
function getCodePoint(char) {
  return char.codePointAt(0) || -1;
}
class XmlNode$7 {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : false;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let json = {
      type: this.type
    };
    if (this.isRootNode) {
      json.isRootNode = true;
    }
    if (this.preserveWhitespace) {
      json.preserveWhitespace = true;
    }
    return json;
  }
}
XmlNode$7.TYPE_CDATA = "cdata";
XmlNode$7.TYPE_COMMENT = "comment";
XmlNode$7.TYPE_DOCUMENT = "document";
XmlNode$7.TYPE_ELEMENT = "element";
XmlNode$7.TYPE_PROCESSING_INSTRUCTION = "pi";
XmlNode$7.TYPE_TEXT = "text";
var XmlNode_1 = XmlNode$7;
const XmlNode$6 = XmlNode_1;
class XmlText$3 extends XmlNode$6 {
  constructor(text2 = "") {
    super();
    this.text = text2;
  }
  get type() {
    return XmlNode$6.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(XmlNode$6.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var XmlText_1 = XmlText$3;
const XmlNode$5 = XmlNode_1;
const XmlText$2 = XmlText_1;
class XmlCdata$2 extends XmlText$2 {
  get type() {
    return XmlNode$5.TYPE_CDATA;
  }
}
var XmlCdata_1 = XmlCdata$2;
const XmlNode$4 = XmlNode_1;
class XmlComment$2 extends XmlNode$4 {
  constructor(content = "") {
    super();
    this.content = content;
  }
  get type() {
    return XmlNode$4.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(XmlNode$4.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var XmlComment_1 = XmlComment$2;
const XmlNode$3 = XmlNode_1;
class XmlElement$3 extends XmlNode$3 {
  constructor(name, attributes = /* @__PURE__ */ Object.create(null), children = []) {
    super();
    this.name = name;
    this.attributes = attributes;
    this.children = children;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let node = this;
    while (node instanceof XmlElement$3) {
      if ("xml:space" in node.attributes) {
        return node.attributes["xml:space"] === "preserve";
      }
      node = node.parent;
    }
    return false;
  }
  get text() {
    return this.children.map((child) => "text" in child ? child.text : "").join("");
  }
  get type() {
    return XmlNode$3.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(XmlNode$3.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((child) => child.toJSON())
    });
  }
}
var XmlElement_1 = XmlElement$3;
const XmlElement$2 = XmlElement_1;
const XmlNode$2 = XmlNode_1;
class XmlDocument$2 extends XmlNode$2 {
  constructor(children = []) {
    super();
    this.children = children;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((child) => child instanceof XmlElement$2) || null;
  }
  get text() {
    return this.children.map((child) => "text" in child ? child.text : "").join("");
  }
  get type() {
    return XmlNode$2.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(XmlNode$2.prototype.toJSON.call(this), {
      children: this.children.map((child) => child.toJSON())
    });
  }
}
var XmlDocument_1 = XmlDocument$2;
const XmlNode$1 = XmlNode_1;
class XmlProcessingInstruction$2 extends XmlNode$1 {
  constructor(name, content = "") {
    super();
    this.name = name;
    this.content = content;
  }
  get type() {
    return XmlNode$1.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(XmlNode$1.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var XmlProcessingInstruction_1 = XmlProcessingInstruction$2;
const StringScanner = StringScanner_1;
const syntax = syntax$1;
const XmlCdata$1 = XmlCdata_1;
const XmlComment$1 = XmlComment_1;
const XmlDocument$1 = XmlDocument_1;
const XmlElement$1 = XmlElement_1;
const XmlProcessingInstruction$1 = XmlProcessingInstruction_1;
const XmlText$1 = XmlText_1;
const emptyString = "";
class Parser$1 {
  constructor(xml2, options = {}) {
    this.document = new XmlDocument$1();
    this.currentNode = this.document;
    this.options = options;
    this.scanner = new StringScanner(normalizeXmlString(xml2));
    this.consumeProlog();
    if (!this.consumeElement()) {
      this.error("Root element is missing or invalid");
    }
    while (this.consumeMisc()) {
    }
    if (!this.scanner.isEnd) {
      this.error("Extra content at the end of the document");
    }
  }
  addNode(node) {
    node.parent = this.currentNode;
    this.currentNode.children.push(node);
  }
  addText(text2) {
    let { children } = this.currentNode;
    if (children.length > 0) {
      let prevNode = children[children.length - 1];
      if (prevNode instanceof XmlText$1) {
        prevNode.text += text2;
        return;
      }
    }
    this.addNode(new XmlText$1(text2));
  }
  consumeAttributeValue() {
    let { scanner } = this;
    let quote = scanner.peek();
    if (quote !== '"' && quote !== "'") {
      return false;
    }
    scanner.advance();
    let chars2;
    let isClosed = false;
    let value = emptyString;
    let regex = quote === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    matchLoop:
      while (!scanner.isEnd) {
        chars2 = scanner.consumeMatch(regex);
        if (chars2) {
          this.validateChars(chars2);
          value += chars2.replace(/[\t\r\n]/g, " ");
        }
        let nextChar = scanner.peek();
        switch (nextChar) {
          case quote:
            isClosed = true;
            break matchLoop;
          case "&":
            value += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case emptyString:
            this.error("Unclosed attribute");
            break;
        }
      }
    if (!isClosed) {
      this.error("Unclosed attribute");
    }
    scanner.advance();
    return value;
  }
  consumeCdataSection() {
    let { scanner } = this;
    if (!scanner.consumeStringFast("<![CDATA[")) {
      return false;
    }
    let text2 = scanner.consumeUntilString("]]>");
    this.validateChars(text2);
    if (!scanner.consumeStringFast("]]>")) {
      this.error("Unclosed CDATA section");
    }
    if (this.options.preserveCdata) {
      this.addNode(new XmlCdata$1(text2));
    } else {
      this.addText(text2);
    }
    return true;
  }
  consumeCharData() {
    let { scanner } = this;
    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);
    if (!charData) {
      return false;
    }
    this.validateChars(charData);
    if (scanner.peek() === "]" && scanner.peek(3) === "]]>") {
      this.error("Element content may not contain the CDATA section close delimiter `]]>`");
    }
    this.addText(charData);
    return true;
  }
  consumeComment() {
    let { scanner } = this;
    if (!scanner.consumeStringFast("<!--")) {
      return false;
    }
    let content = scanner.consumeUntilString("--");
    this.validateChars(content);
    if (!scanner.consumeStringFast("-->")) {
      if (scanner.peek(2) === "--") {
        this.error("The string `--` isn't allowed inside a comment");
      } else {
        this.error("Unclosed comment");
      }
    }
    if (this.options.preserveComments) {
      this.addNode(new XmlComment$1(content.trim()));
    }
    return true;
  }
  consumeContentReference() {
    let ref2 = this.consumeReference();
    if (ref2) {
      this.addText(ref2);
      return true;
    }
    return false;
  }
  consumeDoctypeDeclaration() {
    let { scanner } = this;
    if (!scanner.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace()) {
      return false;
    }
    scanner.consumeMatch(/[^[>]+/y);
    if (scanner.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y)) {
      return true;
    }
    if (!scanner.consumeStringFast(">")) {
      this.error("Unclosed doctype declaration");
    }
    return true;
  }
  consumeElement() {
    let { scanner } = this;
    let mark = scanner.charIndex;
    if (scanner.peek() !== "<") {
      return false;
    }
    scanner.advance();
    let name = this.consumeName();
    if (!name) {
      scanner.reset(mark);
      return false;
    }
    let attributes = /* @__PURE__ */ Object.create(null);
    while (this.consumeWhitespace()) {
      let attrName = this.consumeName();
      if (!attrName) {
        continue;
      }
      let attrValue = this.consumeEqual() && this.consumeAttributeValue();
      if (attrValue === false) {
        this.error("Attribute value expected");
      }
      if (attrName in attributes) {
        this.error(`Duplicate attribute: ${attrName}`);
      }
      if (attrName === "xml:space" && attrValue !== "default" && attrValue !== "preserve") {
        this.error('Value of the `xml:space` attribute must be "default" or "preserve"');
      }
      attributes[attrName] = attrValue;
    }
    if (this.options.sortAttributes) {
      let attrNames = Object.keys(attributes).sort();
      let sortedAttributes = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < attrNames.length; ++i) {
        let attrName = attrNames[i];
        sortedAttributes[attrName] = attributes[attrName];
      }
      attributes = sortedAttributes;
    }
    let isEmpty = Boolean(scanner.consumeStringFast("/>"));
    let element = new XmlElement$1(name, attributes);
    element.parent = this.currentNode;
    if (!isEmpty) {
      if (!scanner.consumeStringFast(">")) {
        this.error(`Unclosed start tag for element \`${name}\``);
      }
      this.currentNode = element;
      this.consumeCharData();
      while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {
        this.consumeCharData();
      }
      let endTagMark = scanner.charIndex;
      let endTagName;
      if (!scanner.consumeStringFast("</") || !(endTagName = this.consumeName()) || endTagName !== name) {
        scanner.reset(endTagMark);
        this.error(`Missing end tag for element ${name}`);
      }
      this.consumeWhitespace();
      if (!scanner.consumeStringFast(">")) {
        this.error(`Unclosed end tag for element ${name}`);
      }
      this.currentNode = element.parent;
    }
    this.addNode(element);
    return true;
  }
  consumeEqual() {
    this.consumeWhitespace();
    if (this.scanner.consumeStringFast("=")) {
      this.consumeWhitespace();
      return true;
    }
    return false;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;
  }
  consumeProcessingInstruction() {
    let { scanner } = this;
    let mark = scanner.charIndex;
    if (!scanner.consumeStringFast("<?")) {
      return false;
    }
    let name = this.consumeName();
    if (name) {
      if (name.toLowerCase() === "xml") {
        scanner.reset(mark);
        this.error("XML declaration isn't allowed here");
      }
    } else {
      this.error("Invalid processing instruction");
    }
    if (!this.consumeWhitespace()) {
      if (scanner.consumeStringFast("?>")) {
        this.addNode(new XmlProcessingInstruction$1(name));
        return true;
      }
      this.error("Whitespace is required after a processing instruction name");
    }
    let content = scanner.consumeUntilString("?>");
    this.validateChars(content);
    if (!scanner.consumeStringFast("?>")) {
      this.error("Unterminated processing instruction");
    }
    this.addNode(new XmlProcessingInstruction$1(name, content));
    return true;
  }
  consumeProlog() {
    let { scanner } = this;
    let mark = scanner.charIndex;
    this.consumeXmlDeclaration();
    while (this.consumeMisc()) {
    }
    if (this.consumeDoctypeDeclaration()) {
      while (this.consumeMisc()) {
      }
    }
    return mark < scanner.charIndex;
  }
  consumeReference() {
    let { scanner } = this;
    if (scanner.peek() !== "&") {
      return false;
    }
    scanner.advance();
    let ref2 = scanner.consumeMatchFn(syntax.isReferenceChar);
    if (scanner.consume() !== ";") {
      this.error("Unterminated reference (a reference must end with `;`)");
    }
    let parsedValue;
    if (ref2[0] === "#") {
      let codePoint = ref2[1] === "x" ? parseInt(ref2.slice(2), 16) : parseInt(ref2.slice(1), 10);
      if (isNaN(codePoint)) {
        this.error("Invalid character reference");
      }
      parsedValue = String.fromCodePoint(codePoint);
      if (!syntax.isXmlChar(parsedValue)) {
        this.error("Character reference resolves to an invalid character");
      }
    } else {
      parsedValue = syntax.predefinedEntities[ref2];
      if (parsedValue === void 0) {
        let {
          ignoreUndefinedEntities,
          resolveUndefinedEntity
        } = this.options;
        let wrappedRef = `&${ref2};`;
        if (resolveUndefinedEntity) {
          let resolvedValue = resolveUndefinedEntity(wrappedRef);
          if (resolvedValue !== null && resolvedValue !== void 0) {
            let type = typeof resolvedValue;
            if (type !== "string") {
              throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
            }
            return resolvedValue;
          }
        }
        if (ignoreUndefinedEntities) {
          return wrappedRef;
        }
        scanner.reset(-wrappedRef.length);
        this.error(`Named entity isn't defined: ${wrappedRef}`);
      }
    }
    return parsedValue;
  }
  consumeSystemLiteral() {
    let { scanner } = this;
    let quote = scanner.consumeStringFast('"') || scanner.consumeStringFast("'");
    if (!quote) {
      return false;
    }
    let value = scanner.consumeUntilString(quote);
    this.validateChars(value);
    if (!scanner.consumeStringFast(quote)) {
      this.error("Missing end quote");
    }
    return value;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner } = this;
    if (!scanner.consumeStringFast("<?xml")) {
      return false;
    }
    if (!this.consumeWhitespace()) {
      this.error("Invalid XML declaration");
    }
    let version2 = Boolean(scanner.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (version2 === false) {
      this.error("XML version is missing or invalid");
    } else if (!/^1\.[0-9]+$/.test(version2)) {
      this.error("Invalid character in version number");
    }
    if (this.consumeWhitespace()) {
      let encoding = Boolean(scanner.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral();
      if (encoding) {
        this.consumeWhitespace();
      }
      let standalone = Boolean(scanner.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      if (standalone) {
        if (standalone !== "yes" && standalone !== "no") {
          this.error('Only "yes" and "no" are permitted as values of `standalone`');
        }
        this.consumeWhitespace();
      }
    }
    if (!scanner.consumeStringFast("?>")) {
      this.error("Invalid or unclosed XML declaration");
    }
    return true;
  }
  error(message) {
    let { charIndex, string: xml2 } = this.scanner;
    let column = 1;
    let excerpt = "";
    let line = 1;
    for (let i = 0; i < charIndex; ++i) {
      let char = xml2[i];
      if (char === "\n") {
        column = 1;
        excerpt = "";
        line += 1;
      } else {
        column += 1;
        excerpt += char;
      }
    }
    let eol = xml2.indexOf("\n", charIndex);
    excerpt += eol === -1 ? xml2.slice(charIndex) : xml2.slice(charIndex, eol);
    let excerptStart = 0;
    if (excerpt.length > 50) {
      if (column < 40) {
        excerpt = excerpt.slice(0, 50);
      } else {
        excerptStart = column - 20;
        excerpt = excerpt.slice(excerptStart, column + 30);
      }
    }
    let err = new Error(
      `${message} (line ${line}, column ${column})
  ${excerpt}
` + " ".repeat(column - excerptStart + 1) + "^\n"
    );
    Object.assign(err, {
      column,
      excerpt,
      line,
      pos: charIndex
    });
    throw err;
  }
  validateChars(string) {
    let charIndex = 0;
    for (let char of string) {
      if (syntax.isNotXmlChar(char)) {
        this.scanner.reset(-([...string].length - charIndex));
        this.error("Invalid character");
      }
      charIndex += 1;
    }
  }
}
var Parser_1 = Parser$1;
function normalizeXmlString(xml2) {
  if (xml2[0] === "\uFEFF") {
    xml2 = xml2.slice(1);
  }
  return xml2.replace(/\r\n?/g, "\n");
}
const Parser = Parser_1;
const XmlCdata = XmlCdata_1;
const XmlComment = XmlComment_1;
const XmlDocument = XmlDocument_1;
const XmlElement = XmlElement_1;
const XmlNode = XmlNode_1;
const XmlProcessingInstruction = XmlProcessingInstruction_1;
const XmlText = XmlText_1;
function parseXml(xml2, options) {
  return new Parser(xml2, options).document;
}
parseXml.XmlCdata = XmlCdata;
parseXml.XmlComment = XmlComment;
parseXml.XmlDocument = XmlDocument;
parseXml.XmlElement = XmlElement;
parseXml.XmlNode = XmlNode;
parseXml.XmlProcessingInstruction = XmlProcessingInstruction;
parseXml.XmlText = XmlText;
var src = parseXml;
class XmlParseError extends Error {
  constructor(message) {
    super(message);
  }
}
function parseXmlString(xmlString) {
  let doc2 = null;
  try {
    doc2 = src(xmlString);
  } catch (e) {
    throw new XmlParseError(e.message);
  }
  return doc2;
}
function getRootElement(xmlDoc) {
  return xmlDoc.children[0];
}
function stripNamespace(name) {
  const colon = name.indexOf(":");
  return colon > -1 ? name.substr(colon + 1) : name;
}
function getElementName(element) {
  return element.name || "";
}
function findChildrenElement(element, name, nested) {
  const strippedName = stripNamespace(name);
  function reducer(prev, curr) {
    if (stripNamespace(getElementName(curr)) === strippedName) {
      prev.push(curr);
    }
    if (nested && Array.isArray(curr.children)) {
      return [...prev, ...curr.children.reduce(reducer, [])];
    } else {
      return prev;
    }
  }
  return element && Array.isArray(element.children) ? element.children.reduce(reducer, []) : [];
}
function findChildElement(element, name, nested) {
  return findChildrenElement(element, name, nested)[0] || null;
}
function getChildrenElement(element) {
  return element && Array.isArray(element.children) ? [...element.children.filter((el) => el.constructor.name === "XmlElement")] : [];
}
function getElementText(element) {
  const textNode = element && Array.isArray(element.children) ? element.children.find((node) => node.type === "text") : null;
  return textNode ? textNode.text : "";
}
function getElementAttribute(element, attrName) {
  return element && element.attributes[attrName] || "";
}
const ENCODINGS = ["utf-8", "utf-16", "iso-8859-1"];
const FALLBACK_ENCODING = "utf-8";
function extractEncoding(contentType) {
  const matches2 = /charset=([^;]+)/.exec(contentType);
  return matches2 ? matches2[1] : null;
}
function decodeString(buffer2, contentType) {
  const encodingHint = contentType ? extractEncoding(contentType) : null;
  const encodingAttempts = encodingHint ? [encodingHint, ...ENCODINGS] : ENCODINGS;
  for (const encoding of encodingAttempts) {
    try {
      const decoder = new TextDecoder(encoding, { fatal: true });
      return decoder.decode(buffer2);
    } catch (e) {
    }
  }
  console.warn(
    `XML document encoding could not be determined, falling back to ${FALLBACK_ENCODING}.`
  );
  return new TextDecoder(FALLBACK_ENCODING).decode(buffer2);
}
const fetchPromises = /* @__PURE__ */ new Map();
function sharedFetch(url) {
  if (fetchPromises.has(url)) {
    return fetchPromises.get(url);
  }
  const promise = fetch(url);
  promise.finally(() => fetchPromises.delete(url));
  fetchPromises.set(url, promise);
  return promise;
}
function queryXmlDocument(url) {
  return sharedFetch(url).catch(
    () => fetch(url, { method: "HEAD", mode: "no-cors" }).catch((error2) => {
      throw new EndpointError(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${error2.message}`,
        0,
        false
      );
    }).then(() => {
      throw new EndpointError(
        `The document could not be fetched due to CORS limitations`,
        0,
        true
      );
    })
  ).then(async (resp) => {
    if (!resp.ok) {
      const text2 = await resp.text();
      throw new EndpointError(
        `Received an error with code ${resp.status}: ${text2}`,
        resp.status,
        false
      );
    }
    const buffer2 = await resp.arrayBuffer();
    const contentTypeHeader = resp.headers.get("Content-Type");
    return decodeString(buffer2, contentTypeHeader);
  }).then((xml2) => parseXmlString(xml2));
}
function setQueryParams(url, params2) {
  const encodedUrlMatch = url.match(/(https?%3A%2F%2F[^/]+)$/);
  if (encodedUrlMatch) {
    const encodedUrl = encodedUrlMatch[1];
    const modifiedUrl = setQueryParams(decodeURIComponent(encodedUrl), params2);
    return url.replace(encodedUrl, encodeURIComponent(modifiedUrl));
  }
  const urlObj = new URL(url);
  const keys = Object.keys(params2);
  const keysLower = keys.map((key) => key.toLowerCase());
  const toDelete = [];
  for (const param of urlObj.searchParams.keys()) {
    if (keysLower.indexOf(param.toLowerCase()) > -1) {
      toDelete.push(param);
    }
  }
  toDelete.map((param) => urlObj.searchParams.delete(param));
  keys.forEach(
    (key) => urlObj.searchParams.set(key, params2[key] === true ? "" : params2[key])
  );
  return urlObj.toString();
}
let cacheExpiryDuration = 1e3 * 60 * 60;
function getCacheExpiryDuration() {
  return cacheExpiryDuration;
}
const cachePromise = "caches" in self ? caches.open("ogc-client") : null;
async function storeCacheEntry(object, ...keys) {
  if (!cachePromise)
    return;
  const entryUrl = "https://cache/" + keys.join("/");
  const cache = await cachePromise;
  await cache.put(
    entryUrl,
    new Response(JSON.stringify(object), {
      headers: {
        "x-expiry": (Date.now() + getCacheExpiryDuration()).toString(10)
      }
    })
  );
}
async function hasValidCacheEntry(...keys) {
  if (!cachePromise)
    return false;
  const entryUrl = "https://cache/" + keys.join("/");
  const cache = await cachePromise;
  return cache.match(entryUrl).then((req) => !!req && parseInt(req.headers.get("x-expiry")) > Date.now());
}
async function readCacheEntry(...keys) {
  if (!cachePromise)
    return null;
  const entryUrl = "https://cache/" + keys.join("/");
  const cache = await cachePromise;
  const response = await cache.match(entryUrl);
  return response ? response.clone().json() : null;
}
const tasksMap = /* @__PURE__ */ new Map();
async function useCache(factory, ...keys) {
  await purgeEntries();
  if (await hasValidCacheEntry(...keys)) {
    return readCacheEntry(...keys);
  }
  const taskKey = keys.join("#");
  if (tasksMap.has(taskKey)) {
    return tasksMap.get(taskKey);
  }
  const taskRun = factory();
  if (taskRun instanceof Promise) {
    taskRun.then(() => tasksMap.delete(taskKey));
    tasksMap.set(taskKey, taskRun);
  }
  const result = await taskRun;
  await storeCacheEntry(result, ...keys);
  return result;
}
async function purgeEntries() {
  if (!cachePromise)
    return;
  const cache = await cachePromise;
  const keys = await cache.keys();
  for (let key of keys) {
    const resp = await cache.match(key);
    if (parseInt(resp.headers.get("x-expiry")) <= Date.now())
      await cache.delete(key);
  }
}
function generateGetFeatureUrl(serviceUrl, version2, featureType, outputFormat, maxFeatures, attributes, hitsOnly, outputCrs, extent, extentCrs) {
  const typeParam = version2 === "2.0.0" ? "TYPENAMES" : "TYPENAME";
  const countParam = version2 === "2.0.0" ? "COUNT" : "MAXFEATURES";
  const newParams = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: version2,
    [typeParam]: featureType
  };
  if (outputFormat !== void 0)
    newParams.OUTPUTFORMAT = outputFormat;
  if (attributes !== void 0)
    newParams.PROPERTYNAME = attributes.join(",");
  if (hitsOnly) {
    newParams.RESULTTYPE = "hits";
    newParams[countParam] = "1";
  } else if (maxFeatures !== void 0)
    newParams[countParam] = maxFeatures.toString(10);
  if (outputCrs) {
    newParams.SRSNAME = outputCrs;
  }
  if (extent) {
    const extentJoined = extent.join(",");
    newParams.BBOX = extentCrs ? `${extentJoined},${extentCrs}` : extentJoined;
  }
  return setQueryParams(serviceUrl, newParams);
}
class WmsEndpoint {
  constructor(url) {
    const capabilitiesUrl = setQueryParams(url, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = useCache(
      () => parseWmsCapabilities(capabilitiesUrl),
      "WMS",
      "CAPABILITIES",
      capabilitiesUrl
    ).then(({ info, layers, version: version2 }) => {
      this._info = info;
      this._layers = layers;
      this._version = version2;
    });
    this._info = null;
    this._layers = null;
    this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function layerSummaryMapper(layerFull) {
      return {
        title: layerFull.title,
        name: layerFull.name,
        abstract: layerFull.abstract,
        ..."children" in layerFull && {
          children: layerFull.children.map(layerSummaryMapper)
        }
      };
    }
    return this._layers.map(layerSummaryMapper);
  }
  getLayerByName(name) {
    let result = null;
    function layerLookup(layer) {
      if (result !== null)
        return;
      if (layer.name === name) {
        result = layer;
        return;
      }
      if ("children" in layer) {
        layer.children.map(layerLookup);
      }
    }
    this._layers.map(layerLookup);
    return result;
  }
  getVersion() {
    return this._version;
  }
}
const LatLonCrsList = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function hasInvertedCoordinates(crsName) {
  return LatLonCrsList.indexOf(simplifyEpsgUrn(crsName)) > -1;
}
function simplifyEpsgUrn(fullCrsName) {
  if (/^urn:(?:x-)?ogc:def:crs:epsg:/.test(fullCrsName.toLowerCase())) {
    const code = /([0-9]+)$/.exec(fullCrsName)[1];
    return `EPSG:${code}`;
  }
  return fullCrsName;
}
function readVersionFromCapabilities$1(capabilitiesDoc) {
  return getRootElement(capabilitiesDoc).attributes["version"];
}
function readLayersFromCapabilities(capabilitiesDoc) {
  const version2 = readVersionFromCapabilities$1(capabilitiesDoc);
  const capability = findChildElement(
    getRootElement(capabilitiesDoc),
    "Capability"
  );
  return findChildrenElement(capability, "Layer").map(
    (layerEl) => parseLayer(layerEl, version2)
  );
}
function readInfoFromCapabilities$1(capabilitiesDoc) {
  const service = findChildElement(getRootElement(capabilitiesDoc), "Service");
  const keywords = findChildrenElement(
    findChildElement(service, "KeywordList"),
    "Keyword"
  ).map(getElementText).filter((v2, i, arr2) => arr2.indexOf(v2) === i);
  return {
    title: getElementText(findChildElement(service, "Title")),
    name: getElementText(findChildElement(service, "Name")),
    abstract: getElementText(findChildElement(service, "Abstract")),
    fees: getElementText(findChildElement(service, "Fees")),
    constraints: getElementText(findChildElement(service, "AccessConstraints")),
    keywords
  };
}
function parseLayer(layerEl, version2, inheritedSrs = [], inheritedStyles = [], inheritedAttribution = null) {
  const srsTag = version2 === "1.3.0" ? "CRS" : "SRS";
  const srsList = findChildrenElement(layerEl, srsTag).map(getElementText);
  const availableCrs = srsList.length > 0 ? srsList : inheritedSrs;
  const layerStyles = findChildrenElement(layerEl, "Style").map(
    parseLayerStyle
  );
  const styles = layerStyles.length > 0 ? layerStyles : inheritedStyles;
  function parseBBox(bboxEl) {
    const srs = getElementAttribute(bboxEl, srsTag);
    const attrs = hasInvertedCoordinates(srs) && version2 === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"];
    return attrs.map((name) => getElementAttribute(bboxEl, name));
  }
  const attributionEl = findChildElement(layerEl, "Attribution");
  const attribution = attributionEl !== null ? parseLayerAttribution(attributionEl) : inheritedAttribution;
  const children = findChildrenElement(layerEl, "Layer").map(
    (layer) => parseLayer(layer, version2, availableCrs, styles, attribution)
  );
  return {
    name: getElementText(findChildElement(layerEl, "Name")),
    title: getElementText(findChildElement(layerEl, "Title")),
    abstract: getElementText(findChildElement(layerEl, "Abstract")),
    availableCrs,
    styles,
    attribution,
    boundingBoxes: findChildrenElement(layerEl, "BoundingBox").reduce(
      (prev, bboxEl) => ({
        ...prev,
        [getElementAttribute(bboxEl, srsTag)]: parseBBox(bboxEl)
      }),
      {}
    ),
    ...children.length && { children }
  };
}
function parseLayerStyle(styleEl) {
  const legendUrl = getElementAttribute(
    findChildElement(findChildElement(styleEl, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: getElementText(findChildElement(styleEl, "Name")),
    title: getElementText(findChildElement(styleEl, "Title")),
    ...legendUrl && { legendUrl }
  };
}
function parseLayerAttribution(attributionEl) {
  const logoUrl = getElementAttribute(
    findChildElement(
      findChildElement(attributionEl, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  );
  const url = getElementAttribute(
    findChildElement(attributionEl, "OnlineResource"),
    "xlink:href"
  );
  const title = getElementText(findChildElement(attributionEl, "Title"));
  return {
    ...title && { title },
    ...url && { url },
    ...logoUrl && { logoUrl }
  };
}
function readVersionFromCapabilities(capabilitiesDoc) {
  return getRootElement(capabilitiesDoc).attributes["version"];
}
function readOutputFormatsFromCapabilities(capabilitiesDoc) {
  const version2 = readVersionFromCapabilities(capabilitiesDoc);
  let outputFormats;
  if (version2.startsWith("1.0")) {
    const getFeature = findChildElement(
      findChildElement(
        findChildElement(getRootElement(capabilitiesDoc), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    outputFormats = getChildrenElement(
      findChildElement(getFeature, "ResultFormat")
    ).map(getElementName);
  } else {
    const operations = findChildElement(
      getRootElement(capabilitiesDoc),
      "OperationsMetadata"
    );
    const getFeature = findChildrenElement(operations, "Operation").find(
      (el) => getElementAttribute(el, "name") === "GetFeature"
    );
    const parameter = findChildrenElement(getFeature, "Parameter").find(
      (el) => getElementAttribute(el, "name") === "outputFormat"
    );
    outputFormats = findChildrenElement(parameter, "Value", true).map(
      getElementText
    );
  }
  return outputFormats;
}
function readInfoFromCapabilities(capabilitiesDoc) {
  const version2 = readVersionFromCapabilities(capabilitiesDoc);
  const serviceTag = version2.startsWith("1.0") ? "Service" : "ServiceIdentification";
  const nameTag = version2.startsWith("1.0") ? "Name" : "ServiceType";
  const service = findChildElement(getRootElement(capabilitiesDoc), serviceTag);
  let keywords;
  if (version2.startsWith("1.0")) {
    keywords = getElementText(findChildElement(service, "Keywords")).split(",").map((keyword2) => keyword2.trim());
  } else {
    keywords = findChildrenElement(
      findChildElement(service, "Keywords"),
      "Keyword"
    ).map(getElementText);
  }
  return {
    title: getElementText(findChildElement(service, "Title")),
    name: getElementText(findChildElement(service, nameTag)),
    abstract: getElementText(findChildElement(service, "Abstract")),
    fees: getElementText(findChildElement(service, "Fees")),
    constraints: getElementText(findChildElement(service, "AccessConstraints")),
    keywords,
    outputFormats: readOutputFormatsFromCapabilities(capabilitiesDoc)
  };
}
function readFeatureTypesFromCapabilities(capabilitiesDoc) {
  const version2 = readVersionFromCapabilities(capabilitiesDoc);
  const outputFormats = readOutputFormatsFromCapabilities(capabilitiesDoc);
  const capability = findChildElement(
    getRootElement(capabilitiesDoc),
    "FeatureTypeList"
  );
  return findChildrenElement(capability, "FeatureType").map(
    (featureTypeEl) => parseFeatureType(featureTypeEl, version2, outputFormats)
  );
}
function parseFeatureType(featureTypeEl, serviceVersion, defaultOutputFormats) {
  const srsTag = serviceVersion.startsWith("2.") ? "CRS" : "SRS";
  const defaultSrsTag = serviceVersion.startsWith("1.0") ? "SRS" : `Default${srsTag}`;
  function parseBBox100() {
    const bboxEl = findChildElement(featureTypeEl, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((name) => getElementAttribute(bboxEl, name)).map(parseFloat);
  }
  function parseBBox() {
    const bboxEl = findChildElement(featureTypeEl, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((elName) => findChildElement(bboxEl, elName)).map((cornerEl) => getElementText(cornerEl).split(" ")).reduce((prev, curr) => [...prev, ...curr]).map(parseFloat);
  }
  const otherCrs = serviceVersion.startsWith("1.0") ? [] : findChildrenElement(featureTypeEl, `Other${srsTag}`).map(getElementText).map(simplifyEpsgUrn);
  const outputFormats = serviceVersion.startsWith("1.0") ? [] : findChildrenElement(
    findChildElement(featureTypeEl, "OutputFormats"),
    "Format"
  ).map(getElementText);
  return {
    name: getElementText(findChildElement(featureTypeEl, "Name")),
    title: getElementText(findChildElement(featureTypeEl, "Title")),
    abstract: getElementText(findChildElement(featureTypeEl, "Abstract")),
    defaultCrs: simplifyEpsgUrn(
      getElementText(findChildElement(featureTypeEl, defaultSrsTag))
    ),
    otherCrs,
    outputFormats: outputFormats.length > 0 ? outputFormats : defaultOutputFormats,
    latLonBoundingBox: serviceVersion.startsWith("1.0") ? parseBBox100() : parseBBox()
  };
}
function parseFeatureProps(getFeaturesDoc, featureTypeFull, serviceVersion) {
  const collection = getRootElement(getFeaturesDoc);
  let members;
  if (serviceVersion.startsWith("2.0")) {
    members = findChildrenElement(collection, "member").map(
      (parent) => getChildrenElement(parent)[0]
    );
  } else {
    const membersRoot = findChildElement(collection, "featureMembers");
    members = membersRoot ? getChildrenElement(membersRoot) : findChildrenElement(collection, "featureMember").map(
      (parent) => getChildrenElement(parent)[0]
    );
  }
  const idAttr = serviceVersion === "1.0.0" ? "fid" : "gml:id";
  function isElementProperty(propName) {
    return propName in featureTypeFull.properties;
  }
  function parseElementPropertyValue(propName, valueAsString) {
    const type = featureTypeFull.properties[propName];
    switch (type) {
      case "integer":
        return parseInt(valueAsString);
      case "float":
        return parseFloat(valueAsString);
      case "boolean":
        return valueAsString === "true";
      default:
        return valueAsString;
    }
  }
  function getProperties(memberEl) {
    return getChildrenElement(memberEl).filter((el) => isElementProperty(stripNamespace(getElementName(el)))).reduce((prev, curr) => {
      const propName = stripNamespace(getElementName(curr));
      return {
        ...prev,
        [propName]: parseElementPropertyValue(propName, getElementText(curr))
      };
    }, {});
  }
  return members.map((el) => ({
    id: getElementAttribute(el, idAttr),
    properties: getProperties(el)
  }));
}
function computeFeaturePropsDetails(featuresWithProps) {
  return featuresWithProps.reduce((prev, curr) => {
    for (const propName in curr.properties) {
      const propValue = curr.properties[propName];
      if (!(propName in prev)) {
        prev[propName] = { uniqueValues: [] };
      }
      const uniqueValue = prev[propName].uniqueValues.find(
        (v2) => v2.value === propValue
      );
      if (uniqueValue)
        uniqueValue.count++;
      else
        prev[propName].uniqueValues.push({ value: propValue, count: 1 });
    }
    return prev;
  }, {});
}
addTaskHandler(
  "parseWmsCapabilities",
  self,
  ({ url }) => queryXmlDocument(url).then((xmlDoc) => ({
    info: readInfoFromCapabilities$1(xmlDoc),
    layers: readLayersFromCapabilities(xmlDoc),
    version: readVersionFromCapabilities$1(xmlDoc)
  }))
);
addTaskHandler(
  "parseWfsCapabilities",
  self,
  ({ url }) => queryXmlDocument(url).then((xmlDoc) => ({
    info: readInfoFromCapabilities(xmlDoc),
    featureTypes: readFeatureTypesFromCapabilities(xmlDoc),
    version: readVersionFromCapabilities(xmlDoc)
  }))
);
addTaskHandler(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url, serviceVersion, featureTypeFull }) => {
    const getFeatureUrl = generateGetFeatureUrl(
      url,
      serviceVersion,
      featureTypeFull.name,
      void 0,
      void 0,
      Object.keys(featureTypeFull.properties)
    );
    return queryXmlDocument(getFeatureUrl).then((getFeatureDoc) => ({
      props: computeFeaturePropsDetails(
        parseFeatureProps(getFeatureDoc, featureTypeFull, serviceVersion)
      )
    }));
  }
);
const predefinedWmsFixture = () => {
  return [
    {
      url: "http://wmts1.geoportail.lu/opendata/service",
      label: "Open Data Webservices WMS"
    },
    {
      url: "http://ows.terrestris.de/osm-gray/service",
      label: "OpenStreetMap by Terrestris (Grey)"
    },
    {
      url: "http://ows.terrestris.de/osm/service",
      label: "OpenStreetMap by Terrestris (Color)"
    }
  ];
};
class WmtsEndpoint {
  constructor(url) {
    __publicField(this, "capabilitiesPromise");
    __publicField(this, "serviceInfo");
    __publicField(this, "layers");
    const parser = new WMTSCapabilities();
    let separator = "&";
    if (url.indexOf("?") === -1) {
      separator = "?";
    }
    if (url.indexOf("Capabilities") === -1) {
      url = url + separator + "SERVICE=WMTS&REQUEST=GetCapabilities";
    }
    this.capabilitiesPromise = fetch(url).then((response) => {
      return response.text();
    }).then((text2) => {
      var _a;
      const result = parser.read(text2);
      this.serviceInfo = this.mapServiceInfo(result.ServiceIdentification);
      this.layers = this.mapToRemoteLayers((_a = result.Contents) == null ? void 0 : _a.Layer);
    });
  }
  mapToRemoteLayers(layers) {
    return [
      {
        type: REMOTE_SERVICE_TYPE.WMTS,
        children: layers.map(
          (layer) => ({
            type: REMOTE_SERVICE_TYPE.WMTS,
            abstract: layer.Abstract,
            format: layer.Format,
            name: layer.Identifier,
            title: layer.Title,
            tileMatrixSetLink: layer.TileMatrixSetLink,
            wgs84BoundingBox: layer.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(serviceInfo) {
    return {
      type: REMOTE_SERVICE_TYPE.WMTS,
      title: serviceInfo.Title,
      abstract: serviceInfo.Abstract,
      fees: serviceInfo.Fees,
      constraints: serviceInfo.AccessConstraints,
      serviceTypeVersion: serviceInfo.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(name) {
    return this.layers[0].children.filter((layer) => layer.name === name)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class RemoteLayersService {
  async getRemoteEndpoint(url) {
    let wmtsEndpoint;
    const wmsEndpoint = await this.getWmsEndpoint(url).isReady().catch(async () => {
      wmtsEndpoint = await this.getWmtsEndpoint(url).isReady();
    });
    return wmsEndpoint || wmtsEndpoint;
  }
  getWmsEndpoint(url) {
    return new WmsEndpoint(this.getProxyfiedUrl(url));
  }
  getWmtsEndpoint(url) {
    return new WmtsEndpoint(this.getProxyfiedUrl(url));
  }
  getProxyfiedUrl(url) {
    if (url.indexOf("httpsproxy") > 0) {
      return url;
    }
    {
      return remoteProxyWms + "?url=" + encodeURIComponent(url);
    }
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((resolve2) => resolve2(predefinedWmsFixture()));
  }
  isRemoteLayer(layerId) {
    return typeof layerId === "string" && (layerId.indexOf(REMOTE_SERVICE_TYPE.WMS) === 0 || layerId.indexOf(REMOTE_SERVICE_TYPE.WMTS) === 0);
  }
}
const remoteLayersService = new RemoteLayersService();
function sortLayerTreeNoChildrenFirst(a, b) {
  var _a, _b;
  if (a.children && !b.children || ((_a = b.children) == null ? void 0 : _a.length) === 0) {
    return 1;
  }
  if (b.children && !a.children || ((_b = a.children) == null ? void 0 : _b.length) === 0) {
    return -1;
  }
  return 0;
}
function remoteLayersToLayerTreeMapper(node, urlWms, depth = 0) {
  const { name = "", type = REMOTE_SERVICE_TYPE.WMS, children } = node;
  const id = `${type}||${urlWms}||${name}`.split("-").join("%2D");
  const mapStore = useMapStore();
  return {
    id,
    name,
    depth,
    children: children == null ? void 0 : children.sort(sortLayerTreeNoChildrenFirst).map((child) => remoteLayersToLayerTreeMapper(child, urlWms, depth + 1)),
    checked: mapStore.hasLayer(id),
    expanded: false
  };
}
function remoteLayerIdtoLayer(layerId) {
  const id = decodeURIComponent(layerId);
  const [type, url, name] = id.split("||");
  return remoteLayerToLayer({
    id,
    url: remoteLayersService.getProxyfiedUrl(url),
    remoteLayer: { name, type }
  });
}
function remoteLayerToLayer({
  id,
  url,
  remoteLayer
}) {
  const { name = "", type = REMOTE_SERVICE_TYPE.WMS } = remoteLayer;
  return {
    id,
    name,
    layers: name,
    url,
    type,
    imageType: LayerImageType.PNG
  };
}
const _hoisted_1$k = { class: "relative text-center" };
const _hoisted_2$h = ["placeholder", "value"];
const _hoisted_3$f = {
  key: 0,
  class: "text-center"
};
const _hoisted_4$d = { class: "lux-label" };
const _hoisted_5$b = {
  key: 1,
  class: "text-center"
};
const _hoisted_6$7 = { class: "lux-label" };
const _hoisted_7$4 = {
  key: 2,
  class: "text-center"
};
const _hoisted_8$4 = /* @__PURE__ */ createBaseVNode("div", { class: "fa fa-refresh fa-spin" }, null, -1);
const _hoisted_9$2 = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "remote-layers",
  setup(__props) {
    const { t } = useTranslation();
    const mapStore = useMapStore();
    const layers = useLayers();
    const wmsLayers = shallowRef([]);
    const layerTree = shallowRef();
    const { remoteLayersOpen } = storeToRefs(useAppStore());
    const { setRemoteLayersOpen } = useAppStore();
    let isLoading = false;
    let inputRemoteUrl;
    let currentRemoteUrl;
    let currentRemoteEndpoint;
    watchEffect(updateLayerTree);
    function updateLayerTree() {
      layerTree.value = layerTree.value ? layerTreeService.updateLayers(
        layerTree.value,
        mapStore.layers
      ) : void 0;
    }
    remoteLayersService.fetchRemoteWmsEndpoint().then((wmsLayersFetch) => {
      wmsLayers.value = wmsLayersFetch.map(({ url, label }) => ({
        label,
        value: url
      }));
    });
    async function getRemoteEndpoint(url) {
      isLoading = true;
      currentRemoteEndpoint = await remoteLayersService.getRemoteEndpoint(url).catch(() => alert(t("Impossible de contacter ce WMS", { ns: "client" })));
      currentRemoteUrl = url;
      isLoading = false;
    }
    async function getRemoteLayers() {
      const remoteEndpoint = currentRemoteEndpoint;
      const remoteLayers = remoteEndpoint == null ? void 0 : remoteEndpoint.getLayers();
      if (remoteLayers && remoteLayers[0]) {
        const treeLayers = remoteLayersToLayerTreeMapper(
          remoteLayers[0],
          currentRemoteUrl
        );
        layerTree.value = layerTreeService.updateLayers(treeLayers, mapStore.layers);
      }
    }
    async function onChangeRemoteEndpoint(url) {
      currentRemoteUrl = inputRemoteUrl = url;
      await getRemoteEndpoint(currentRemoteUrl);
      getRemoteLayers();
    }
    function onChangeRemoteUrl(event) {
      inputRemoteUrl = event.target.value;
    }
    async function onClickGetLayers() {
      await getRemoteEndpoint(inputRemoteUrl);
      getRemoteLayers();
    }
    function toggleParent(node) {
      layerTree.value = layerTreeService.toggleNode(
        node.id,
        layerTree.value,
        "expanded"
      );
    }
    function toggleLayer(node) {
      const { id, name } = node;
      const remoteEndpoint = currentRemoteEndpoint;
      if (node.checked === true) {
        mapStore.removeLayers(id);
      } else {
        const remoteLayer = remoteEndpoint == null ? void 0 : remoteEndpoint.getLayerByName(name);
        if (remoteLayer) {
          const layer = layers.initLayer(
            remoteLayerToLayer({
              id,
              url: remoteLayersService.getProxyfiedUrl(currentRemoteUrl),
              remoteLayer
            })
          );
          mapStore.addLayers(layer);
        }
      }
    }
    return (_ctx, _cache) => {
      return unref(remoteLayersOpen) ? (openBlock(), createBlock(ModalDialog, {
        key: 0,
        title: unref(t)("Add external data", { ns: "client" }),
        onClose: _cache[0] || (_cache[0] = ($event) => unref(setRemoteLayersOpen)(false))
      }, {
        content: withCtx(() => {
          var _a, _b;
          return [
            createBaseVNode("div", _hoisted_1$k, [
              createVNode(DropdownList, {
                class: "lux-remote-services-dropdown",
                options: unref(wmsLayers),
                placeholder: unref(t)("Predefined wms", { ns: "client" }),
                onChange: onChangeRemoteEndpoint
              }, null, 8, ["options", "placeholder"]),
              createBaseVNode("input", {
                class: "lux-input w-[300px]",
                type: "url",
                placeholder: unref(t)("Choose or write a WMS url", {
                  ns: "client"
                }),
                value: unref(currentRemoteUrl) || "",
                onChange: onChangeRemoteUrl
              }, null, 40, _hoisted_2$h),
              createBaseVNode("button", {
                type: "button",
                class: "lux-btn",
                onClick: onClickGetLayers
              }, toDisplayString(unref(t)("Get the layers", { ns: "client" })), 1)
            ]),
            !unref(isLoading) && unref(currentRemoteEndpoint) ? (openBlock(), createElementBlock("div", _hoisted_3$f, [
              createBaseVNode("span", _hoisted_4$d, toDisplayString(unref(t)("Description du service :", {
                ns: "client"
              })), 1),
              createTextVNode(" " + toDisplayString((_a = unref(currentRemoteEndpoint).getServiceInfo()) == null ? void 0 : _a.abstract), 1)
            ])) : createCommentVNode("v-if", true),
            !unref(isLoading) && unref(currentRemoteEndpoint) ? (openBlock(), createElementBlock("div", _hoisted_5$b, [
              createBaseVNode("span", _hoisted_6$7, toDisplayString(unref(t)("Access constraints :", {
                ns: "client"
              })), 1),
              createTextVNode(" " + toDisplayString((_b = unref(currentRemoteEndpoint).getServiceInfo()) == null ? void 0 : _b.constraints), 1)
            ])) : createCommentVNode("v-if", true),
            unref(isLoading) ? (openBlock(), createElementBlock("div", _hoisted_7$4, [
              _hoisted_8$4,
              createBaseVNode("span", null, toDisplayString(unref(t)("Chargement des informations", {
                ns: "client"
              })), 1)
            ])) : createCommentVNode("v-if", true),
            !unref(isLoading) ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
              unref(layerTree) ? (openBlock(), createBlock(LayerTreeNode, {
                key: 0,
                class: "block p-[10px] mb-[11px]",
                node: unref(layerTree),
                onToggleParent: toggleParent,
                onToggleLayer: toggleLayer
              }, null, 8, ["node"])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ];
        }),
        _: 1
      }, 8, ["title"])) : createCommentVNode("v-if", true);
    };
  }
});
const RemoteLayers = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/remote-layers/remote-layers.vue"]]);
function formatDate(dateString, language = "fr-FR") {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat(language).format(date);
}
const _hoisted_1$j = { class: "font-bold" };
const _hoisted_2$g = { class: "col-span-2" };
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: true },
    value: { type: String, required: true }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("span", _hoisted_1$j, toDisplayString(props.label), 1),
        createBaseVNode("span", _hoisted_2$g, toDisplayString(props.value), 1)
      ], 64);
    };
  }
});
const LayerMetadataItem = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-metadata/layer-metadata-item.vue"]]);
function isoLang2To3(code) {
  const lang = {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  };
  return lang[code.toLowerCase()];
}
function stringToHtml(str) {
  const parser = new DOMParser();
  const doc2 = parser.parseFromString(str, "text/html");
  return doc2.body;
}
function getMetadataLinks(link) {
  const links = [];
  function splitLink(link2) {
    const currentLink = link2.split("|");
    if (currentLink[3] === "WWW:LINK-1.0-http--link" && links.indexOf(currentLink[2]) === -1) {
      links.push(currentLink[2]);
    }
  }
  if (Array.isArray(link)) {
    link.forEach(splitLink, link);
  } else {
    splitLink(link);
  }
  return links;
}
function getResponsibleParty(responsibleParty) {
  const pocs = Array.isArray(responsibleParty) ? responsibleParty : [responsibleParty];
  const poc = pocs.filter((poc2) => poc2.split("|")[1] === "metadata");
  return {
    organisaton: poc[0].split("|")[2],
    name: poc[0].split("|")[5],
    unknown: poc[0].split("|")[6],
    address: poc[0].split("|")[7],
    email: poc[0].split("|")[4]
  };
}
class OwsHelper {
}
class WmsHelper extends OwsHelper {
  async getMetadata(serviceType, url, layerName) {
    console.assert(serviceType === REMOTE_SERVICE_TYPE.WMS);
    const wmsEndpoint = remoteLayersService.getWmsEndpoint(url);
    await wmsEndpoint.isReady();
    const service = wmsEndpoint == null ? void 0 : wmsEndpoint.getServiceInfo();
    const layer = wmsEndpoint == null ? void 0 : wmsEndpoint.getLayerByName(layerName);
    return {
      title: layer.title,
      description: layer.abstract,
      keywords: service.keywords,
      accessConstraints: service.constraints,
      serviceDescription: service.abstract
    };
  }
}
const wmsHelper = new WmsHelper();
class WmtsHelper extends OwsHelper {
  async getMetadata(serviceType, url, layerName) {
    console.assert(serviceType === REMOTE_SERVICE_TYPE.WMTS);
    const wmtsEndpoint = remoteLayersService.getWmtsEndpoint(url);
    await wmtsEndpoint.isReady();
    const service = wmtsEndpoint == null ? void 0 : wmtsEndpoint.getServiceInfo();
    const layer = wmtsEndpoint == null ? void 0 : wmtsEndpoint.getLayerByName(layerName);
    return {
      title: layer.title,
      description: layer.abstract,
      accessConstraints: service.constraints,
      serviceDescription: service.abstract
    };
  }
}
const wmtsHelper = new WmtsHelper();
class RemoteMetadataHelper {
  async getMetadata(serviceType, url, layerName) {
    if (serviceType === REMOTE_SERVICE_TYPE.WMS) {
      return wmsHelper.getMetadata(serviceType, url, layerName);
    } else if (serviceType === REMOTE_SERVICE_TYPE.WMTS) {
      return wmtsHelper.getMetadata(serviceType, url, layerName);
    } else {
      throw new Error(`Unsupported service type: ${serviceType}`);
    }
  }
}
const remoteMetadataHelper = new RemoteMetadataHelper();
class LayerMetadataService {
  constructor() {
    __publicField(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    __publicField(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    __publicField(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(id, currentLanguage) {
    const layer = useThemes().findBgLayerById(+id) || useThemes().findById(+id);
    if (layer) {
      const localMetadata = layer.metadata;
      const metadataId = localMetadata == null ? void 0 : localMetadata.metadata_id;
      const metadata = metadataId && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        metadataId,
        currentLanguage
      );
      const title = layer.name;
      const legendName = (localMetadata == null ? void 0 : localMetadata.legend_name) || "";
      const layerId = layer == null ? void 0 : layer.id;
      const legendHtml = legendName && await this.getLegendHtml(
        this.legendBaseUrl,
        legendName,
        layerId,
        currentLanguage
      );
      return {
        ...metadata,
        title,
        hasLegend: !!legendHtml,
        ...legendHtml && { legendHtml }
      };
    } else {
      const [serviceType, url, layerName] = String(id).split("%2D").join("-").split("||");
      return remoteMetadataHelper.getMetadata(
        serviceType,
        url,
        layerName
      );
    }
  }
  getLocalMetadata(baseUrl, metadataUid, language) {
    return fetch(`${baseUrl}?lang=${language}&uid=${metadataUid}`).then(async (response) => {
      const metadata = (await response.json()).metadata;
      return {
        name: metadata.title,
        serviceDescription: metadata.serviceDescription,
        description: metadata.abstract,
        legalConstraints: metadata.legalConstraints,
        link: getMetadataLinks(metadata.link),
        revisionDate: metadata.revisionDate,
        keyword: metadata.keyword,
        responsibleParty: metadata.responsibleParty ? getResponsibleParty(metadata.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${isoLang2To3(
          language
        )}/catalog.search#/metadata/${metadataUid}`,
        isError: false
      };
    }).catch(() => {
      return { isError: true };
    });
  }
  getLegendHtml(legendBaseUrl, legendName, layerId, language) {
    const queryParams = {
      lang: language,
      ...legendName && { name: legendName },
      ...layerId && { id: layerId.toString() }
    };
    if (queryParams.name && queryParams.lang) {
      if (window.devicePixelRatio > 1) {
        queryParams.dpi = (window.devicePixelRatio * 96).toString();
      }
      const legendUrl = `${legendBaseUrl}?${new URLSearchParams(
        queryParams
      ).toString()}`;
      return fetch(legendUrl).then(async (response) => {
        if (response.status >= 400 && response.status < 600) {
          throw new Error("Server responded with error code");
        }
        const legendString = await response.text();
        return legendString ? stringToHtml(legendString) : void 0;
      }).catch(() => {
        return void 0;
      });
    }
  }
}
const layerMetadataService = new LayerMetadataService();
const _hoisted_1$i = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" };
const _hoisted_2$f = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
};
const _hoisted_3$e = { class: "font-bold" };
const _hoisted_4$c = { class: "col-span-2" };
const _hoisted_5$a = ["title"];
const _hoisted_6$6 = ["title"];
const _hoisted_7$3 = {
  key: 4,
  class: "col-span-3"
};
const _hoisted_8$3 = { class: "font-bold" };
const _hoisted_9$1 = { class: "col-span-2" };
const _hoisted_10$1 = ["href"];
const _hoisted_11$1 = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
};
const _hoisted_12 = { class: "font-bold" };
const _hoisted_13 = { class: "col-span-2" };
const _hoisted_14 = { key: 0 };
const _hoisted_15 = { key: 1 };
const _hoisted_16 = { key: 2 };
const _hoisted_17 = { key: 3 };
const _hoisted_18 = { key: 4 };
const _hoisted_19 = ["href"];
const _hoisted_20 = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
};
const _hoisted_21 = { class: "font-bold" };
const _hoisted_22 = { class: "col-span-2" };
const _hoisted_23 = ["href"];
const _hoisted_24 = {
  key: 9,
  class: "col-span-3"
};
const _hoisted_25 = { key: 10 };
const _hoisted_26 = { class: "text-xl" };
const _hoisted_27 = {
  key: 11,
  class: "col-span-3"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "layer-metadata",
  setup(__props) {
    const metadataStore = useMetadataStore();
    const { metadataId } = storeToRefs(metadataStore);
    const { t, i18next } = useTranslation();
    const layerMetadata = ref();
    const displayFullDescription = ref(true);
    const MAX_DESCRIPTION_LENGTH = 220;
    watch(metadataId, async (id) => {
      var _a, _b;
      layerMetadata.value = id ? await layerMetadataService.getLayerMetadata(id, i18next.language) : void 0;
      displayFullDescription.value = (((_b = (_a = layerMetadata.value) == null ? void 0 : _a.description) == null ? void 0 : _b.length) || 0) < MAX_DESCRIPTION_LENGTH;
    });
    onMounted(() => {
      i18next.on("languageChanged", async () => {
        if (metadataId.value) {
          layerMetadata.value = await layerMetadataService.getLayerMetadata(
            metadataId.value,
            i18next.language
          );
        }
      });
    });
    const description = computed(
      () => {
        var _a, _b, _c;
        return displayFullDescription.value ? (_a = layerMetadata.value) == null ? void 0 : _a.description : (_c = (_b = layerMetadata.value) == null ? void 0 : _b.description) == null ? void 0 : _c.slice(0, MAX_DESCRIPTION_LENGTH);
      }
    );
    function showFullDescription() {
      displayFullDescription.value = true;
    }
    function hideFullDescription() {
      displayFullDescription.value = false;
    }
    function closeLayerMetadata() {
      metadataStore.clearMetadataId();
    }
    return (_ctx, _cache) => {
      const _directive_dompurify_html = resolveDirective("dompurify-html");
      return layerMetadata.value ? (openBlock(), createBlock(ModalDialog, {
        key: 0,
        footer: false,
        "max-height": true,
        title: unref(t)(`${layerMetadata.value.title}`, { ns: "client" }),
        onClose: closeLayerMetadata
      }, {
        content: withCtx(() => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
          return [
            createBaseVNode("div", _hoisted_1$i, [
              layerMetadata.value.name ? (openBlock(), createBlock(LayerMetadataItem, {
                key: 0,
                label: unref(t)("Name"),
                value: layerMetadata.value.name
              }, null, 8, ["label", "value"])) : createCommentVNode("v-if", true),
              layerMetadata.value.serviceDescription ? (openBlock(), createBlock(LayerMetadataItem, {
                key: 1,
                label: unref(t)("Description du Service"),
                value: layerMetadata.value.serviceDescription
              }, null, 8, ["label", "value"])) : createCommentVNode("v-if", true),
              layerMetadata.value.description ? (openBlock(), createElementBlock("div", _hoisted_2$f, [
                createBaseVNode("span", _hoisted_3$e, toDisplayString(unref(t)("Description")), 1),
                createBaseVNode("span", _hoisted_4$c, [
                  withDirectives(createBaseVNode("span", null, null, 512), [
                    [_directive_dompurify_html, unref(description)]
                  ]),
                  !displayFullDescription.value ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    title: unref(t)("Display full description", {
                      ns: "client"
                    }),
                    onClick: showFullDescription,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, _hoisted_5$a)) : createCommentVNode("v-if", true),
                  displayFullDescription.value && (((_a = unref(description)) == null ? void 0 : _a.length) || 0) > MAX_DESCRIPTION_LENGTH ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    title: unref(t)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: hideFullDescription,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, _hoisted_6$6)) : createCommentVNode("v-if", true)
                ])
              ])) : createCommentVNode("v-if", true),
              layerMetadata.value.legalConstraints ? (openBlock(), createBlock(LayerMetadataItem, {
                key: 3,
                label: unref(t)(`Contrainte d'utilisation`),
                value: layerMetadata.value.legalConstraints
              }, null, 8, ["label", "value"])) : createCommentVNode("v-if", true),
              ((_b = layerMetadata.value.link) == null ? void 0 : _b.length) !== 0 ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(layerMetadata.value.link, (link) => {
                  return openBlock(), createElementBlock("div", {
                    class: "grid gap-2 grid-cols-3",
                    key: link
                  }, [
                    createBaseVNode("span", _hoisted_8$3, toDisplayString(unref(t)("Url vers la resource")), 1),
                    createBaseVNode("span", _hoisted_9$1, [
                      createBaseVNode("a", {
                        class: "text-secondary hover:underline",
                        target: "_blank",
                        href: link
                      }, toDisplayString(link), 9, _hoisted_10$1)
                    ])
                  ]);
                }), 128))
              ])) : createCommentVNode("v-if", true),
              layerMetadata.value.revisionDate ? (openBlock(), createBlock(LayerMetadataItem, {
                key: 5,
                label: unref(t)("Revision date"),
                value: unref(formatDate)(layerMetadata.value.revisionDate, unref(i18next).language)
              }, null, 8, ["label", "value"])) : createCommentVNode("v-if", true),
              layerMetadata.value.keyword ? (openBlock(), createBlock(LayerMetadataItem, {
                key: 6,
                label: unref(t)("Keywords"),
                value: (_c = layerMetadata.value.keyword) == null ? void 0 : _c.join(",")
              }, null, 8, ["label", "value"])) : createCommentVNode("v-if", true),
              layerMetadata.value.responsibleParty ? (openBlock(), createElementBlock("div", _hoisted_11$1, [
                createBaseVNode("div", _hoisted_12, toDisplayString(unref(t)("Contact")), 1),
                createBaseVNode("div", _hoisted_13, [
                  ((_d = layerMetadata.value.responsibleParty) == null ? void 0 : _d.organisaton) ? (openBlock(), createElementBlock("p", _hoisted_14, toDisplayString((_e = layerMetadata.value.responsibleParty) == null ? void 0 : _e.organisaton), 1)) : createCommentVNode("v-if", true),
                  ((_f = layerMetadata.value.responsibleParty) == null ? void 0 : _f.name) ? (openBlock(), createElementBlock("p", _hoisted_15, toDisplayString((_g = layerMetadata.value.responsibleParty) == null ? void 0 : _g.name), 1)) : createCommentVNode("v-if", true),
                  ((_h = layerMetadata.value.responsibleParty) == null ? void 0 : _h.unknown) ? (openBlock(), createElementBlock("p", _hoisted_16, toDisplayString((_i = layerMetadata.value.responsibleParty) == null ? void 0 : _i.unknown), 1)) : createCommentVNode("v-if", true),
                  ((_j = layerMetadata.value.responsibleParty) == null ? void 0 : _j.address) ? (openBlock(), createElementBlock("p", _hoisted_17, toDisplayString((_k = layerMetadata.value.responsibleParty) == null ? void 0 : _k.address), 1)) : createCommentVNode("v-if", true),
                  ((_l = layerMetadata.value.responsibleParty) == null ? void 0 : _l.email) ? (openBlock(), createElementBlock("p", _hoisted_18, [
                    createBaseVNode("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((_m = layerMetadata.value.responsibleParty) == null ? void 0 : _m.email)
                    }, toDisplayString((_n = layerMetadata.value.responsibleParty) == null ? void 0 : _n.email), 9, _hoisted_19)
                  ])) : createCommentVNode("v-if", true)
                ])
              ])) : createCommentVNode("v-if", true),
              layerMetadata.value.metadataLink ? (openBlock(), createElementBlock("div", _hoisted_20, [
                createBaseVNode("span", _hoisted_21, toDisplayString(unref(t)("Link to the metadata")), 1),
                createBaseVNode("span", _hoisted_22, [
                  createBaseVNode("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: layerMetadata.value.metadataLink
                  }, toDisplayString(unref(t)("link")), 9, _hoisted_23)
                ])
              ])) : createCommentVNode("v-if", true),
              layerMetadata.value.isError ? (openBlock(), createElementBlock("div", _hoisted_24, toDisplayString(unref(t)("The metadata is right now not available")), 1)) : createCommentVNode("v-if", true),
              layerMetadata.value.legendHtml ? (openBlock(), createElementBlock("div", _hoisted_25, [
                createBaseVNode("h4", _hoisted_26, toDisplayString(unref(t)("Legend")), 1),
                withDirectives(createBaseVNode("span", null, null, 512), [
                  [_directive_dompurify_html, (_o = layerMetadata.value.legendHtml) == null ? void 0 : _o.innerHTML]
                ])
              ])) : createCommentVNode("v-if", true),
              !layerMetadata.value.hasLegend ? (openBlock(), createElementBlock("div", _hoisted_27, toDisplayString(unref(t)("The legend is not available for this layer")), 1)) : createCommentVNode("v-if", true)
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : createCommentVNode("v-if", true);
    };
  }
});
const LayerMetadata = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-metadata/layer-metadata.vue"]]);
const _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class StatePersistorLangService {
  bootstrap() {
    this.restore();
    let stop;
    stop = watchEffect(() => {
      this.persist();
      stop && stop();
    });
  }
  persist() {
    const appStore = useAppStore();
    const { lang } = storeToRefs(appStore);
    watch(
      lang,
      (value, oldValue) => {
        if (oldValue !== value) {
          storageHelper.setValue(SP_KEY_LANG, value);
          const getHTMLTag = document.documentElement;
          getHTMLTag.setAttribute("lang", value);
        }
      },
      { immediate: true }
    );
  }
  restore() {
    const lang = storageHelper.getValue(SP_KEY_LANG);
    if (lang) {
      const { setLang } = useAppStore();
      const { i18next } = useTranslation();
      i18next.changeLanguage(lang);
      setLang(lang);
    }
  }
}
const statePersistorLangService = new StatePersistorLangService();
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "language-selector",
  setup(__props) {
    const { i18next, t } = useTranslation();
    const { setLang } = useAppStore();
    const { lang } = storeToRefs(useAppStore());
    const availableLanguages = computed(
      () => ["en", "de", "fr", "lb"].map((lang2) => ({
        label: t(lang2),
        value: lang2,
        ariaLabel: t(`Changer de langue : {{lang}}`, { lang: lang2 })
      }))
    );
    const placeholder = t("Changer de langue");
    statePersistorLangService.bootstrap();
    function changeLanguages(lang2) {
      i18next.changeLanguage(lang2);
      setLang(lang2);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(DropdownList, {
          class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
          options: unref(availableLanguages),
          placeholder: unref(placeholder),
          modelValue: unref(lang),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(lang) ? lang.value = $event : null),
          onChange: changeLanguages
        }, null, 8, ["options", "placeholder", "modelValue"])
      ]);
    };
  }
});
const LanguageSelector = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/nav-bars/language-selector.vue"]]);
class ThemeSelectorService {
  setCurrentThemeColors(themeName) {
    const root = document.querySelector(":root");
    const colors = ["primary", "secondary", "tertiary"];
    colors.forEach((colorTone) => {
      const color = getComputedStyle(root).getPropertyValue(
        `--${themeName}-${colorTone}`
      );
      root.style.setProperty(`--color-${colorTone}`, color);
    });
  }
}
const themeSelectorService = new ThemeSelectorService();
const _hoisted_1$h = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" };
const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ createBaseVNode("img", { src: _imports_0 })
], -1);
const _hoisted_3$d = /* @__PURE__ */ createBaseVNode("div", { class: "grow text-center" }, "search", -1);
const _hoisted_4$b = { class: "h-full flex" };
const _hoisted_5$9 = { class: "hidden lg:inline-block" };
const _hoisted_6$5 = { class: "border-l-[1px] border-stone-300 h-full" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "header-bar",
  setup(__props) {
    const { t } = useTranslation();
    const appStore = useAppStore();
    const { layersOpen, myLayersTabOpen, themeGridOpen } = storeToRefs(appStore);
    const { setLayersOpen, setMyLayersTabOpen, setThemeGridOpen } = appStore;
    const themeStore = useThemeStore();
    const { theme } = storeToRefs(themeStore);
    watch(
      theme,
      (theme2) => {
        if (theme2) {
          themeSelectorService.setCurrentThemeColors(theme2.name);
        }
      },
      { immediate: true }
    );
    function onClick() {
      if (!layersOpen.value) {
        setLayersOpen(true);
        myLayersTabOpen.value && setMyLayersTabOpen(false);
        setThemeGridOpen(true);
      } else if (layersOpen.value) {
        if (themeGridOpen.value) {
          setLayersOpen(false);
        } else {
          myLayersTabOpen.value && setMyLayersTabOpen(false);
          setThemeGridOpen(true);
        }
      }
    }
    return (_ctx, _cache) => {
      var _a, _b;
      return openBlock(), createElementBlock("header", _hoisted_1$h, [
        _hoisted_2$e,
        _hoisted_3$d,
        createBaseVNode("div", null, [
          createBaseVNode("ul", _hoisted_4$b, [
            createBaseVNode("li", null, [
              createBaseVNode("button", {
                class: normalizeClass(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(_a = unref(theme)) == null ? void 0 : _a.name}`]),
                onClick
              }, [
                createBaseVNode("span", _hoisted_5$9, toDisplayString(unref(t)(`${(_b = unref(theme)) == null ? void 0 : _b.name}`)), 1)
              ], 2)
            ]),
            createBaseVNode("li", _hoisted_6$5, [
              createVNode(LanguageSelector, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
});
const HeaderBar = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/header/header-bar.vue"]]);
const _hoisted_1$g = { class: "block text-[13px] sm:text-base uppercase" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "button-icon",
  props: {
    label: { type: String, required: true },
    icon: { type: String, required: true },
    active: { type: Boolean, required: false }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", props.active ? "bg-primary text-white" : ""])
      }, [
        createBaseVNode("span", {
          class: normalizeClass(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", props.active ? "lux-close-cross" : `after:content-${props.icon}`])
        }, null, 2),
        createBaseVNode("span", _hoisted_1$g, toDisplayString(props.label), 1)
      ], 2);
    };
  }
});
const ButtonIcon = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/footer/button-icon.vue"]]);
const _hoisted_1$f = ["href"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "button-link",
  props: {
    label: { type: String, required: true },
    link: { type: String, required: true }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("a", {
        class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
        href: `${props.link}`,
        target: "_blank"
      }, toDisplayString(_ctx.$props.label), 9, _hoisted_1$f);
    };
  }
});
const ButtonLink = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/footer/button-link.vue"]]);
const _hoisted_1$e = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" };
const _hoisted_2$d = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" };
const _hoisted_3$c = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" };
const _hoisted_4$a = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "footer-bar",
  setup(__props) {
    const { t, i18next } = useTranslation();
    const { setLayersOpen } = useAppStore();
    const { layersOpen } = storeToRefs(useAppStore());
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("footer", _hoisted_1$e, [
        createCommentVNode(" left buttons "),
        createBaseVNode("ul", _hoisted_2$d, [
          createBaseVNode("li", null, [
            createVNode(ButtonIcon, {
              label: unref(t)("Layers", { ns: "client" }),
              icon: "layers",
              active: unref(layersOpen),
              onClick: _cache[0] || (_cache[0] = () => unref(setLayersOpen)(!unref(layersOpen)))
            }, null, 8, ["label", "active"])
          ]),
          createCommentVNode('TODOs in each button when implemented\n        - remove class="text-gray-300"\n        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)\n      '),
          createBaseVNode("li", null, [
            createVNode(ButtonIcon, {
              class: "text-gray-300",
              label: unref(t)("My Maps", { ns: "client" }),
              icon: "mymaps"
            }, null, 8, ["label"])
          ]),
          createBaseVNode("li", null, [
            createVNode(ButtonIcon, {
              class: "text-gray-300",
              label: unref(t)("Infos", { ns: "client" }),
              icon: "infos"
            }, null, 8, ["label"])
          ]),
          createBaseVNode("li", null, [
            createVNode(ButtonIcon, {
              class: "text-gray-300",
              label: unref(t)("Legends", { ns: "client" }),
              icon: "legends"
            }, null, 8, ["label"])
          ]),
          createBaseVNode("li", null, [
            createVNode(ButtonIcon, {
              class: "text-gray-300",
              label: unref(t)("Routing", { ns: "client" }),
              icon: "routing"
            }, null, 8, ["label"])
          ])
        ]),
        createCommentVNode(" center buttons "),
        createBaseVNode("div", _hoisted_3$c, [
          createVNode(ButtonIcon, {
            class: "text-gray-300",
            label: unref(t)("Dessin", { ns: "client" }),
            icon: "draw"
          }, null, 8, ["label"]),
          createVNode(ButtonIcon, {
            class: "text-gray-300 hidden sm:block",
            label: unref(t)("Mesurer", { ns: "client" }),
            icon: "measure"
          }, null, 8, ["label"]),
          createVNode(ButtonIcon, {
            class: "text-gray-300 hidden sm:block",
            label: unref(t)("Imprimer", { ns: "client" }),
            icon: "print"
          }, null, 8, ["label"]),
          createVNode(ButtonIcon, {
            class: "text-gray-300",
            label: unref(t)("Partager", { ns: "client" }),
            icon: "share"
          }, null, 8, ["label"])
        ]),
        createCommentVNode(" right buttons "),
        createBaseVNode("div", _hoisted_4$a, [
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("What's new", { ns: "client" }),
            link: `https://geoportail.lu/${unref(i18next).language}/questions/whats-new/`
          }, null, 8, ["label", "link"]),
          createCommentVNode("TODO get geonetworkBaseUrl from config"),
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("Geocatalogue", { ns: "client" }),
            link: ""
          }, null, 8, ["label"]),
          createCommentVNode("TODO handle feedback links (for different portals?)"),
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("Feedback", { ns: "client" }),
            link: ""
          }, null, 8, ["label"]),
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("A Propos", { ns: "client" }),
            link: `https://www.geoportail.lu/${unref(i18next).language}/propos/`
          }, null, 8, ["label", "link"]),
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("Aide", { ns: "client" }),
            link: `https://www.geoportail.lu/${unref(i18next).language}/documentation/`
          }, null, 8, ["label", "link"]),
          createVNode(ButtonLink, {
            class: "hidden lg:flex",
            label: unref(t)("Contact", { ns: "client" }),
            link: `https://www.geoportail.lu/${unref(i18next).language}/propos/contactez-nous/`
          }, null, 8, ["label", "link"]),
          createVNode(ButtonLink, {
            label: unref(t)("Legalites", { ns: "client" }),
            link: `https://www.geoportail.lu/${unref(i18next).language}/propos/mentions-legales/`
          }, null, 8, ["label", "link"]),
          createVNode(ButtonLink, {
            label: unref(t)("ACT", { ns: "client" }),
            link: `http://www.act.public.lu/`
          }, null, 8, ["label", "link"])
        ])
      ]);
    };
  }
});
const FooterBar = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/footer/footer-bar.vue"]]);
const _hoisted_1$d = { class: "flex flex-row flex-wrap pl-2.5" };
const _hoisted_2$c = ["onClick"];
const _hoisted_3$b = { class: "text-2xl absolute top-5" };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: true }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.themes, (theme) => {
          return openBlock(), createElementBlock("button", {
            class: normalizeClass(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${theme.name}-primary hover:text-${theme.name}-primary`]),
            key: theme.id,
            onClick: ($event) => _ctx.$emit("setTheme", theme.name)
          }, [
            createBaseVNode("div", _hoisted_3$b, toDisplayString(unref(t)(`${theme.name}`)), 1),
            createBaseVNode("div", {
              class: normalizeClass(["text-6xl absolute bottom-1 after:font-icons", `after:content-${theme.name}`])
            }, null, 2)
          ], 10, _hoisted_2$c);
        }), 128))
      ]);
    };
  }
});
const ThemeGrid = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/theme-selector/theme-grid.vue"]]);
const _hoisted_1$c = ["aria-expanded"];
const _hoisted_2$b = { class: "py-0.5" };
const _hoisted_3$a = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" };
const _hoisted_4$9 = { class: "py-[3px]" };
const _hoisted_5$8 = { class: "flex flex-row flex-wrap ml-1 w-12" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: true },
    currentTheme: { type: null, required: false },
    isOpen: { type: Boolean, required: false }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const themesComputed = computed(() => {
      var _a;
      return ((_a = props.themes) == null ? void 0 : _a.slice(0, 8)) || [];
    });
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": props.isOpen
      }, [
        createBaseVNode("span", _hoisted_2$b, toDisplayString(unref(t)("Theme")) + ": " + toDisplayString(unref(t)(`${(_a = props.currentTheme) == null ? void 0 : _a.name}`)), 1),
        createBaseVNode("span", _hoisted_3$a, [
          createBaseVNode("span", _hoisted_4$9, toDisplayString(unref(t)("Changer")), 1),
          createBaseVNode("span", _hoisted_5$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(themesComputed), (theme) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(`h-2.5 w-2.5 m-px bg-${theme.name}-primary`),
                key: theme.id
              }, null, 2);
            }), 128))
          ])
        ])
      ], 8, _hoisted_1$c);
    };
  }
});
const ThemeSelectorButton = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/theme-selector/theme-selector-button.vue"]]);
const _hoisted_1$b = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "theme-selector",
  setup(__props) {
    const appStore = useAppStore();
    const { setThemeGridOpen } = appStore;
    const { themeGridOpen } = storeToRefs(appStore);
    const themeStore = useThemeStore();
    const themesService = useThemes();
    const { theme, themes: themesFromStore } = storeToRefs(themeStore);
    const themes2 = computed(
      () => {
        var _a;
        return ((_a = themesFromStore.value) == null ? void 0 : _a.filter(
          (theme2) => {
            var _a2;
            return ((_a2 = theme2.metadata) == null ? void 0 : _a2.display_in_switcher) === true;
          }
        )) || [];
      }
    );
    function toggleThemesGrid() {
      setThemeGridOpen(!themeGridOpen.value);
    }
    function setTheme(themeName) {
      themesService.setTheme(themeName);
      toggleThemesGrid();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(ThemeSelectorButton, {
          onClick: toggleThemesGrid,
          themes: unref(themes2),
          currentTheme: unref(theme),
          isOpen: unref(themeGridOpen)
        }, null, 8, ["themes", "currentTheme", "isOpen"]),
        unref(themeGridOpen) ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
          createVNode(ThemeGrid, {
            onSetTheme: setTheme,
            themes: unref(themes2)
          }, null, 8, ["themes"])
        ])) : createCommentVNode("v-if", true)
      ], 64);
    };
  }
});
const ThemeSelector = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/theme-selector/theme-selector.vue"]]);
function themesToLayerTree(node, depth = 0) {
  const { name, id, children, metadata } = node;
  return {
    name,
    id,
    depth,
    children: children == null ? void 0 : children.map((child) => themesToLayerTree(child, depth + 1)),
    checked: false,
    expanded: (metadata == null ? void 0 : metadata.is_expanded) || false
  };
}
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "catalog-tree",
  setup(__props) {
    const mapStore = useMapStore();
    const themeStore = useThemeStore();
    const layers = useLayers();
    const layerTree = shallowRef();
    watchEffect(updateLayerTree);
    function updateLayerTree() {
      var _a;
      if (themeStore.theme && mapStore.layers) {
        const treeModel = layerTree.value && layerTree.value.id === ((_a = themeStore.theme) == null ? void 0 : _a.id) ? layerTree.value : themesToLayerTree(themeStore.theme);
        layerTree.value = layerTreeService.updateLayers(
          treeModel,
          mapStore.layers
        );
      }
    }
    function toggleParent(node) {
      layerTree.value = layerTreeService.toggleNode(
        node.id,
        layerTree.value,
        "expanded"
      );
    }
    function toggleLayer(node) {
      layers.toggleLayer(+node.id, !node.checked);
    }
    return (_ctx, _cache) => {
      return unref(layerTree) ? (openBlock(), createBlock(LayerTreeNode, {
        node: unref(layerTree),
        key: unref(layerTree).id,
        onToggleParent: toggleParent,
        onToggleLayer: toggleLayer
      }, null, 8, ["node"])) : createCommentVNode("v-if", true);
    };
  }
});
const Catalog = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/catalog/catalog-tree.vue"]]);
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "catalog-tab",
  setup(__props) {
    const { themeGridOpen } = storeToRefs(useAppStore());
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(ThemeSelector),
        unref(themeGridOpen) === false ? (openBlock(), createBlock(Catalog, {
          key: 0,
          class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
        })) : createCommentVNode("v-if", true)
      ], 64);
    };
  }
});
const CatalogTab = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_23) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform2 = css(el, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr2, obj) {
  for (var i in arr2) {
    if (!arr2.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr2[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src2) {
  if (dst && src2) {
    for (var key in src2) {
      if (src2.hasOwnProperty(key)) {
        dst[key] = src2[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y2) {
  el.scrollLeft += x;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults$1) {
      if (defaults$1.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults$1[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref2) {
  var sortable = _ref2.sortable, rootEl2 = _ref2.rootEl, name = _ref2.name, targetEl = _ref2.targetEl, cloneEl2 = _ref2.cloneEl, toEl = _ref2.toEl, fromEl = _ref2.fromEl, oldIndex2 = _ref2.oldIndex, newIndex2 = _ref2.newIndex, oldDraggableIndex2 = _ref2.oldDraggableIndex, newDraggableIndex2 = _ref2.newDraggableIndex, originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, extraEventProperties = _ref2.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref2.evt, data = _objectWithoutProperties(_ref2, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof$3(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref2) {
  var originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, dragEl2 = _ref2.dragEl, activeSortable = _ref2.activeSortable, dispatchSortableEvent = _ref2.dispatchSortableEvent, hideGhostForTarget = _ref2.hideGhostForTarget, unhideGhostForTarget = _ref2.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
const DEFAULT_SLIDER_RATIO = 0.5;
const DEFAULT_SLIDER_OPENED = false;
const useSliderComparatorStore = defineStore(
  "slider",
  () => {
    const mapStore = useMapStore();
    const sliderRatio = ref(DEFAULT_SLIDER_RATIO);
    const sliderActive = ref(DEFAULT_SLIDER_OPENED);
    const sliderTopLayer = computed(
      () => [...mapStore.layers].reverse()[0]
    );
    function setRatio(ratio) {
      let newRatio = ratio;
      if (ratio < 0.1) {
        newRatio = 0.1;
      } else if (ratio > 0.9) {
        newRatio = 0.9;
      }
      sliderRatio.value = newRatio;
    }
    function toggleSlider(open2) {
      sliderActive.value = open2 != null ? open2 : !sliderActive.value;
    }
    return {
      sliderActive,
      sliderRatio,
      sliderTopLayer,
      setRatio,
      toggleSlider
    };
  },
  {}
);
function useLayer(layer, context) {
  const { t } = useTranslation();
  function getLabel() {
    return t(layer.name, { ns: "client" });
  }
  function onClickInfo() {
    context == null ? void 0 : context.emit("clickInfo", layer);
  }
  return {
    t,
    getLabel,
    onClickInfo
  };
}
const _hoisted_1$a = { class: "lux-layer-manager-item mt-2.5" };
const _hoisted_2$a = ["title"];
const _hoisted_3$9 = { class: "flex-1 text-left cursor-default" };
const _hoisted_4$8 = ["title"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: true },
    layer: { type: null, required: true }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const { t, onClickInfo } = useLayer(props.layer, { emit: emit2 });
    const txtTitleLabel = computed(
      () => t('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: getLabel()
      })
    );
    function getLabel() {
      return t(props.layer.name, { ns: "client" });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createBaseVNode("button", {
          class: "fa fa-info w-3",
          title: unref(txtTitleLabel),
          onClick: _cache[0] || (_cache[0] = (...args) => unref(onClickInfo) && unref(onClickInfo)(...args))
        }, null, 8, _hoisted_2$a),
        createBaseVNode("span", _hoisted_3$9, toDisplayString(getLabel()), 1),
        __props.showEditButton ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "fa fa-pencil",
          title: unref(t)("Open editor panel", { ns: "client" }),
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("clickEdit"))
        }, null, 8, _hoisted_4$8)) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
const LayerManagerItemBackground = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-manager/layer-item/layer-item-background.vue"]]);
const _hoisted_1$9 = { class: "lux-layer-manager-item relative" };
const _hoisted_2$9 = { class: "w-full flex flex-nowrap items-start gap-x-2" };
const _hoisted_3$8 = ["title"];
const _hoisted_4$7 = ["title"];
const _hoisted_5$7 = ["aria-expanded", "aria-controls", "data-cy"];
const _hoisted_6$4 = ["aria-expanded", "aria-controls"];
const _hoisted_7$2 = ["title"];
const _hoisted_8$2 = ["id"];
const _hoisted_9 = ["title"];
const _hoisted_10 = ["id", "value", "aria-label"];
const _hoisted_11 = ["aria-label"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "layer-item",
  props: {
    layer: { type: null, required: true },
    draggableClassName: { type: String, required: true },
    isOpen: { type: Boolean, required: true },
    isLayerComparatorOpen: { type: Boolean, required: true },
    displayLayerComparatorOpen: { type: Boolean, required: true }
  },
  emits: [
    "clickInfo",
    "clickEdit",
    "changeOpacity",
    "clickToggle",
    "clickToggleLayerComparator",
    "clickRemove"
  ],
  setup(__props, { emit: emit2 }) {
    var _a, _b, _c, _d;
    const props = __props;
    const { t, getLabel, onClickInfo } = useLayer(props.layer, { emit: emit2 });
    const opacity = shallowRef(
      ((_b = (_a = props.layer) == null ? void 0 : _a.opacity) != null ? _b : 1) * 100
    );
    const prevOpacity = shallowRef(
      ((_d = (_c = props.layer) == null ? void 0 : _c.previousOpacity) != null ? _d : opacity.value) * 100
    );
    const txtDraggableLabel = computed(
      () => t('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: getLabel()
      })
    );
    const txtTitleLabel = computed(
      () => t('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: getLabel()
      })
    );
    const txtRemoveLayer = computed(
      () => t('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: getLabel()
      })
    );
    function onClickToggle() {
      emit2("clickToggle", props.layer);
    }
    function onToggleVisibility() {
      if (opacity.value === 0) {
        opacity.value = prevOpacity.value;
      } else {
        prevOpacity.value = opacity.value;
        opacity.value = 0;
      }
      dispatchChangeOpacity();
    }
    function onClickRemove() {
      emit2("clickRemove", props.layer);
    }
    function onChangeOpacity(event) {
      if (event.target) {
        opacity.value = parseInt(event.target.value);
        dispatchChangeOpacity();
      }
    }
    function onToggleLayerComparator() {
      emit2("clickToggleLayerComparator", props.layer);
    }
    function dispatchChangeOpacity() {
      emit2("changeOpacity", props.layer, opacity.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("button", {
            class: normalizeClass(["fa-solid fa-bars cursor-move mt-1", __props.draggableClassName]),
            title: unref(txtDraggableLabel)
          }, null, 10, _hoisted_3$8),
          createBaseVNode("button", {
            class: "fa-solid fa-info mt-1",
            title: unref(txtTitleLabel),
            onClick: _cache[0] || (_cache[0] = (...args) => unref(onClickInfo) && unref(onClickInfo)(...args))
          }, null, 8, _hoisted_4$7),
          createBaseVNode("button", {
            "aria-expanded": props.isOpen,
            "aria-controls": `layer-manager-item-content-${props.layer.id}`,
            "data-cy": `myLayerItemLabel-${props.layer.id}`,
            class: "cursor-pointer grow text-left break-words w-[70%]",
            onClick: onClickToggle
          }, toDisplayString(unref(getLabel)()), 9, _hoisted_5$7),
          createBaseVNode("button", {
            class: normalizeClass(["mt-1 w-3.5 fa-solid", props.isOpen ? "fa-xmark" : "fa-ellipsis"]),
            onClick: onClickToggle,
            "aria-expanded": props.isOpen,
            "aria-controls": `layer-manager-item-content-${props.layer.id}`
          }, null, 10, _hoisted_6$4),
          createBaseVNode("button", {
            class: "mt-1 fa-solid fa-trash",
            title: unref(txtRemoveLayer),
            onClick: onClickRemove
          }, null, 8, _hoisted_7$2)
        ]),
        createBaseVNode("div", {
          class: normalizeClass(["lux-layer-manager-item-content", props.isOpen ? "h-6" : "h-0"]),
          id: `layer-manager-item-content-${props.layer.id}`
        }, [
          createBaseVNode("button", {
            title: unref(t)("Toggle layer opacity for {{layerName}}", {
              layerName: unref(t)(props.layer.name)
            }),
            class: normalizeClass(["w-5 fa-solid", unref(opacity) === 0 ? "fa-eye-slash" : "fa-eye"]),
            onClick: onToggleVisibility
          }, null, 10, _hoisted_9),
          createBaseVNode("input", {
            id: `${props.layer.id}-steps-range`,
            type: "range",
            min: "0",
            max: "100",
            value: unref(opacity),
            step: "25",
            onChange: onChangeOpacity,
            class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
            "aria-label": unref(t)("Change opacity for {{ layerName }}", { layerName: unref(getLabel)() })
          }, null, 40, _hoisted_10),
          __props.displayLayerComparatorOpen ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(["fa ml-auto text-sm cursor-pointer", props.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
            "aria-label": unref(t)("Toggle layer comparator for {{ layerName }}", {
              layerName: unref(getLabel)()
            }),
            onClick: onToggleLayerComparator
          }, null, 10, _hoisted_11)) : createCommentVNode("v-if", true)
        ], 10, _hoisted_8$2)
      ]);
    };
  }
});
const LayerManagerItem = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-manager/layer-item/layer-item.vue"]]);
const _hoisted_1$8 = { id: "sortable-layers" };
const _hoisted_2$8 = ["id"];
const _hoisted_3$7 = { class: "flex flex-row justify-center space-x-1 my-2" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(__props, { emit: emit2 }) {
    const { t } = useTranslation();
    const { setMetadataId } = useMetadataStore();
    const mapStore = useMapStore();
    const appStore = useAppStore();
    const styles = useMvtStyles();
    const sliderStore = useSliderComparatorStore();
    const { bgLayer } = storeToRefs(mapStore);
    const { sliderActive } = storeToRefs(sliderStore);
    const layers = computed(() => [...mapStore.layers].reverse());
    const isLayerOpenId = shallowRef();
    const draggableClassName = "drag-handle";
    const bgLayerIsEditable = computed(
      () => styles.isLayerStyleEditable(bgLayer.value)
    );
    const { setRemoteLayersOpen } = useAppStore();
    onMounted(() => {
      const sortableLayers = document.getElementById("sortable-layers");
      if (sortableLayers) {
        Sortable.create(sortableLayers, {
          dataIdAttr: "data-id",
          dragClass: "lux-sortable-drag",
          ghostClass: "lux-sortable-ghost",
          sort: true,
          handle: `.${draggableClassName}`,
          onSort: sortMethod
        });
      }
    });
    function sortMethod(event) {
      const items = event.to.children;
      mapStore.reorderLayers([...items].map((val) => Number(val.id)).reverse());
    }
    function changeOpacityLayer(layer, opacity) {
      mapStore.setLayerOpacity(layer.id, opacity / 100);
    }
    function removeLayer(layer) {
      mapStore.removeLayers(layer.id);
    }
    function toggleAccordionItem(layer) {
      isLayerOpenId.value = isLayerOpenId.value !== layer.id ? layer.id : void 0;
    }
    function openEditionLayer() {
      appStore.openStyleEditorPanel();
    }
    function toggleLayerComparator() {
      sliderStore.toggleSlider();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ul", _hoisted_1$8, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(layers), (layer, index2) => {
          return openBlock(), createElementBlock("li", {
            key: layer.id,
            id: layer.id
          }, [
            createVNode(LayerManagerItem, {
              draggableClassName,
              layer,
              isOpen: unref(isLayerOpenId) === layer.id,
              isLayerComparatorOpen: unref(sliderActive),
              displayLayerComparatorOpen: index2 === 0,
              onClickRemove: removeLayer,
              onClickToggle: toggleAccordionItem,
              onClickToggleLayerComparator: toggleLayerComparator,
              onClickInfo: ($event) => unref(setMetadataId)(layer.id),
              onChangeOpacity: changeOpacityLayer
            }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo"])
          ], 8, _hoisted_2$8);
        }), 128)),
        createBaseVNode("li", null, [
          createVNode(LayerManagerItemBackground, {
            layer: unref(bgLayer) || unref(BLANK_BACKGROUNDLAYER),
            showEditButton: unref(bgLayerIsEditable),
            onClickInfo: _cache[0] || (_cache[0] = () => unref(bgLayer) && unref(setMetadataId)(unref(bgLayer).id)),
            onClickEdit: openEditionLayer
          }, null, 8, ["layer", "showEditButton"]),
          createBaseVNode("div", _hoisted_3$7, [
            createBaseVNode("button", {
              class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
              onClick: _cache[1] || (_cache[1] = ($event) => emit2("displayCatalog"))
            }, toDisplayString(unref(t)("+ Add layers", { ns: "client" })), 1),
            createBaseVNode("button", {
              class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
              onClick: _cache[2] || (_cache[2] = ($event) => unref(setRemoteLayersOpen)(true))
            }, toDisplayString(unref(t)("+ Add external Wms", { ns: "client" })), 1)
          ])
        ])
      ]);
    };
  }
});
const LayerManager = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-manager/layer-manager.vue"]]);
const _hoisted_1$7 = { class: "flex flex-col h-full pt-1.5" };
const _hoisted_2$7 = { class: "h-16 shrink-0 flex justify-between lux-panel-title" };
const _hoisted_3$6 = ["aria-label"];
const _hoisted_4$6 = { class: "flex flex-row gap-2 h-10 text-2xl" };
const _hoisted_5$6 = ["aria-expanded"];
const _hoisted_6$3 = { key: 0 };
const _hoisted_7$1 = ["aria-expanded"];
const _hoisted_8$1 = { class: "relative grow p-2.5 bg-primary overflow-auto" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "layer-panel",
  setup(__props) {
    const { t } = useTranslation();
    const appStore = useAppStore();
    const { setLayersOpen } = appStore;
    const { myLayersTabOpen } = storeToRefs(appStore);
    const { layers } = storeToRefs(useMapStore());
    function onClickMyLayers() {
      appStore.setMyLayersTabOpen(true);
    }
    function onDisplayCatalog() {
      appStore.setMyLayersTabOpen(false);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createCommentVNode(" Panel title and close button "),
        createBaseVNode("div", _hoisted_2$7, [
          createBaseVNode("div", null, toDisplayString(unref(t)("Layers", { ns: "client" })), 1),
          createBaseVNode("span", null, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = () => unref(setLayersOpen)(false)),
              "aria-label": unref(t)("Close", { ns: "client" }),
              class: "fa-sharp fa-solid fa-close"
            }, null, 8, _hoisted_3$6)
          ])
        ]),
        createCommentVNode(" My Layers and Catalog tab labels "),
        createBaseVNode("div", _hoisted_4$6, [
          createBaseVNode("button", {
            onClick: onClickMyLayers,
            class: normalizeClass(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", unref(myLayersTabOpen) ? "bg-primary" : "bg-tertiary"]),
            "aria-expanded": unref(myLayersTabOpen)
          }, [
            createTextVNode(toDisplayString(unref(t)("my_layers", { ns: "client" })) + " ", 1),
            unref(layers).length ? (openBlock(), createElementBlock("span", _hoisted_6$3, "(" + toDisplayString(unref(layers).length) + ")", 1)) : createCommentVNode("v-if", true)
          ], 10, _hoisted_5$6),
          createBaseVNode("button", {
            onClick: onDisplayCatalog,
            class: normalizeClass(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", unref(myLayersTabOpen) ? "bg-tertiary" : "bg-primary"]),
            "aria-expanded": !unref(myLayersTabOpen)
          }, toDisplayString(unref(t)("Catalog", { ns: "client" })), 11, _hoisted_7$1)
        ]),
        createCommentVNode(" Panel content (MyLayers and Catalog) "),
        createBaseVNode("div", _hoisted_8$1, [
          unref(myLayersTabOpen) ? (openBlock(), createBlock(LayerManager, {
            key: 0,
            onDisplayCatalog
          })) : createCommentVNode("v-if", true),
          !unref(myLayersTabOpen) ? (openBlock(), createBlock(CatalogTab, { key: 1 })) : createCommentVNode("v-if", true)
        ])
      ]);
    };
  }
});
const LayerPanel = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/layer-panel/layer-panel.vue"]]);
class StatePersistorLayerComparatorService {
  bootstrap() {
    let stop;
    stop = watchEffect(() => {
      this.restore();
      this.persist();
      stop && stop();
    });
  }
  persist() {
    const sliderStore = useSliderComparatorStore();
    watch(
      [() => sliderStore.sliderActive, () => sliderStore.sliderRatio],
      ([newSliderActive, newSliderRatio], [oldSliderActive]) => {
        if (newSliderActive !== oldSliderActive) {
          storageHelper.setValue(SP_KEY_LAYERCOMPARATOR, newSliderActive);
        }
        storageHelper.setValue(
          SP_KEY_LAYERCOMPARATOR_SLIDERRATIO,
          newSliderRatio
        );
      }
    );
  }
  restore() {
    const lc = storageHelper.getValue(SP_KEY_LAYERCOMPARATOR, stringToBoolean);
    const sliderRatio = storageHelper.getValue(SP_KEY_LAYERCOMPARATOR_SLIDERRATIO, stringToNumber);
    const { toggleSlider, setRatio } = useSliderComparatorStore();
    if (typeof lc !== "undefined" && lc !== null) {
      toggleSlider(lc);
      if (typeof sliderRatio !== void 0 && sliderRatio !== null) {
        setRatio(sliderRatio != null ? sliderRatio : DEFAULT_SLIDER_RATIO);
      }
    }
  }
}
const statePersistorSliderComparatorService = new StatePersistorLayerComparatorService();
const _hoisted_1$6 = ["onKeydown"];
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("span", { class: "lux-slider-line" }, null, -1);
const _hoisted_3$5 = /* @__PURE__ */ createBaseVNode("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ createBaseVNode("span"),
  /* @__PURE__ */ createBaseVNode("span")
], -1);
const _hoisted_4$5 = {
  key: 0,
  class: "lux-slider-layer-label"
};
const _hoisted_5$5 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-arrow-left mr-2" }, null, -1);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: true },
    sliderRatio: { type: Number, required: true },
    sliderTopLayer: { type: null, required: true },
    sliderOffset: { type: Number, required: true },
    containerOffset: { type: Number, required: true }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(__props, { expose, emit: emit2 }) {
    const props = __props;
    const DEFAULT_STEP_ONKEYDOWN = 30;
    const { t } = useTranslation();
    const sliderElement = ref(null);
    const styleObject = computed(() => ({ left: `${props.sliderOffset}px` }));
    let isDragging = false;
    expose({
      sliderElement
    });
    function moveSplitBar(offsetLeft) {
      emit2("moveSplitBar", offsetLeft + sliderElement.value.offsetWidth / 2);
    }
    function onMouseDown() {
      isDragging = true;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    function onMouseMove(payload) {
      if (!isDragging) {
        return;
      }
      moveSplitBar(payload.clientX - props.containerOffset);
    }
    function onMouseUp() {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    function onKeyDownRight() {
      moveSplitBar(sliderElement.value.offsetLeft + DEFAULT_STEP_ONKEYDOWN);
    }
    function onKeyDownLeft() {
      moveSplitBar(sliderElement.value.offsetLeft - DEFAULT_STEP_ONKEYDOWN);
    }
    function onKeyDownEsc() {
      emit2("escSplitBar");
    }
    onMounted(() => {
      var _a;
      (_a = sliderElement.value) == null ? void 0 : _a.focus({ focusVisible: true });
    });
    onUnmounted(() => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        ref_key: "sliderElement",
        ref: sliderElement,
        onMousedown: onMouseDown,
        onMousemove: onMouseMove,
        onMouseup: onMouseUp,
        onKeydown: [
          withKeys(onKeyDownRight, ["space"]),
          withKeys(onKeyDownRight, ["right"]),
          withKeys(onKeyDownLeft, ["left"]),
          withKeys(onKeyDownLeft, ["delete"]),
          withKeys(onKeyDownEsc, ["esc"])
        ],
        class: "left-[20px] absolute h-full w-[32px] block",
        style: normalizeStyle(unref(styleObject)),
        role: "seperator",
        "aria-controls": "map-container"
      }, [
        _hoisted_2$6,
        _hoisted_3$5,
        __props.sliderTopLayer ? (openBlock(), createElementBlock("span", _hoisted_4$5, [
          _hoisted_5$5,
          createBaseVNode("span", null, toDisplayString(unref(t)(__props.sliderTopLayer.name)), 1)
        ])) : createCommentVNode("v-if", true)
      ], 44, _hoisted_1$6);
    };
  }
});
const SplitterElement = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/slider/splitter-element.vue"]]);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "slider-comparator",
  setup(__props) {
    const sliderStore = useSliderComparatorStore();
    const openLayers = useOpenLayers();
    const olMap2 = useMap().olMap;
    const splitterElement = ref(null);
    const { sliderActive, sliderRatio, sliderTopLayer } = storeToRefs(sliderStore);
    const splitterElementOffset = computed(
      () => {
        var _a, _b;
        return ((_b = (_a = splitterElement.value) == null ? void 0 : _a.sliderElement) == null ? void 0 : _b.offsetWidth) || 0;
      }
    );
    const sliderOffset = computed(
      () => {
        var _a, _b;
        return olMap2.value && splitterElement.value ? sliderRatio.value * olMap2.value.getSize()[0] - ((_b = (_a = splitterElement.value) == null ? void 0 : _a.sliderElement) == null ? void 0 : _b.offsetWidth) / 2 + olMap2.value.getViewport().offsetLeft : 0;
      }
    );
    let olLayerPrerenderEvent;
    let olLayerPostrenderEvent;
    let mapWrapperElement;
    statePersistorSliderComparatorService.bootstrap();
    watch([sliderTopLayer, sliderActive], ([topLayer, isActive], [oldTopLayer]) => {
      var _a;
      if (topLayer && isActive) {
        if (topLayer !== oldTopLayer) {
          deactivate();
        }
        activate();
      } else {
        deactivate();
      }
      (_a = olMap2.value) == null ? void 0 : _a.render();
    });
    watch(sliderOffset, () => {
      var _a;
      (_a = olMap2.value) == null ? void 0 : _a.render();
    });
    function activate() {
      const olLayer = openLayers.getLayerFromCache(sliderTopLayer.value);
      olLayerPrerenderEvent = olLayer.on(
        EventType.PRERENDER,
        function(event) {
          var _a;
          const ctx = event.context;
          const mapSize = (_a = olMap2.value) == null ? void 0 : _a.getSize();
          const width = sliderOffset.value + splitterElementOffset.value / 2;
          const tl = getRenderPixel(event, [0, 0]);
          const tr = getRenderPixel(event, [width, 0]);
          const bl = getRenderPixel(event, [0, mapSize[1]]);
          const br = getRenderPixel(event, [width, mapSize[0]]);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(tl[0], tl[1]);
          ctx.lineTo(bl[0], bl[1]);
          ctx.lineTo(br[0], br[1]);
          ctx.lineTo(tr[0], tr[1]);
          ctx.closePath();
          ctx.clip();
        }
      );
      olLayerPostrenderEvent = olLayer.on(
        EventType.POSTRENDER,
        function(e) {
          const event = e;
          const ctx = event.context;
          ctx.restore();
        }
      );
    }
    function deactivate() {
      unByKey([olLayerPrerenderEvent, olLayerPostrenderEvent]);
    }
    function onMoveSplitBar(offsetLeft) {
      var _a;
      const mapSize = (_a = olMap2.value) == null ? void 0 : _a.getSize();
      const newRatio = offsetLeft / mapSize[0];
      sliderStore.setRatio(newRatio);
    }
    function onEscSplitBar() {
      sliderStore.toggleSlider();
    }
    onMounted(() => {
      var _a, _b;
      mapWrapperElement = (_b = (_a = olMap2.value) == null ? void 0 : _a.getTargetElement()) == null ? void 0 : _b.closest(".map-wrapper");
    });
    onUnmounted(() => {
      deactivate();
    });
    return (_ctx, _cache) => {
      var _a;
      return unref(sliderTopLayer) && unref(sliderActive) ? (openBlock(), createBlock(SplitterElement, {
        key: 0,
        ref_key: "splitterElement",
        ref: splitterElement,
        sliderActive: unref(sliderActive),
        sliderRatio: unref(sliderRatio),
        sliderTopLayer: unref(sliderTopLayer),
        sliderOffset: unref(sliderOffset),
        containerOffset: ((_a = unref(mapWrapperElement)) == null ? void 0 : _a.offsetLeft) || 0,
        onMoveSplitBar,
        onEscSplitBar
      }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : createCommentVNode("v-if", true);
    };
  }
});
const SliderComparator = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/slider/slider-comparator.vue"]]);
const STORAGE_SEPARATOR = "-";
const STORAGE_SEPARATOR_V2 = ",";
class StorageLayerMapper {
  constructor() {
    __publicField(this, "layersOpacitiesToNumbersV2", (opacitiesText) => {
      return this.layersOpacitiesToNumbers(opacitiesText, STORAGE_SEPARATOR_V2);
    });
  }
  layerIdsToLayers(layerIdsText) {
    const themes2 = useThemes();
    const layers = useLayers();
    const layerIds = layerIdsText ? layerIdsText.split(STORAGE_SEPARATOR) : [];
    return layerIds.map((layerId) => {
      const layer = remoteLayersService.isRemoteLayer(layerId) ? remoteLayerIdtoLayer(layerId) : themes2.findById(parseInt(layerId, 10));
      return layer ? layers.initLayer(layer) : void 0;
    });
  }
  layerNamesToLayersV2(layersNamesText) {
    const themes2 = useThemes();
    const layers = useLayers();
    const layersNames = layersNamesText ? layersNamesText.split(STORAGE_SEPARATOR_V2) : [];
    return layersNames.map((layerName) => {
      const layer = themes2.findByName(layerName);
      return layer ? layers.initLayer(layer) : void 0;
    });
  }
  layersOpacitiesToNumbers(opacitiesText, separator = STORAGE_SEPARATOR) {
    return stringToNumbers(opacitiesText, separator);
  }
  layersVisibilitiesToBooleansV2(visibilitiesText) {
    return stringToBooleans(visibilitiesText, STORAGE_SEPARATOR_V2);
  }
  layersToLayerIds(layers) {
    return (layers == null ? void 0 : layers.map((layer) => layer.id).join(STORAGE_SEPARATOR)) || "";
  }
  layersToLayerOpacities(layers) {
    return (layers == null ? void 0 : layers.map((layer) => {
      var _a;
      return (_a = layer.opacity) != null ? _a : 1;
    }).join(STORAGE_SEPARATOR)) || "";
  }
  bgLayerNameToBgLayer(bgLayerName) {
    const themes2 = useThemes();
    return bgLayerName ? themes2.findBgLayerByName(bgLayerName) : null;
  }
  bgLayerToBgLayerName(layer) {
    return (layer == null ? void 0 : layer.name) || BLANK_BACKGROUNDLAYER.name;
  }
}
const storageLayerMapper = new StorageLayerMapper();
const DEFAULT_BGLAYER_NAME = "basemap_2015_global";
const DEFAULT_BGLAYER_NAME_V2 = "orthogr_2013_global";
const V2_BGLAYER_TO_V3_ = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class StatePersistorBgLayerService {
  bootstrap() {
    const themeStore = useThemeStore();
    let stop;
    stop = watchEffect(() => {
      if (themeStore.bgLayers.length > 0) {
        this.restore();
        this.persist();
        stop && stop();
      }
    });
  }
  persist() {
    const mapStore = useMapStore();
    const { bgLayer } = storeToRefs(mapStore);
    watch(
      bgLayer,
      (value, oldValue) => {
        if (oldValue !== value) {
          storageHelper.setValue(
            SP_KEY_BGLAYER,
            value,
            storageLayerMapper.bgLayerToBgLayerName
          );
        }
      },
      { immediate: true }
    );
  }
  restore() {
    const { setMapBackground } = useBackgroundLayer();
    const bgLayer = this.getBgLayerFromStorage();
    setMapBackground(bgLayer);
  }
  getBgLayerFromStorage() {
    const version2 = storageHelper.getInitialVersion();
    const bgLayerName = storageHelper.getValue(SP_KEY_BGLAYER);
    const bgLayer = !bgLayerName ? storageLayerMapper.bgLayerNameToBgLayer(DEFAULT_BGLAYER_NAME) : version2 === 2 ? this.getBgLayerFromStorageV2(bgLayerName) : storageLayerMapper.bgLayerNameToBgLayer(bgLayerName);
    return bgLayer;
  }
  getBgLayerFromStorageV2(bgLayerNameFromStorage) {
    const bgLayerOpacity = storageHelper.getValue(
      SP_KEY_V2_BGLAYEROPACITY,
      stringToNumber
    );
    let bgLayerName = "";
    if (bgLayerNameFromStorage) {
      bgLayerName = V2_BGLAYER_TO_V3_[bgLayerNameFromStorage];
    } else if (bgLayerOpacity === 0) {
      bgLayerName = DEFAULT_BGLAYER_NAME_V2;
    }
    return storageLayerMapper.bgLayerNameToBgLayer(bgLayerName);
  }
}
const statePersistorBgLayerService = new StatePersistorBgLayerService();
class StatePersistorLayersService {
  bootstrap() {
    const themeStore = useThemeStore();
    let stop;
    stop = watchEffect(() => {
      if (themeStore.themes) {
        this.restore();
        this.persist();
        stop && stop();
      }
    });
  }
  persist() {
    const mapStore = useMapStore();
    const { layers } = storeToRefs(mapStore);
    watch(
      layers,
      (value, oldValue) => {
        if (oldValue !== value) {
          storageHelper.setValue(
            SP_KEY_LAYERS,
            value,
            storageLayerMapper.layersToLayerIds
          );
          storageHelper.setValue(
            SP_KEY_OPACITIES,
            value,
            storageLayerMapper.layersToLayerOpacities
          );
        }
      },
      { immediate: true }
    );
  }
  restore() {
    const version2 = storageHelper.getInitialVersion();
    const mapStore = useMapStore();
    const layers = storageHelper.getValue(
      SP_KEY_LAYERS,
      version2 === 2 ? storageLayerMapper.layerNamesToLayersV2 : storageLayerMapper.layerIdsToLayers
    );
    const opacities = version2 === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    if (opacities) {
      layers == null ? void 0 : layers.forEach((layer, index2) => {
        var _a;
        if (layer) {
          layer.opacity = (_a = opacities[index2]) != null ? _a : 1;
        }
      });
    }
    if (version2 === 2) {
      storageHelper.removeItem(SP_KEY_V2_BGLAYEROPACITY);
      storageHelper.removeItem(SP_KEY_V2_LAYERSINDICIES);
      storageHelper.removeItem(SP_KEY_V2_LAYERSOPACITIES);
      storageHelper.removeItem(SP_KEY_V2_LAYERSVISIBILITY);
    }
    mapStore.addLayers(...(layers == null ? void 0 : layers.filter((layer) => layer)) || []);
  }
  getOpacitiesFromStorage() {
    return storageHelper.getValue(
      SP_KEY_OPACITIES,
      storageLayerMapper.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const opacities = storageHelper.getValue(
      SP_KEY_V2_LAYERSOPACITIES,
      storageLayerMapper.layersOpacitiesToNumbersV2
    );
    const visibility = storageHelper.getValue(
      SP_KEY_V2_LAYERSVISIBILITY,
      storageLayerMapper.layersVisibilitiesToBooleansV2
    );
    return opacities.map((opacity, index2) => visibility[index2] ? opacity : 0);
  }
}
const statePersistorLayersService = new StatePersistorLayersService();
class StorageThemeMapper {
  themeToThemeName(theme) {
    return (theme == null ? void 0 : theme.name) || "";
  }
}
const storageThemeMapper = new StorageThemeMapper();
class StatePersistorThemeService {
  bootstrap() {
    this.restore();
    let stop;
    stop = watchEffect(() => {
      this.persist();
      stop && stop();
    });
  }
  persist() {
    const themeStore = useThemeStore();
    watch(
      () => themeStore.theme,
      (value, oldValue) => {
        if (oldValue !== value && value) {
          storageHelper.setValue(
            SP_KEY_THEME,
            value,
            storageThemeMapper.themeToThemeName
          );
        }
      },
      { immediate: true }
    );
  }
  restore() {
    const theme = storageHelper.getValue(SP_KEY_THEME);
    if (theme) {
      const { setTheme } = useThemeStore();
      setTheme(theme);
    }
  }
}
const statePersistorThemeService = new StatePersistorThemeService();
class StatePersistorLayersOpenService {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let stop;
    stop = watchEffect(() => {
      this.persistLayersOpen();
      stop && stop();
    });
  }
  persistLayersOpen() {
    const appStore = useAppStore();
    const { layersOpen } = storeToRefs(appStore);
    watch(
      layersOpen,
      (value, oldValue) => {
        if (oldValue !== value) {
          storageHelper.setValue(SP_KEY_LAYERS_OPEN, value);
        }
      },
      { immediate: true }
    );
  }
  restoreLayersOpen() {
    const layersOpen = storageHelper.getValue(SP_KEY_LAYERS_OPEN) !== "false";
    const { setLayersOpen } = useAppStore();
    setLayersOpen(layersOpen);
  }
}
const statePersistorLayersOpenService = new StatePersistorLayersOpenService();
class StatePersistorMyMapService {
  bootstrap() {
    this.restore();
    let stop;
    stop = watchEffect(() => {
      this.persist();
      stop && stop();
    });
  }
  persist() {
  }
  restore() {
    const mapId = storageHelper.getValue(SP_KEY_MAPID);
    useAppStore().setMapId(mapId);
  }
}
const statePersistorMyMapService = new StatePersistorMyMapService();
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXMLHttpRequest() {
  return typeof XMLHttpRequest === "function" || (typeof XMLHttpRequest === "undefined" ? "undefined" : _typeof$2(XMLHttpRequest)) === "object";
}
function isPromise(maybePromise) {
  return !!maybePromise && typeof maybePromise.then === "function";
}
function makePromise(maybePromise) {
  if (isPromise(maybePromise)) {
    return maybePromise;
  }
  return Promise.resolve(maybePromise);
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var getFetch$1 = { exports: {} };
var browserPonyfill = { exports: {} };
var hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  if (hasRequiredBrowserPonyfill)
    return browserPonyfill.exports;
  hasRequiredBrowserPonyfill = 1;
  (function(module, exports2) {
    var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      (function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve2, reject) {
            reader.onload = function() {
              resolve2(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars2[i] = String.fromCharCode(view[i]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err) {
          exports3.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error2 = Error(message);
            this.stack = error2.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve2, reject) {
            var request3 = new Request(input, init2);
            if (request3.signal && request3.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve2(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request3.method, request3.url, true);
            if (request3.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request3.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request3.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request3.signal) {
              request3.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request3.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request3._bodyInit === "undefined" ? null : request3._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response2;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response2;
        exports3.fetch = fetch2;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module.exports = exports2;
  })(browserPonyfill, browserPonyfill.exports);
  return browserPonyfill.exports;
}
(function(module, exports2) {
  var fetchApi2;
  if (typeof fetch === "function") {
    if (typeof commonjsGlobal !== "undefined" && commonjsGlobal.fetch) {
      fetchApi2 = commonjsGlobal.fetch;
    } else if (typeof window !== "undefined" && window.fetch) {
      fetchApi2 = window.fetch;
    } else {
      fetchApi2 = fetch;
    }
  }
  if (typeof commonjsRequire !== "undefined" && (typeof window === "undefined" || typeof window.document === "undefined")) {
    var f = fetchApi2 || requireBrowserPonyfill();
    if (f.default)
      f = f.default;
    exports2.default = f;
    module.exports = exports2.default;
  }
})(getFetch$1, getFetch$1.exports);
const getFetch = getFetch$1.exports;
const fetchNode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFetch
}, [getFetch$1.exports]);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var fetchApi;
if (typeof fetch === "function") {
  if (typeof global !== "undefined" && global.fetch) {
    fetchApi = global.fetch;
  } else if (typeof window !== "undefined" && window.fetch) {
    fetchApi = window.fetch;
  } else {
    fetchApi = fetch;
  }
}
var XmlHttpRequestApi;
if (hasXMLHttpRequest()) {
  if (typeof global !== "undefined" && global.XMLHttpRequest) {
    XmlHttpRequestApi = global.XMLHttpRequest;
  } else if (typeof window !== "undefined" && window.XMLHttpRequest) {
    XmlHttpRequestApi = window.XMLHttpRequest;
  }
}
var ActiveXObjectApi;
if (typeof ActiveXObject === "function") {
  if (typeof global !== "undefined" && global.ActiveXObject) {
    ActiveXObjectApi = global.ActiveXObject;
  } else if (typeof window !== "undefined" && window.ActiveXObject) {
    ActiveXObjectApi = window.ActiveXObject;
  }
}
if (!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi)
  fetchApi = getFetch || fetchNode;
if (typeof fetchApi !== "function")
  fetchApi = void 0;
var addQueryString = function addQueryString2(url, params2) {
  if (params2 && _typeof$1(params2) === "object") {
    var queryString = "";
    for (var paramName in params2) {
      queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params2[paramName]);
    }
    if (!queryString)
      return url;
    url = url + (url.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
  }
  return url;
};
var fetchIt = function fetchIt2(url, fetchOptions, callback) {
  fetchApi(url, fetchOptions).then(function(response) {
    if (!response.ok)
      return callback(response.statusText || "Error", {
        status: response.status
      });
    response.text().then(function(data) {
      callback(null, {
        status: response.status,
        data
      });
    }).catch(callback);
  }).catch(callback);
};
var omitFetchOptions = false;
var requestWithFetch = function requestWithFetch2(options, url, payload, callback) {
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  var headers = defaults({}, typeof options.customHeaders === "function" ? options.customHeaders() : options.customHeaders);
  if (payload)
    headers["Content-Type"] = "application/json";
  var reqOptions = typeof options.requestOptions === "function" ? options.requestOptions(payload) : options.requestOptions;
  var fetchOptions = defaults({
    method: payload ? "POST" : "GET",
    body: payload ? options.stringify(payload) : void 0,
    headers
  }, omitFetchOptions ? {} : reqOptions);
  try {
    fetchIt(url, fetchOptions, callback);
  } catch (e) {
    if (!reqOptions || Object.keys(reqOptions).length === 0 || !e.message || e.message.indexOf("not implemented") < 0) {
      return callback(e);
    }
    try {
      Object.keys(reqOptions).forEach(function(opt) {
        delete fetchOptions[opt];
      });
      fetchIt(url, fetchOptions, callback);
      omitFetchOptions = true;
    } catch (err) {
      callback(err);
    }
  }
};
var requestWithXmlHttpRequest = function requestWithXmlHttpRequest2(options, url, payload, callback) {
  if (payload && _typeof$1(payload) === "object") {
    payload = addQueryString("", payload).slice(1);
  }
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  try {
    var x;
    if (XmlHttpRequestApi) {
      x = new XmlHttpRequestApi();
    } else {
      x = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
    }
    x.open(payload ? "POST" : "GET", url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    x.withCredentials = !!options.withCredentials;
    if (payload) {
      x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    var h2 = options.customHeaders;
    h2 = typeof h2 === "function" ? h2() : h2;
    if (h2) {
      for (var i in h2) {
        x.setRequestHeader(i, h2[i]);
      }
    }
    x.onreadystatechange = function() {
      x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {
        status: x.status,
        data: x.responseText
      });
    };
    x.send(payload);
  } catch (e) {
    console && console.log(e);
  }
};
var request = function request2(options, url, payload, callback) {
  if (typeof payload === "function") {
    callback = payload;
    payload = void 0;
  }
  callback = callback || function() {
  };
  if (fetchApi && url.indexOf("file:") !== 0) {
    return requestWithFetch(options, url, payload, callback);
  }
  if (hasXMLHttpRequest() || typeof ActiveXObject === "function") {
    return requestWithXmlHttpRequest(options, url, payload, callback);
  }
  callback(new Error("No fetch and no xhr implementation found!"));
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var getDefaults = function getDefaults2() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: false,
    parse: function parse2(data) {
      return JSON.parse(data);
    },
    stringify: JSON.stringify,
    parsePayload: function parsePayload(namespace, key, fallbackValue) {
      return _defineProperty({}, key, fallbackValue || "");
    },
    request,
    reloadInterval: typeof window !== "undefined" ? false : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: false,
    withCredentials: false,
    overrideMimeType: false,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
};
var Backend = function() {
  function Backend2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Backend2);
    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = "backend";
    this.init(services, options, allOptions);
  }
  _createClass(Backend2, [{
    key: "init",
    value: function init2(services) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults());
      this.allOptions = allOptions;
      if (this.services && this.options.reloadInterval) {
        setInterval(function() {
          return _this.reload();
        }, this.options.reloadInterval);
      }
    }
  }, {
    key: "readMulti",
    value: function readMulti(languages, namespaces, callback) {
      this._readAny(languages, languages, namespaces, namespaces, callback);
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      this._readAny([language], language, [namespace], namespace, callback);
    }
  }, {
    key: "_readAny",
    value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
      var _this2 = this;
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === "function") {
        loadPath = this.options.loadPath(languages, namespaces);
      }
      loadPath = makePromise(loadPath);
      loadPath.then(function(resolvedLoadPath) {
        if (!resolvedLoadPath)
          return callback(null, {});
        var url = _this2.services.interpolator.interpolate(resolvedLoadPath, {
          lng: languages.join("+"),
          ns: namespaces.join("+")
        });
        _this2.loadUrl(url, callback, loadUrlLanguages, loadUrlNamespaces);
      });
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url, callback, languages, namespaces) {
      var _this3 = this;
      this.options.request(this.options, url, void 0, function(err, res) {
        if (res && (res.status >= 500 && res.status < 600 || !res.status))
          return callback("failed loading " + url + "; status code: " + res.status, true);
        if (res && res.status >= 400 && res.status < 500)
          return callback("failed loading " + url + "; status code: " + res.status, false);
        if (!res && err && err.message && err.message.indexOf("Failed to fetch") > -1)
          return callback("failed loading " + url + ": " + err.message, true);
        if (err)
          return callback(err, false);
        var ret, parseErr;
        try {
          if (typeof res.data === "string") {
            ret = _this3.options.parse(res.data, languages, namespaces);
          } else {
            ret = res.data;
          }
        } catch (e) {
          parseErr = "failed parsing " + url + " to json";
        }
        if (parseErr)
          return callback(parseErr, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create2(languages, namespace, key, fallbackValue, callback) {
      var _this4 = this;
      if (!this.options.addPath)
        return;
      if (typeof languages === "string")
        languages = [languages];
      var payload = this.options.parsePayload(namespace, key, fallbackValue);
      var finished = 0;
      var dataArray = [];
      var resArray = [];
      languages.forEach(function(lng) {
        var addPath = _this4.options.addPath;
        if (typeof _this4.options.addPath === "function") {
          addPath = _this4.options.addPath(lng, namespace);
        }
        var url = _this4.services.interpolator.interpolate(addPath, {
          lng,
          ns: namespace
        });
        _this4.options.request(_this4.options, url, payload, function(data, res) {
          finished += 1;
          dataArray.push(data);
          resArray.push(res);
          if (finished === languages.length) {
            if (typeof callback === "function")
              callback(dataArray, resArray);
          }
        });
      });
    }
  }, {
    key: "reload",
    value: function reload2() {
      var _this5 = this;
      var _this$services = this.services, backendConnector = _this$services.backendConnector, languageUtils = _this$services.languageUtils, logger = _this$services.logger;
      var currentLanguage = backendConnector.language;
      if (currentLanguage && currentLanguage.toLowerCase() === "cimode")
        return;
      var toLoad = [];
      var append = function append2(lng) {
        var lngs = languageUtils.toResolveHierarchy(lng);
        lngs.forEach(function(l) {
          if (toLoad.indexOf(l) < 0)
            toLoad.push(l);
        });
      };
      append(currentLanguage);
      if (this.allOptions.preload)
        this.allOptions.preload.forEach(function(l) {
          return append(l);
        });
      toLoad.forEach(function(lng) {
        _this5.allOptions.ns.forEach(function(ns) {
          backendConnector.read(lng, ns, "read", null, null, function(err, data) {
            if (err)
              logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data)
              logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data);
            backendConnector.loaded("".concat(lng, "|").concat(ns), err, data);
          });
        });
      });
    }
  }]);
  return Backend2;
}();
Backend.type = "backend";
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: true },
    colors: { type: Array, required: true }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(props.colors, (color, i) => {
        return openBlock(), createElementBlock("span", {
          key: `${__props.styleName}-${i}`,
          class: "grow m-px",
          style: normalizeStyle(`background-color: ${color}`)
        }, " \xA0 ", 4);
      }), 128);
    };
  }
});
const SimpleStyleItem = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/simple-style-item.vue"]]);
const _hoisted_1$5 = { class: "text-white border-2 p-[10px] m-[10px]" };
const _hoisted_2$5 = { class: "text-center mb-3" };
const _hoisted_3$4 = ["title"];
const _hoisted_4$4 = { class: "text-white" };
const _hoisted_5$4 = ["title", "onClick"];
const _hoisted_6$2 = { class: "flex" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "simple-style-selector",
  setup(__props) {
    const { t } = useTranslation();
    const styleStore = useStyleStore();
    const styleService = useMvtStyles();
    const { bgStyle } = storeToRefs(styleStore);
    const simpleStyleConf = bgConfigFixture().simple_styles.road;
    const simpleStyles = ref(simpleStyleConf);
    watch(
      bgStyle,
      (newBgStyle) => simpleStyles.value = styleService.checkSelection(
        newBgStyle || [],
        simpleStyleConf
      ),
      { immediate: true }
    );
    function onStylingSelected(item) {
      styleStore.setSimpleStyle(item);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createCommentVNode(" TODO: create clean container for simple and advanced style editors "),
        createBaseVNode("h5", _hoisted_2$5, toDisplayString(unref(t)("Select a style", { ns: "client" })), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(simpleStyles.value, (item) => {
          return openBlock(), createElementBlock("div", {
            key: item.unlocalized_label,
            title: unref(t)(item.unlocalized_label, { ns: "client" }),
            class: normalizeClass(`${item.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
          }, [
            createBaseVNode("span", _hoisted_4$4, toDisplayString(unref(t)(item.unlocalized_label, { ns: "client" })) + " : ", 1),
            createBaseVNode("button", {
              title: unref(t)("Select style: {{styleName}}", {
                styleName: unref(t)(item.unlocalized_label)
              }),
              onClick: ($event) => onStylingSelected(item),
              class: "w-full"
            }, [
              createBaseVNode("span", _hoisted_6$2, [
                createVNode(SimpleStyleItem, {
                  colors: item.colors,
                  "style-name": item.unlocalized_label
                }, null, 8, ["colors", "style-name"])
              ])
            ], 8, _hoisted_5$4)
          ], 10, _hoisted_3$4);
        }), 128))
      ]);
    };
  }
});
const SimpleStyleSelector = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/simple-style-selector.vue"]]);
function getDefaultMediumStyling(bgLayer) {
  const layerDef = getLayerDef(bgLayer);
  if (!layerDef || !layerDef.medium_style_class)
    return [];
  return bgConfigFixture().medium_default_styles[layerDef.medium_style_class];
}
function getLayerDef(bgLayer) {
  return bgConfigFixture().bg_layers.find((l) => l.id == (bgLayer == null ? void 0 : bgLayer.id));
}
const _hoisted_1$4 = { class: "flex w-full items-center" };
const _hoisted_2$4 = {
  for: "colorId",
  class: "w-40"
};
const _hoisted_3$3 = { class: "grow" };
const _hoisted_4$3 = ["value"];
const _hoisted_5$3 = ["checked", "aria-label"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: true },
    colorEditable: { type: Boolean, required: true }
  },
  emits: ["changeStyle"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const { t } = useTranslation();
    function updateColor(colorChangeEvent) {
      if (colorChangeEvent.target) {
        const newStyle = {
          ...props.style,
          color: colorChangeEvent.target.value
        };
        emit2("changeStyle", newStyle);
      }
    }
    function updateVisibility(visibilityChangeEvent) {
      if (visibilityChangeEvent) {
        const newStyle = {
          ...props.style,
          visible: visibilityChangeEvent.target.checked
        };
        emit2("changeStyle", newStyle);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("label", _hoisted_2$4, toDisplayString(unref(t)(__props.style.label)), 1),
        createBaseVNode("div", _hoisted_3$3, [
          __props.colorEditable && props.style.color ? (openBlock(), createElementBlock("input", {
            key: 0,
            id: "colorId",
            type: "color",
            class: "w-11 h-5 py-[1px] px-[2px]",
            value: props.style.color,
            onInput: updateColor
          }, null, 40, _hoisted_4$3)) : createCommentVNode("v-if", true)
        ]),
        createBaseVNode("input", {
          type: "checkbox",
          class: "flex-none mr-3",
          checked: props.style.visible,
          onChange: updateVisibility,
          "aria-label": unref(t)("Show or hide {{ thematicName }}", {
            thematicName: props.style.label
          })
        }, null, 40, _hoisted_5$3)
      ]);
    };
  }
});
const MediumStyleItem = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/medium-style-item.vue"]]);
const _hoisted_1$3 = { class: "text-white border-2 p-[10px] m-[10px]" };
const _hoisted_2$3 = { class: "text-center mb-3" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: true }
  },
  setup(__props) {
    const props = __props;
    const COLOR_EDITABLE_LAYERS = ["basemap_2015_global"];
    const styleStore = useStyleStore();
    const { bgStyle } = storeToRefs(styleStore);
    const { t } = useTranslation();
    const isColorVisible = computed(
      () => COLOR_EDITABLE_LAYERS.includes(props.layer.name)
    );
    const styles = computed(
      () => bgStyle.value || getDefaultMediumStyling(props.layer)
    );
    function changeStyle(i, newStyle) {
      bgStyle.value = styles.value.map(
        (item, index2) => index2 === i ? newStyle : item
      );
      styleStore.disableExpertStyle();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("h5", _hoisted_2$3, toDisplayString(unref(isColorVisible) ? unref(t)("Select a colour for every theme") : unref(t)("Activate categories")), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(styles), (item, i) => {
          return openBlock(), createBlock(MediumStyleItem, {
            key: item.label,
            style: normalizeStyle(item),
            onChangeStyle: ($event) => changeStyle(i, $event),
            colorEditable: unref(isColorVisible)
          }, null, 8, ["style", "onChangeStyle", "colorEditable"]);
        }), 128))
      ]);
    };
  }
});
const MediumStyleSelector = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/medium-style-selector.vue"]]);
var FileSaver_min = { exports: {} };
(function(module, exports2) {
  (function(a, b) {
    b();
  })(commonjsGlobal, function() {
    function b(a2, b2) {
      return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
    }
    function c2(a2, b2, c3) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c3);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c3) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h2) {
      var i = f.URL || f.webkitURL, j = document.createElement("a");
      g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c2(b2, g2, h2) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
        i.revokeObjectURL(j.href);
      }, 4e4), setTimeout(function() {
        e(j);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h2) {
      if (g2 = g2 || f2.name || "download", "string" != typeof f2)
        navigator.msSaveOrOpenBlob(b(f2, h2), g2);
      else if (d(f2))
        c2(f2, g2, h2);
      else {
        var i = document.createElement("a");
        i.href = f2, i.target = "_blank", setTimeout(function() {
          e(i);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
        return c2(b2, d2, e2);
      var h2 = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j || h2 && i || a) && "undefined" != typeof FileReader) {
        var k = new FileReader();
        k.onloadend = function() {
          var a2 = k.result;
          a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k.readAsDataURL(b2);
      } else {
        var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
  });
})(FileSaver_min);
const _hoisted_1$2 = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" };
const _hoisted_2$2 = { class: "text-center mb-3" };
const _hoisted_3$2 = { class: "flex flex-row justify-center" };
const _hoisted_4$2 = { class: "absolute top-[70px] w-full text-center text-base" };
const _hoisted_5$2 = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" };
const _hoisted_6$1 = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:py-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
};
const _hoisted_7 = { class: "absolute top-[70px] w-full text-center text-base" };
const _hoisted_8 = ["href"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "expert-style-selector",
  setup(__props) {
    const mapStore = useMapStore();
    const styleStore = useStyleStore();
    const styleService = useMvtStyles();
    const { appliedStyle } = storeToRefs(styleStore);
    const { t } = useTranslation();
    function downloadCustomStyleFile() {
      const currentStyle = appliedStyle.value;
      const content = JSON.stringify(currentStyle);
      const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
      const fileName = "styles.json";
      FileSaver_min.exports.saveAs(blob, fileName);
    }
    function setCustomStyle(styleEvent) {
      const files = styleEvent.target.files;
      if ((files == null ? void 0 : files.length) !== 1) {
        return;
      }
      const file = files[0];
      const myFile = new File([], "./text.txt");
      myFile.text().then((res) => console.log(res));
      if (file.type !== "application/json") {
        return;
      }
      file.text().then((result) => {
        styleStore.enableExpertStyle();
        appliedStyle.value = JSON.parse(result);
      });
      styleEvent.target.value = "";
    }
    function getStyleUrl() {
      if (styleStore.styleId === null) {
        return styleService.getDefaultMapBoxStyleUrl(
          styleService.getVectorId(mapStore.bgLayer)
        );
      } else {
        return `${styleService.getvtstyleUrl_}?id=${styleStore.styleId}`;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("h5", _hoisted_2$2, toDisplayString(unref(t)("Lancer \xE9diteur externe ou importer json")), 1),
        createBaseVNode("div", _hoisted_3$2, [
          createBaseVNode("a", {
            href: "#",
            class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
            onClick: _cache[0] || (_cache[0] = ($event) => downloadCustomStyleFile())
          }, [
            createBaseVNode("span", _hoisted_4$2, toDisplayString(unref(t)("Download style")), 1)
          ]),
          createBaseVNode("div", _hoisted_5$2, [
            createBaseVNode("label", _hoisted_6$1, [
              createBaseVNode("span", _hoisted_7, toDisplayString(unref(t)("Upload style")), 1)
            ]),
            createBaseVNode("input", {
              class: "invisible",
              type: "file",
              name: "uploadMvtStyle",
              id: "uploadMvtStyle",
              onChange: setCustomStyle
            }, null, 32)
          ])
        ]),
        createBaseVNode("a", {
          href: `https://maputnik.github.io/editor/?style=${getStyleUrl()}`,
          target: "_blank",
          class: "lux-btn text-center"
        }, toDisplayString(unref(t)("Open Maputnik editor")), 9, _hoisted_8)
      ]);
    };
  }
});
const ExpertStyleSelector = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/expert-style-selector.vue"]]);
const _hoisted_1$1 = { key: 0 };
const _hoisted_2$1 = { class: "h-20 shrink-0 flex justify-between lux-panel-title" };
const _hoisted_3$1 = { key: 0 };
const _hoisted_4$1 = { key: 1 };
const _hoisted_5$1 = { key: 2 };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "style-selector",
  setup(__props) {
    const { t } = useTranslation();
    const mapStore = useMapStore();
    const appStore = useAppStore();
    const styleStore = useStyleStore();
    const { bgLayer } = storeToRefs(mapStore);
    const styles = useMvtStyles();
    const styleCapabilities = computed(
      () => styles.getStyleCapabilitiesFromLayer(bgLayer.value)
    );
    watch(bgLayer, (bgLayer2) => {
      if (!styles.isLayerStyleEditable(bgLayer2)) {
        appStore.closeStyleEditorPanel();
      }
    });
    let isSimpleStyleOpen = ref(false);
    let isMediumStyleOpen = ref(false);
    let isAdvancedStyleOpen = ref(false);
    function resetStyle() {
      styleStore.setStyle(null);
    }
    return (_ctx, _cache) => {
      return unref(styleCapabilities).isEditable ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("button", {
          onClick: _cache[0] || (_cache[0] = () => unref(appStore).closeStyleEditorPanel())
        }, "X close"),
        createBaseVNode("h2", _hoisted_2$1, toDisplayString(unref(t)("Style editor")), 1),
        unref(styleCapabilities).hasSimpleStyle ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = () => isRef(isSimpleStyleOpen) ? isSimpleStyleOpen.value = !unref(isSimpleStyleOpen) : isSimpleStyleOpen = !unref(isSimpleStyleOpen))
          }, toDisplayString(unref(t)("Choose a predefined style")), 1),
          createVNode(SimpleStyleSelector, {
            class: normalizeClass(unref(isSimpleStyleOpen) ? "" : "hidden")
          }, null, 8, ["class"])
        ])) : createCommentVNode("v-if", true),
        unref(styleCapabilities).hasAdvancedStyle ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
          createBaseVNode("button", {
            onClick: _cache[2] || (_cache[2] = () => isRef(isMediumStyleOpen) ? isMediumStyleOpen.value = !unref(isMediumStyleOpen) : isMediumStyleOpen = !unref(isMediumStyleOpen))
          }, toDisplayString(unref(t)("Change main colours")), 1),
          unref(bgLayer) ? (openBlock(), createBlock(MediumStyleSelector, {
            key: 0,
            class: normalizeClass(unref(isMediumStyleOpen) ? "" : "hidden"),
            layer: unref(bgLayer)
          }, null, 8, ["class", "layer"])) : createCommentVNode("v-if", true)
        ])) : createCommentVNode("v-if", true),
        unref(styleCapabilities).hasExpertStyle ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
          createBaseVNode("button", {
            onClick: _cache[3] || (_cache[3] = () => isRef(isAdvancedStyleOpen) ? isAdvancedStyleOpen.value = !unref(isAdvancedStyleOpen) : isAdvancedStyleOpen = !unref(isAdvancedStyleOpen))
          }, toDisplayString(unref(t)("Advanced settings")), 1),
          unref(bgLayer) ? (openBlock(), createBlock(ExpertStyleSelector, {
            key: 0,
            class: normalizeClass(unref(isAdvancedStyleOpen) ? "" : "hidden"),
            layer: unref(bgLayer)
          }, null, 8, ["class", "layer"])) : createCommentVNode("v-if", true)
        ])) : createCommentVNode("v-if", true),
        createBaseVNode("button", {
          onClick: resetStyle,
          class: "lux-btn"
        }, toDisplayString(unref(t)("Reset style", { ns: "client" })), 1)
      ])) : createCommentVNode("v-if", true);
    };
  }
});
const StyleSelector = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/components/style-selector/style-selector.vue"]]);
const _hoisted_1 = { class: "h-screen flex flex-col overflow-hidden" };
const _hoisted_2 = { class: "flex grow" };
const _hoisted_3 = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
};
const _hoisted_4 = {
  key: 1,
  class: "w-80 bg-primary"
};
const _hoisted_5 = { class: "map-wrapper grow bg-blue-100 relative" };
const _hoisted_6 = { class: "absolute right-1 top-16" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    statePersistorMyMapService.bootstrap();
    statePersistorLayersService.bootstrap();
    statePersistorThemeService.bootstrap();
    statePersistorLayersOpenService.bootstrapLayersOpen();
    statePersistorStyleService.bootstrapStyle();
    statePersistorBgLayerService.bootstrap();
    const { layersOpen, styleEditorOpen } = storeToRefs(useAppStore());
    watch(
      layersOpen,
      () => setTimeout(() => {
        resizeMap();
      }, 50)
    );
    onMounted(() => window.addEventListener("resize", resizeMap));
    onUnmounted(() => window.removeEventListener("resize", resizeMap));
    function traverseLayer(layer, ancestors, visitor) {
      const descend = visitor(layer, ancestors);
      if (descend && layer instanceof olLayerGroup) {
        layer.getLayers().forEach((childLayer) => {
          traverseLayer(childLayer, [...ancestors, layer], visitor);
        });
      }
    }
    function resizeMap() {
      const map2 = useMap().getOlMap();
      map2.updateSize();
      traverseLayer(map2.getLayerGroup(), [], (layer) => {
        if (layer instanceof MapBox) {
          layer.maplibreMap.resize();
        }
        return true;
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(HeaderBar),
        createBaseVNode("main", _hoisted_2, [
          createCommentVNode(" Layer panel "),
          unref(layersOpen) ? (openBlock(), createElementBlock("div", _hoisted_3, [
            createVNode(LayerPanel)
          ])) : createCommentVNode("v-if", true),
          createCommentVNode(" Style editor "),
          unref(styleEditorOpen) ? (openBlock(), createElementBlock("div", _hoisted_4, [
            createVNode(StyleSelector)
          ])) : createCommentVNode("v-if", true),
          createCommentVNode(" Map container and slider comparator "),
          createBaseVNode("div", _hoisted_5, [
            createVNode(MapContainer),
            createVNode(SliderComparator),
            createVNode(RemoteLayers),
            createVNode(LayerMetadata)
          ]),
          createCommentVNode(" Background selector "),
          createBaseVNode("div", _hoisted_6, [
            createVNode(BackgroundSelector)
          ])
        ]),
        createVNode(FooterBar, { class: "fixed bottom-5 sm:static z-20" }),
        createVNode(AlertNotifications)
      ]);
    };
  }
});
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "/home/mkirmse/devel/gmf/luxembourg-geoportail_reb/src/App.vue"]]);
initProjections();
instance.use(Backend);
instance.init({
  lng: "fr",
  debug: false,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: `/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json`
  }
});
const app = createApp(App);
app.use(createPinia());
app.use(install, { i18next: instance });
app.use(y);
const createElementInstance = (component = {}, app2 = null) => {
  return defineCustomElement(
    {
      setup: () => {
        const inst = getCurrentInstance();
        Object.assign(inst.appContext, app2._context);
        Object.assign(inst.provides, app2._context.provides);
      },
      render: () => h(component)
    },
    { shadowRoot: false }
  );
};
export {
  AlertNotifications,
  App,
  BackgroundSelector,
  DropdownList,
  FooterBar,
  HeaderBar,
  install as I18NextVue,
  LayerMetadata,
  LayerPanel,
  MapContainer,
  MapBox as MapLibreLayer,
  RemoteLayers,
  SliderComparator,
  y as VueDOMPurifyHTML,
  app,
  Backend as backend,
  createElementInstance,
  createPinia,
  defineCustomElement,
  instance as i18next,
  statePersistorBgLayerService,
  statePersistorLayersOpenService,
  statePersistorLayersService,
  statePersistorMyMapService,
  statePersistorStyleService,
  statePersistorThemeService,
  storeToRefs,
  themeSelectorService,
  useAppStore,
  useMap,
  useMapStore,
  useMvtStyles,
  useOpenLayers,
  useStyleStore,
  useThemeStore,
  watch
};
