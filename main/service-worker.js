function v(s){const e=s.startsWith("[")?s:`[${s}]`,t=n=>(...a)=>{const o=console?.[n]??console?.log;if(typeof o!="function")return;const c=o;try{c.call(console,e,...a)}catch{try{c(e,...a)}catch{}}};return{log:t("log"),info:t("info"),warn:t("warn"),error:t("error"),debug:t("debug")}}const E="7.0.4",u=`lux-geoportail-v4-v${E}`,i={APP_SHELL:`${u}-app-shell`,VT_TILES:`${u}-vt-tiles`,VT_STYLES:`${u}-vt-styles`,VT_SPRITES:`${u}-vt-sprites`,VT_GLYPHS:`${u}-vt-glyphs`},g=Object.values(i),_=self.registration?.scope??`${self.location.origin}/`,m=new URL(".",_).href,C=new URL(m).pathname,H=`${self.location.origin}/`,W=`${self.location.origin}/index.html`,A=m,k=new URL("index.html",m).href,I=Array.from(new Set([new URL("manifest.json",m).href,new URL("manifest.json",_).href,new URL("manifest.json",self.location.href).href])),j=s=>{try{return new URL(s).href}catch{const e=s.replace(/^\/+/,"");return new URL(e,m).href}},w=Array.from(new Set([A,k,H,W])),N=["/assets/locales/app.de.json","/assets/locales/app.en.json","/assets/locales/app.fr.json","/assets/locales/app.lb.json","/assets/locales/client.de.json","/assets/locales/client.en.json","/assets/locales/client.fr.json","/assets/locales/client.lb.json","/assets/locales/legends.de.json","/assets/locales/legends.en.json","/assets/locales/legends.fr.json","/assets/locales/legends.lb.json","/assets/locales/server.de.json","/assets/locales/server.en.json","/assets/locales/server.fr.json","/assets/locales/server.lb.json","/assets/locales/tooltips.de.json","/assets/locales/tooltips.en.json","/assets/locales/tooltips.fr.json","/assets/locales/tooltips.lb.json"],$=["/favicon.ico"],O=["https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"],F=N.map(j),V=$.map(j),x=Array.from(new Set([...w,...F,...V,...O])),T=["vectortiles.geoportail.lu","vectortiles-staging.geoportail.lu"],M=["roadmap","topomap","topomap_gray"],G=["Noto Sans Regular","Noto Sans Bold","Noto Sans Italic"],U="0-255",S=["cdnjs.cloudflare.com","map.geoportail.lu"],{log:h,warn:r}=v("SW");h(`Bootstrapping service worker v${E} / cache ${u}`);self.addEventListener("install",s=>{const e=(async()=>{await Y(),await Promise.allSettled([D(),q(),Z(),se()])})();s.waitUntil(e.catch(t=>{r("Install failed",t)}).finally(()=>self.skipWaiting()))});self.addEventListener("activate",s=>{const e=caches.keys().then(t=>{const n=t.map(a=>{if(a.startsWith("lux-geoportail-v4-")&&!g.includes(a))return h("Deleting legacy cache",a),caches.delete(a)});return Promise.all(n)});s.waitUntil(e.catch(t=>r("Cache cleanup failed",t)).then(()=>self.clients.claim()))});self.addEventListener("fetch",s=>{const{request:e}=s;if(e.method!=="GET")return;if(e.mode==="navigate"){s.respondWith(oe(e));return}const t=ne(e.url);if(t){s.respondWith(re(e,t));return}const n=ae(e.url);n&&(n===i.VT_STYLES?s.respondWith(ie(e,n)):s.respondWith(ce(e,n)))});self.addEventListener("message",s=>{const{data:e,ports:t}=s;if(e){if(e.type==="CLEAR_CACHE"){s.waitUntil(Promise.allSettled(g.map(n=>caches.delete(n))).then(n=>{n.some(o=>o.status==="rejected")?(r("Failed to clear some caches",n),t?.[0]?.postMessage({success:!1,error:"Some cache deletions failed"})):t?.[0]?.postMessage({success:!0})}).catch(n=>{r("Failed to clear caches",n),t?.[0]?.postMessage({success:!1,error:n.message})}));return}if(e.type==="GET_CACHE_SIZE"){s.waitUntil(de().then(n=>t?.[0]?.postMessage({size:n})));return}if(e.type==="SKIP_WAITING"){self.skipWaiting();return}if(e.type==="GET_SW_META"){t?.[0]?.postMessage({version:E,cacheVersion:u});return}}});async function Y(){const s=await caches.open(i.APP_SHELL);for(const e of w)try{const t=new Request(e,{credentials:"same-origin"}),n=await fetch(t);if(!n.ok||!n.headers.get("content-type")?.includes("text/html"))continue;await s.put(t,n.clone());const a=await n.clone().text();await z(a,e,s),await Promise.allSettled(w.filter(o=>o!==e).map(o=>s.put(new Request(o,{credentials:"same-origin"}),n.clone()))),h("Precaching entrypoint + linked assets succeeded via",e);return}catch(t){r("Failed to precache entrypoint",e,t)}r("Unable to precache entry HTML â€“ all attempts failed")}async function D(){const s=await caches.open(i.APP_SHELL),e=x.map(t=>L(s,t,{parseCss:!0}));await Promise.allSettled(e)}async function q(){for(const s of I){const e=new Request(s,{credentials:"same-origin"});try{const t=await fetch(e);if(!t.ok)throw new Error(`HTTP ${t.status}`);const n=await caches.open(i.APP_SHELL);await n.put(e,t.clone());const a=await t.json(),o=B(a);if(!o.size){r("No manifest assets detected to precache from",s);return}h("Precaching manifest assets from",s,"count:",o.size),await Promise.allSettled(Array.from(o).map(c=>L(n,c)));return}catch(t){r("Failed to precache build manifest assets via",s,t)}}}function B(s){const e=new Set,t=new Set,n=o=>{if(o)try{t.add(new URL(o,m).href)}catch(c){r("Failed to resolve manifest asset URL:",o,c)}},a=o=>{if(!o||e.has(o))return;e.add(o);const c=s[o];c&&(n(c.file),c.css?.forEach(n),c.assets?.forEach(n),c.imports?.forEach(a),c.dynamicImports?.forEach(a))};return Object.entries(s).forEach(([o,c])=>{(c?.isEntry||o.endsWith(".html"))&&a(o)}),t}async function z(s,e,t){const n=Array.from(J(s,e));n.length&&(h("Precaching linked HTML assets:",n.length),await Promise.allSettled(n.map(a=>L(t,a,{parseCss:!0}))))}function J(s,e){const t=new Set;return[/<script[^>]+src=["']([^"']+)["'][^>]*>/gi,/<link[^>]+rel=["'](?:modulepreload|preload|stylesheet)["'][^>]*href=["']([^"']+)["'][^>]*>/gi,/<link[^>]+rel=["'](?:icon|apple-touch-icon)["'][^>]*href=["']([^"']+)["'][^>]*>/gi,/<img[^>]+src=["']([^"']+)["'][^>]*>/gi].forEach(a=>{let o;for(;(o=a.exec(s))!==null;){const c=o[1];if(!c)continue;const l=c.trim().toLowerCase();if(!(l.startsWith("data:")||l.startsWith("javascript:")||l.startsWith("vbscript:")||l.startsWith("file:")||l.startsWith("blob:")||l.startsWith("mailto:")))try{const f=new URL(c,e).href,d=new URL(f),y=d.hostname,R=d.pathname,p=f.startsWith(self.location.origin),P=S.includes(y),b=R.match(/\.(js|css|svg|png|jpg|jpeg|gif|webp|ico|json|map)$/i);p||P||b?t.add(f):r("Skipping non-standard linked asset (not same-origin, CDN, or known asset type):",f)}catch(f){r("Failed to resolve linked asset URL:",c,f)}}}),t}async function L(s,e,t={}){try{const n=e.startsWith(self.location.origin),a=S.includes(new URL(e).hostname),o={credentials:n?"same-origin":"omit",mode:n?"same-origin":"cors"};let c;try{const p=new Request(e,o);c=await fetch(p)}catch(p){if(!n&&a&&o.mode==="cors"){r("CORS fetch failed, retrying without CORS for asset:",e);const P=new Request(e,{credentials:"omit",mode:"no-cors"});c=await fetch(P)}else throw p}const l=c.type==="opaque";if(!l&&!c.ok)throw new Error(`HTTP ${c.status}`);const f={credentials:n?"same-origin":"omit",mode:n?"same-origin":l?"no-cors":"cors"},d=new Request(e,f);await s.put(d,c.clone());const y=!l&&(n||a)&&c.headers.get("content-type")?.includes("text/css");if(!!(t.parseCss&&y)){const p=await c.clone().text();await K(p,e,s)}}catch(n){r("Failed to precache asset:",e,n)}}async function K(s,e,t){const n=Array.from(X(s,e));n.length&&(h("Precaching CSS-referenced assets:",n.length),await Promise.allSettled(n.map(a=>L(t,a))))}function X(s,e){const t=/url\(([^)]+)\)/gi,n=new Set;let a;for(;(a=t.exec(s))!==null;){const o=a[1].trim().replace(/^['"]|['"]$/g,"");if(!o)continue;const c=o.trim().toLowerCase();if(!(c.startsWith("data:")||c.startsWith("javascript:")||c.startsWith("vbscript:")||c.startsWith("file:")||c.startsWith("blob:")||c.startsWith("mailto:")))try{const l=new URL(o,e).href,f=new URL(l).hostname,d=l.match(/\.(woff2?|ttf|otf|eot|png|jpg|jpeg|gif|webp|svg)$/i);(l.startsWith(self.location.origin)||S.includes(f))&&(d?n.add(l):r("Skipping CSS url() reference that is not a known static asset type:",l))}catch(l){r("Failed to resolve CSS asset URL:",o,l)}}return n}async function Z(){const s=await caches.open(i.VT_STYLES),e=T.flatMap(n=>M.map(a=>`https://${n}/styles/${a}/style.json`));h("Precaching default vector styles + TileJSON metadata:",e.length,"files");const t=e.map(n=>Q(s,n));await Promise.allSettled(t)}async function Q(s,e){try{const t=new Request(e,{mode:"cors"}),n=await fetch(t);if(!n.ok)throw new Error(`HTTP ${n.status}`);await s.put(t,n.clone());const a=await ee(n.clone(),e);await Promise.allSettled(a.map(o=>te(s,o))),h("Precached style + metadata:",e)}catch(t){r("Failed to precache style:",e,t)}}async function ee(s,e){try{const n=(await s.json()).sources??{};return Object.values(n).map(a=>typeof a.url=="string"?new URL(a.url,e).href:null).filter(a=>!!a)}catch(t){return r("Failed to parse style JSON for TileJSON references",t),[]}}async function te(s,e){try{const t=new Request(e,{mode:"cors"}),n=await fetch(t);if(n.ok)await s.put(t,n.clone()),h("Precached metadata:",e);else throw new Error(`HTTP ${n.status}`)}catch(t){r("Failed to precache metadata:",e,t)}}async function se(){const s=await caches.open(i.VT_GLYPHS),e=T.flatMap(n=>G.map(a=>`https://${n}/fonts/${encodeURIComponent(a)}/${U}.pbf`));h("Precaching critical glyph ranges:",e.length,"files");const t=e.map(async n=>{try{const a=new Request(n,{mode:"cors"}),o=await fetch(a);if(!o.ok)throw new Error(`HTTP ${o.status}`);await s.put(a,o.clone()),h("Precached glyphs:",n)}catch(a){r("Failed to precache glyphs:",n,a)}});await Promise.allSettled(t)}function ne(s){try{const e=new URL(s);if(S.includes(e.hostname))return i.APP_SHELL;if(e.origin!==self.location.origin)return null;const t=e.pathname;return w.includes(e.href)||t===C||t==="/"||t.endsWith(".html")||t.startsWith("/assets/locales/")||t.match(/\/assets\/.*\.(js|css|svg|png|jpg|jpeg|gif|webp)$/)||t.match(/\.(woff2?|ttf|otf|eot)$/)||t.match(/\/(favicon\.ico|.*\.(png|jpg|jpeg|svg|gif|webp))$/)&&!t.includes("/styles/")?i.APP_SHELL:null}catch(e){return r("Failed to classify app shell resource:",s,e),null}}function ae(s){try{const e=new URL(s);if(!T.includes(e.hostname))return null;const t=e.pathname;return t.endsWith(".pbf")?t.includes("/fonts/")?i.VT_GLYPHS:i.VT_TILES:t.includes("/data/")&&t.endsWith(".png")?i.VT_TILES:t.includes("/data/")&&t.endsWith(".json")||t.includes("/styles/")&&t.endsWith("style.json")?i.VT_STYLES:t.includes("/styles/")&&(t.includes("/sprite")||t.endsWith(".png")||t.endsWith(".json"))?i.VT_SPRITES:null}catch(e){return r("Failed to classify vector resource:",s,e),null}}async function oe(s){const e=await caches.open(i.APP_SHELL);try{const n=await fetch(s);if(n.ok)return await e.put(s,n.clone()),await Promise.allSettled(w.map(a=>e.put(new Request(a,{credentials:"same-origin"}),n.clone()))),n;r("Navigation returned non-OK status:",n.status,s.url)}catch(n){r("Navigation failed, attempting cache fallback",n)}for(const n of w){const a=await e.match(new Request(n));if(a)return a}const t=await e.match(new Request(A));return t||new Response("<!doctype html><html><head><title>Offline</title></head><body><h1>You are offline</h1><p>This page has not been cached yet.</p></body></html>",{status:200,headers:{"Content-Type":"text/html"}})}async function ce(s,e){const t=await caches.open(e),n=await t.match(s);if(n)return n;try{const a=await fetch(s);return a.ok&&await t.put(s,a.clone()),a}catch(a){if(e===i.VT_GLYPHS&&le(s.url))return pe(s,a);throw e===i.VT_TILES&&ue(s.url)&&r("Tile not available offline, allowing MapLibre to reuse previously rendered tiles:",s.url),a}}async function re(s,e){const t=await caches.open(e),n=await t.match(s),a=fetch(s).then(c=>(c&&c.ok&&t.put(s,c.clone()),c)).catch(c=>{c instanceof TypeError||r("Background update failed for",s.url,c)});if(n)return a.catch(()=>{}),n;const o=await a;if(o)return o;throw new Error("Network response not available")}async function ie(s,e){const t=await caches.open(e);try{const n=await fetch(s);return n.ok&&await t.put(s,n.clone()),n}catch(n){r("Network failed, falling back to cache for",s.url);const a=await t.match(s);if(a)return a;throw n}}function le(s){return/\/fonts\/.*\.pbf$/.test(s)}function he(s){const e=s.match(/\/(\d+-\d+)\.pbf$/);return e?e[1]:null}function fe(s){return s===U}function pe(s,e){const t=he(s.url);if(!t||fe(t))throw r("Critical glyph missing:",s.url,e),e;return h("Optional glyph not cached (offline):",s.url),new Response(null,{status:404,headers:{"Content-Type":"application/x-protobuf"}})}function ue(s){return/\/data\/.*\.(pbf|png)$/.test(s)}async function de(){const s={entries:0,caches:g.length};for(const e of g){const n=await(await caches.open(e)).keys();s.entries+=n.length}return s}
